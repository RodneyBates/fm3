
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in brace-enclosed code, e.g., do not
            write "{ (* Don't do this. *) }".  This probably applies to double
            quote too.  lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error.
*)

(* Use metaprogram lalr to generate FM3Parser.i3, FM3Parser.m3, and
   _Debug, from this file, using command line:
   "../lib/lalr -M -g -i -t -d -D -k FM3Parser.lalr"
   (Omitting quotes.) 
*)

SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the front of the parser interface. */ 
EXPORT
  {
  
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* Where is the right place for this? *) 
  TYPE BrandKindTyp =
         { BkAbsent (* No BRANDED. *) 
         , BkAnon (* BRANDED, but no string given. *) 
         , BkExplicit (* BRANDED, with string following. *)
         } ;
         
  PROCEDURE BrandKindImage ( Kind : BrandKindTyp ) : TEXT ;

  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  {

(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3Base;
    IMPORT FM3CLOptions; 
    IMPORT FM3CLToks; 
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3SrcToks AS Stk;
    IMPORT FM3Pass1;
    IMPORT FM3ExpImp;
    FROM FM3Pass1 IMPORT Coord;
    FROM FM3Pass1 IMPORT PutBwd_Attribute;
    FROM FM3Pass1 IMPORT tParsAttribute;
    FROM FM3Pass1 IMPORT ParsAttrNull;
    FROM FM3Pass1 IMPORT MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;

    TYPE Bkt = BrandKindTyp ;
    
    PROCEDURE BrandKindImage ( Kind : BrandKindTyp ) : TEXT

    = BEGIN
        CASE Kind OF
        | Bkt . BkAbsent => RETURN "BkAbsent"
        | Bkt . BkAnon => RETURN "BkAnon"
        | Bkt . BkExplicit => RETURN "BkExplicit"
        END (*CASE*) 
      END BrandKindImage ; 
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Skt = FM3Scopes . ScopeKindTyp ;
    TYPE Dkt = FM3Decls . DeclKindTyp ; 
    TYPE Ukt = FM3Units . UnitKindTyp ;
    TYPE Bkt = BrandKindTyp ; 
  }

/* Parser module initialization. */ 
BEGIN
  { }
  
/* Parser module final cleanup. */ 
CLOSE { }
(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code uses the declarations directly from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)
(* These are not used by lalr: 

    StkUnknown                                   =     -1 (*16_01 *)
    StkBOF                                       =     -2 (*16_02 *)
    StkEOF                                       =     -3 (*16_03 *)
*)

    (* This column ---------------------------------------V
       is wrong, now that values are negative.
    *) 

    (* Reserved words: *) 
    StkRwAND                                     =      5 (*16_05 *)
    StkRwANY                                     =      6 (*16_06 *)
    StkRwARRAY                                   =      7 (*16_07 *)
    StkRwAS                                      =      8 (*16_08 *)
    StkRwBEGIN                                   =      9 (*16_09 *)
    StkRwBITS                                    =     10 (*16_0a *)
    StkRwBRANDED                                 =     11 (*16_0b *)
    StkRwBY                                      =     12 (*16_0c *)
    StkRwCASE                                    =     13 (*16_0d *)
    StkRwCONST                                   =     14 (*16_0e *)
    StkRwDIV                                     =     15 (*16_0f *)
    StkRwDO                                      =     16 (*16_10 *)
    StkRwELSE                                    =     17 (*16_11 *)
    StkRwELSIF                                   =     18 (*16_12 *)
    StkRwEND                                     =     19 (*16_13 *)
    StkRwEVAL                                    =     20 (*16_14 *)
    StkRwEXCEPT                                  =     21 (*16_15 *)
    StkRwEXCEPTION                               =     22 (*16_16 *)
    StkRwEXIT                                    =     23 (*16_17 *)
    StkRwEXPORTS                                 =     24 (*16_18 *)
    StkRwFINALLY                                 =     25 (*16_19 *)
    StkRwFOR                                     =     26 (*16_1a *)
    StkRwFROM                                    =     27 (*16_1b *)
    StkRwGENERIC                                 =     28 (*16_1c *)
    StkRwIF                                      =     29 (*16_1d *)
    StkRwIMPORT                                  =     30 (*16_1e *)
    StkRwIN                                      =     31 (*16_1f *)
    StkRwINTERFACE                               =     32 (*16_20 *)
    StkRwLOCK                                    =     33 (*16_21 *)
    StkRwLOOP                                    =     34 (*16_22 *)
    StkRwMETHODS                                 =     35 (*16_23 *)
    StkRwMOD                                     =     36 (*16_24 *)
    StkRwMODULE                                  =     37 (*16_25 *)
    StkRwNOT                                     =     38 (*16_26 *)
    StkRwOBJECT                                  =     39 (*16_27 *)
    StkRwOF                                      =     40 (*16_28 *)
    StkRwOR                                      =     41 (*16_29 *)
    StkRwOVERRIDES                               =     42 (*16_2a *)
    StkRwPROCEDURE                               =     43 (*16_2b *)
    StkRwRAISE                                   =     44 (*16_2c *)
    StkRwRAISES                                  =     45 (*16_2d *)
    StkRwREADONLY                                =     46 (*16_2e *)
    StkRwRECORD                                  =     47 (*16_2f *)
    StkRwREF                                     =     48 (*16_30 *)
    StkRwREPEAT                                  =     49 (*16_31 *)
    StkRwRETURN                                  =     50 (*16_32 *)
    StkRwREVEAL                                  =     51 (*16_33 *)
    StkRwROOT                                    =     52 (*16_34 *)
    StkRwSET                                     =     53 (*16_35 *)
    StkRwTHEN                                    =     54 (*16_36 *)
    StkRwTO                                      =     55 (*16_37 *)
    StkRwTRY                                     =     56 (*16_38 *)
    StkRwTYPE                                    =     57 (*16_39 *)
    StkRwTYPECASE                                =     58 (*16_3a *)
    StkRwUNSAFE                                  =     59 (*16_3b *)
    StkRwUNTIL                                   =     60 (*16_3c *)
    StkRwUNTRACED                                =     61 (*16_3d *)
    StkRwVALUE                                   =     62 (*16_3e *)
    StkRwVAR                                     =     63 (*16_3f *)
    StkRwWHILE                                   =     64 (*16_c0 00 *)
    StkRwWITH                                    =     65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =     66 (*16_c2 00 *)
    StkDot                                       =     67 (*16_c3 00 *)
    StkEqual                                     =     68 (*16_c4 00 *)
    StkOpenParen                                 =     69 (*16_c5 00 *)
    StkCloseParen                                =     70 (*16_c6 00 *)
    StkComma                                     =     71 (*16_c7 00 *)
    StkColon                                     =     72 (*16_c8 00 *)
    StkSubtype                                   =     73 (*16_c9 00 *)
    StkBecomes                                   =     74 (*16_ca 00 *)
    StkOpenBrace                                 =     75 (*16_cb 00 *)
    StkCloseBrace                                =     76 (*16_cc 00 *)
    StkStroke                                    =     77 (*16_cd 00 *)
    StkArrow                                     =     78 (*16_ce 00 *)
    StkEllipsis                                  =     79 (*16_cf 00 *)
    StkOpenBracket                               =     80 (*16_d0 00 *)
    StkCloseBracket                              =     81 (*16_d1 00 *)
    StkUnequal                                   =     82 (*16_d2 00 *)
    StkLess                                      =     83 (*16_d3 00 *)
    StkGreater                                   =     84 (*16_d4 00 *)
    StkLessEqual                                 =     85 (*16_d5 00 *)
    StkGreaterEqual                              =     86 (*16_d6 00 *)
    StkPlus                                      =     87 (*16_d7 00 *)
    StkMinus                                     =     88 (*16_d8 00 *)
    StkAmpersand                                 =     89 (*16_d9 00 *)
    StkStar                                      =     90 (*16_da 00 *)
    StkSlash                                     =     91 (*16_db 00 *)
    StkDeref                                     =     92 (*16_dc 00 *)
    StkOpenPragma                                =     93 (*16_dd 00 *)
    StkClosePragma                               =     94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =     95 (*16_df 00 *)
    StkIntLit                                    =     96 (*16_e0 00 *)
    StkLongIntLit                                =     97 (*16_e1 00 *)
    StkBasedLit                                  =     98 (*16_e2 00 *)
    StkLongBasedLit                              =     99 (*16_e3 00 *)
    StkRealLit                                   =    100 (*16_e4 00 *)
    StkLongRealLit                               =    101 (*16_e5 00 *)
    StkExtendedLit                               =    102 (*16_e6 00 *)
    StkTextLit                                   =    103 (*16_e7 00 *)
    StkWideTextLit                               =    104 (*16_e8 00 *)
    StkCharLit                                   =    105 (*16_e9 00 *)
    StkWideCharLit                               =    106 (*16_ea 00 *)
    StkLexErrChars                               =    107 (*16_eb 00 *)
    StkPragmaId                                  =    108 (*16_ec 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *)


(* Reserved identifier numeric lex codes need not be known to lalr for parsing,
   thus embedded semantic actions can refer to them directly as FM3SrcToks.Rid*,
   and no copying into here is necessary.
*) 

(* NOTE: Modula-3's idea that semicolons can optionally be separators
   or terminators fails to apply to imports, exports, or declarations,
   where they can only be terminators.  And BTW, commas are always separators.
   Regardless of the source syntax, in the internal token streams, a list
   always has separator tokens, never element terminators that are not part
   of the element itself. (But there is a *list* terminator, "*Rt".) 
*) 

(* --------------------- Precedence and associativity ---------------------- *)

OPER LEFT StkRwRAISES 
(*
  LEFT StkRwOR
  LEFT StkRwAND
  LEFT StkRwNOT 
  NONE StkEqual StkUnequal StkLess StkGreater StkLessEqual StkGreaterEqual
  LEFT StkPlus StkMinus StkAmpersand
  LEFT StkStar StkSlasn StkRwDIV StkRwMod
(*  LEFT StkPlus StkMinus *) 
  LEFT StkDeref
*)

(* --------------------------- Productions. ------------------------- *)

RULE

(* NOTE: regarding the parser's default setting of the PaPass1Coord field:
   A shift, including an error repair insertion, first copies the current pass1
   output pointer into .PaPass1Coord.  For a reduce, and if the semantic
   action doesn't set PaPass1Coord, then the parser sets it to a default.
   If the RHS is empty, this is the current pass 1 output pointer.  If the
   reduce is nonempty, this is a copy from the attribute of the RHS's
   leftmost token.

   NOTE: regarding the parser's default setting of the field Scan . Position:
   If it is not set by semantic actions, it too is set by the generated parser.
   If the RHS is empty, this is the current position.  If the reduce is
   nonempty, it is a copy from the attribute of the RHS's leftmost token.
*) 

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; } . 

   InterfaceLt : OptUnsafe StkRwINTERFACE NonreservedIdent IntfPragmas
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         (* Default Coord. *) 
         $$ . Scan . Position := $2 . Scan . Position ; 
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntKind := Ukt . UkInterface ; 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         FM3Pass1 . InterfaceId ( LUnitRef , $3 . Scan ) ;
         
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkInterface , $2 . Scan . Position ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } .

   InstInterface :
     InterfaceLt StkEqual NonreservedIdent GenActualList StkRwEND
     NonreservedIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ;
(*INCOMPLETE.*)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $6 . Scan , Ukt . UkInstInterface ) ; 
     } . 

   InterfaceMiddle : InterfaceLt StkSemicolon ImportList ExpImpDone 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         (* Default Position & Coord. *) 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkInterface *>
         FM3Scopes . PushOpenScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } . 
   Interface : InterfaceMiddle OpenDeclList StkRwEND NonreservedIdent StkDot
     { VAR LScopeRefOpen , LScopeRefDecl : FM3Scopes . ScopeRefTyp ;
       BEGIN
         (* Default Position & Coord. *) 
         LScopeRefOpen := FM3Scopes . PopOpenScopeRef ( ) ;
         <* ASSERT LScopeRefOpen . ScpKind = Skt . SkInterface *> 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeRt , LScopeRefOpen ^ . ScpSelfScopeNo ) ;
           
         LScopeRefDecl := FM3Scopes . PopDeclScopeRef ( ) ;
         <* ASSERT LScopeRefDecl = LScopeRefOpen *> 
           
         FM3Pass1 . DeclScopeRtL2R ( LScopeRefDecl ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRefDecl ^ . ScpSelfScopeNo ) ;
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef , $4 . Scan , Ukt . UkInterface ) ; 
         FM3Pass1 . CheckStdUnitPragma ( FM3Units . UnitStackTopRef ) ; 
         FM3Pass1 . PutBwd_LCIP_rip 
           ( Itk . ItkInterfaceLt
           , $1 . PaPass1Coord
           , FM3Units . UnitStackTopRef ^ . UntSelfUnitNo 
           , $1 . Scan . Position 
           ) ;
       END ; 
     } .

   IntfPragmas : /* Empty */ . 

   IntfPragmas : IntfPragmas IntfPragma .

   IntfPragma : StkOpenPragma StkPragmaId StkClosePragma
     { FM3Pass1 . RecognizedPragma ( $2 ) ; } .

   IntfPragma : StkOpenPragma StkIdent StkClosePragma
     { FM3Pass1 . UnrecognizedPragma ( $2 ) ; } .

   ModuleLt : OptUnsafe StkRwMODULE NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
       BEGIN
         (* Default Coord. *) 
         $$ . Scan . Position := $3 . Scan . Position ; 
         (* ^Module name position, in case no explicit EXPORTS. *) 
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         FM3Pass1 . ModuleId ( LUnitRef , $3 . Scan ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkModule , $2 . Scan . Position ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ; 
       END ; 
     } .

   InstModule :
     ModuleLt StkEqual NonreservedIdent GenActualList StkRwEND
     NonreservedIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ;
(*INCOMPLETE.*)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $6 . Scan , Ukt . UkInstModule ) ; 
     } . 

   ModuleMiddle : ModuleLt Exports StkSemicolon ImportList ExpImpDone 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         (* Default Position & Coord. *) 
         FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Scopes . PushOpenScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } . 

   Module : ModuleMiddle OpenDeclList
            StkRwBEGIN StmtList StkRwEND NonreservedIdent StkDot
     { VAR LScopeRefDecl , LScopeRefOpen : FM3Scopes . ScopeRefTyp ;
       BEGIN
         (* Default Position & Coord. *) 
         LScopeRefOpen := FM3Scopes . PopOpenScopeRef ( ) ;
         <* ASSERT LScopeRefOpen . ScpKind = Skt . SkModule *> 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeRt , LScopeRefOpen ^ . ScpSelfScopeNo ) ;
           
         LScopeRefDecl := FM3Scopes . PopDeclScopeRef ( ) ;
         <* ASSERT LScopeRefDecl = LScopeRefOpen *> 
         
         FM3Pass1 . DeclScopeRtL2R ( LScopeRefDecl ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRefDecl ^ . ScpSelfScopeNo ) ; 
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef , $6 .Scan , Ukt . UkModule ) ; 
         FM3Pass1 . PutBwd_LCIP_eCiP_riP 
           ( Itk . ItkModuleLt
           , $1 . PaPass1Coord
           , FM3Units . UnitStackTopRef ^ . UntSelfUnitNo 
           , $1 . Scan . Position 
           , $3 . PaPass1Coord
           , $3 . Scan . Position
           , $1 . Scan . Position 
           ) ; 
       END ; 
     } .

   GenInterfaceLt : StkRwGENERIC StkRwINTERFACE NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkInterface ) ; 
         LUnitRef := FM3Units . UnitStackTopRef ;
         FM3Pass1 . InterfaceId ( LUnitRef , $3 . Scan ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( LUnitRef 
                , Skt . SkInterface
                , $2 . Scan . Position
                ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ;
       END ; 
     } .  

   GenInterface :
       GenInterfaceLt GenInterfaceKind GenFormalList
       StkSemicolon ImportList ExpImpDone
       OpenDeclList StkRwEND NonreservedIdent StkDot 
     { (* Scope ref:
        FM3Pass1 . PutBwd_TI ( Itk . ItkDeclScopeLt , $1 . PaConstructNo ) ;
       *)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $8 . Scan , Ukt . UkGenInterface ) ; 
     } .

   GenModuleLt : StkRwGENERIC StkRwMODULE NonreservedIdent  
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkGenModule ) ;
         LUnitRef := FM3Units . UnitStackTopRef ;
         FM3Pass1 . ModuleId ( LUnitRef , $3 . Scan ) ;
         LScopeRef  
           := FM3Scopes . NewScopeRef
                ( LUnitRef
                , Skt . SkModule
                , $1 . Scan . Position
                ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef  ; 
       END ; 
     } . 

   GenModule :
       GenModuleLt GenModuleKind GenFormalList
       StkSemicolon ImportList ExpImpDone Block NonreservedIdent StkDot 
     { (* scope ref
          FM3Pass1 . PutBwd_TI ( Itk . ItkDeclScopeRt , $1 . PaConstructNo ) ;
       *) 
       FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; 
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $8 . Scan , Ukt . UkGenModule ) ;
     } .

   Block : /* COMPLETE ME */ . 

   OptUnsafe : StkRwUNSAFE
     { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe :
     { $$ . PaBool (* Unsafe? *) := FALSE (* Safe. *) ; }.

   OptSemicolon : StkSemicolon { $$ . PaPos2 := $1 . Scan . Position ; } .
   OptSemicolon : /*Empty*/
     { $$ . PaPos2 := FM3Scanner . Attribute . Position ; 
       (* If semicolon is absent, right end of item to left. *) 
     } . 
 
(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { (* Handle this in pass 1.
          MakeListPos
            ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
       *) 
     } .

(*  ----------------------------- Imports -----------------------. *) 

   ImportList : /*Empty*/ . 

   ImportList : ImportList Import .
     
   (* ASImport, including plain IMPORT *) 
   Import : StkRwIMPORT ImportItemPlusList StkSemicolon .
     
   ImportItemPlusList : ImportItem .
   ImportItemPlusList : ImportItemPlusList StkComma ImportItem . 

   ImportItem : NonreservedIdent
      { FM3ExpImp . ImportAS ( $1 . Scan , $1 . Scan ) } .
     
   ImportItem : NonreservedIdent StkRwAS NonreservedIdent
     { FM3ExpImp . ImportAS ( $1 . Scan , $3 . Scan ) } .
     
   (* FROM Id IMPORT ... *)
   FromImportLt : StkRwFROM NonreservedIdent StkRwIMPORT
     { $$ . PaRefany 
         := FM3ExpImp . GetInterface
              ( $2 . Scan . SaChars
              , $2 . Scan . Position
              , IsExport := FALSE
              ) ; 
     } . 
 
   Import : FromImportLt FromImportIdPlusList StkSemicolon . 

   FromImportIdPlusList : NonreservedIdent
     { EVAL FM3ExpImp . ImportDeclByIdent
              ( $0 . PaRefany (* Implied NARROW *) , $1 . Scan ) ; 
     } . 
   
   FromImportIdPlusList : FromImportIdPlusList StkComma NonreservedIdent
     { EVAL FM3ExpImp . ImportDeclByIdent
              ( $0 . PaRefany (* Implied NARROW *) , $3 . Scan ) ; 
     } .

   ExpImpDone : /* Empty */
     { FM3ExpImp . Done ( ) ; } . 

(* ------------------------------- Exports ------------------------- . *)

(* Exports are handled directly in pass 1, without writing internal tokens. *)

   Exports : /* Empty */
   /* An implied export. */ 
     { VAR LUnitRef : FM3Units . UnitRefTyp ;
       BEGIN
         IF FM3SharedUtils . CompareAToT 
              ( FM3Units . UnitStackTopRef ^ . UntUnitIdent ^ , "Main" )
            = FM3Base . CmpEQ
            AND NOT FM3CLToks . CltStdSources IN FM3CLOptions . OptionTokSet
         THEN (* Don't bring in Main.i3 when exported implicitly. *)
         ELSE  
           LUnitRef
             := FM3ExpImp . GetInterface 
                  ( FM3Units . UnitStackTopRef ^ . UntUnitIdent
                  , $0 . PaPos 
                  , IsExport := TRUE
                  ) ;
           FM3ExpImp . ImportAllDecls
             ( LUnitRef , $0 . Scan . Position ) ;
         END (*IF*) ; 
       END (* Block. *) ;  
     } .

   Exports : StkRwEXPORTS ExportIdPlusList .

   ExportIdPlusList : ExportIdent . 

   ExportIdPlusList : ExportIdPlusList StkComma ExportIdent . 

   ExportIdent : NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ;
       BEGIN
          LUnitRef
            := FM3ExpImp . GetInterface
                 ( $1 . Scan . SaChars
                 , $1 . Scan . Position
                 , IsExport := TRUE
                 ) ;
         FM3ExpImp . ImportAllDecls ( LUnitRef , $1 . Scan . Position ) ;
       END (* Block. *) ;  
     } .

(* ----------------------------- Identifiers ---------------------------- *)

   NonreservedIdent : StkIdent 
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
(* FIXME: emit error if it's reserved. *) 
     } .

   IdentRef : StkIdent /* Only in a reference context. */ 
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
       FM3Pass1 . IdentRefL2R ( $1 ) ;
     } .

   QualIdentRef : StkIdent StkDot StkIdent /* Only in a reference context. */  
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;  
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
       FM3Pass1 . QualIdentRefL2R ( $1 , $3 ) ;
     } .

(* Qualified or unqualified ident reference. *)

   IdentOrQualRef : IdentRef
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
     } . 
   IdentOrQualRef : QualIdentRef 
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
     } . 
   
   (* DeclIdListElems . PaInt > 0 is count of valid Idents. *)
   (* In source syntax, this list is never empty and always
      comma-separated.  Internally, invalid (reserved or repeated)
      idents may be removed, which could leave it empty.  If so,
      the entire declaration is removed after issuing error messages.
   *) 

   DeclIdListElems : StkIdent
     { IF FM3Pass1 . DeclIdL2R
            ( FM3Decls . TopDeclParseInfo ( ) . DiKind , IdAttribute := $1 )
       THEN (* Use this ident. *) 
         $$ . PaInt := 1 ;
         $$ . PaRefany := IntSets . Singleton ( $1 . Scan . SaAtom ) 
       ELSE
         $$ . PaInt := 0 ;
         $$ . PaRefany := IntSets . Empty ( ) 
       END (*IF*) ; 
     } . 
     
   DeclIdListElems : DeclIdListElems StkComma StkIdent
     { IF FM3Pass1 . DeclIdL2R
            ( FM3Decls . TopDeclParseInfo ( ) . DiKind , IdAttribute := $3 )
       (* ^No Itk separators here.  It would be kinda silly. *) 
       THEN (* Use this ident. *)
         $$ . PaInt := $1 . PaInt + 1 ;
         $$ . PaRefany
           := IntSets . Include
                ( NARROW ( $3 . PaRefany , IntSets . T ) , $3 . Scan . SaAtom ) ;
       ELSE
         $$ . PaInt := $3 . PaInt (* Valid Id count, no increase. *) ;
         $$ . PaRefany := $3 . PaRefany ; 
       END (*IF*) ;
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma IdentRef
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated maybe-qualified Idents. *)
   IdentOrQualRefStarList : /*Empty*/
     { $$ . PaInt := 0 ; } .
   IdentOrQualRefStarList : IdentOrQualRefPlusList
     { $$ . PaInt := $1 . PaInt ; } .
   IdentOrQualRefPlusList : IdentOrQualRef
     { $$ . PaInt := 1 } . 
   IdentOrQualRefPlusList : IdentOrQualRefPlusList StkComma IdentOrQualRef
     { $$ . PaInt := $1 . PaInt + 1 ; } .
     
   TypeName : IdentOrQualRef .

   (* Make ROOT and UNTRACED ROOT look to later passes like reserved idents,
      even though they are necessarily reserved words in source syntax, because
      their set of legal syntactic contexts differ from those of identifiers:
   *) 

   TypeName : StkRwROOT
     { FM3Pass1 . PutBwd_TIP
         ( Itk . ItkReservedIdRef , Stk . RidROOT , $1 . PaPos ) ; 
     } . 

   TypeName : StkRwUNTRACED StkRwROOT
     { FM3Pass1 . PutBwd_TIP
         ( Itk . ItkReservedIdRef
         , Stk . RidUNTRACEDROOT
         , $1 . PaPos
         ) ; 
     } . 

(* ------------------------- Constant Declarations -------------------- . *) 

   OptConstType : StkColon Type
     { $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ; } . 

   (* ConstDeclGroup is a list of type declarations all following
      a single occurrence of "CONST".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   ConstDeclGroupLt : StkRwCONST 
     { (* Default PaPos. *) } .

   ConstDeclGroup : ConstDeclGroupLt ConstDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   ConstDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   ConstDeclList : ConstDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   ConstDeclPlus : ConstDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   ConstDeclPlus : ConstDeclPlus ConstDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .

(* TODO:Maybe combine this with TypeDeclId and others, which differ only in Dkt. *) 
   ConstDeclId : StkIdent
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . PaInt (* Ident count, 0 if error, else 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkConst , IdAttribute := $1 ) ) ;
     } .

   ConstDeclTypeTok : /* Absent or present, all the same. */
     { FM3Pass1 . PutBwd_TP 
         ( Itk . ItkConstDeclType , FM3Scanner . Attribute . Position ) ;
     } .

   OptConstDeclType : StkColon Type 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $2 . Scan . Position 
     } .

   OptConstDeclType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkDeclTypeAbsent , FM3Scanner . Attribute . Position ) ; 
     } .

   ConstDeclValueTok : 
     { FM3Pass1 . PutBwd_TP 
         ( Itk . ItkConstDeclValue , FM3Scanner . Attribute . Position ) ;
     } .

   ConstDecl : ConstDeclId ConstDeclTypeTok OptConstDeclType
               ConstDeclValueTok StkEqual Expr  
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN
         FM3Pass1 . PutBwd_LCP_rp
           ( Itk . ItkConstDeclLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $2 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* -------------------------- Type Declarations. --------------------- . *)

   TypeRelation : StkEqual { $$ . PaTok1 := Itk . ItkTypeDeclLt ; } .

   TypeRelation : StkSubtype { $$ . PaTok1 := Itk . ItkSubtypeDeclLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. type decls. *) 

   (* TypeDeclGroup is a list of type declarations all following
      a single occurrence of "TYPE".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   TypeDeclGroupLt : StkRwTYPE
     { $$ . PaPos := $1 . Scan . Position; } .

   TypeDeclGroup : TypeDeclGroupLt TypeDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   TypeDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   TypeDeclList : TypeDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   TypeDeclPlus : TypeDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   TypeDeclPlus : TypeDeclPlus TypeDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .
 
   TypeDeclId : StkIdent
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . PaInt (* Ident count, 0 if error, else 1. *)
         := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkType , IdAttribute := $1 ) ) ; 
     } .

   TypeDecl : TypeDeclId TypeRelation Type  
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN 
         FM3Pass1 . PutBwd_LCP_eCP_rP
           ( $2 . PaTok1 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           
           , $2 . PaPass1Coord
           , $2 . Scan . Position
           
           , $1 . Scan . Position 
           ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $2 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* ----------------------------- Revelations ---------------------------- *) 

   RevelationRelation : StkEqual { $$ . PaTok1 := Itk . ItkFullRevealLt ; } .

   RevelationRelation : StkSubtype
     { $$ . PaTok1 := Itk . ItkPartialRevealLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. revelations. *) 

   (* RevelationGroup is a list of revelations all following
      a single occurrence of "REVEAL".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "REVEAL".  
   *)
   
   RevelationGroupLt : StkRwREVEAL
     {  $$. Scan . Position := $1 . Scan . Position  } .

   RevelationGroup : RevelationGroupLt RevelationList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   RevelationList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists. *)
         := FM3Scanner . Attribute . Position ; 
     } .

   RevelationList : RevelationPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   
   RevelationPlus : Revelation StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $2 . Scan . Position ; 
     } .

   RevelationPlus : RevelationPlus Revelation StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt semicolon. *) := $3 . Scan . Position ; 
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
       END (*IF*) ; 
     } .

   Revelation : IdentOrQualRef RevelationRelation Type  
     { $$ . PaInt := 1 (* BlockDecl count. *) ;
(* CHECK^ Do we really want to count this as a block decl?  It occupies a 
          space in the Blockdecl list, but does not introduce a new identifier,
          rather adds decl info about the identifier.
*) 
       FM3Pass1 . PutBwd_LCP_eCP_rP
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         
         , $1 . Scan . Position 
         ) ;
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDeclList, VarDecl . PaInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   VarDeclGroupLt : StkRwVAR
     { $$ . PaDeclDepth 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVarDeclLt
                  , DiIdListTok := Itk . ItkVarDeclIdListLt
                  , DiIdSepTok := Itk . ItkVarDeclIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDeclList 
      { $$ . PaInt := $2 . PaInt (* Decl count. *)  ;
        $$ . PaPos (* Rt Semicolon. *) := $2 . PaPos ;  
        <* ASSERT FM3Decls . PopDeclParseInfo ( ) = $1 . PaDeclDepth *>
      } . 

   VarDeclList : /*Empty*/ 
      { $$ . PaInt := 0 (* Decl count. *) ;
        $$ . PaPos (* No trailing semicolon exists. *)
          := FM3Scanner.Attribute . Position ; 
      } .

   VarDeclList : VarDeclPlus  
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ; 

       (*FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkVarDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
       *) 
     } . 
   
   VarDeclPlus : VarDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt Semicolon. *) := $2 . Scan . Position ;  
     } .

   VarDeclPlus : VarDeclPlus VarDecl StkSemicolon 
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt Semicolon. *) := $3 . Scan . Position ;  
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ;  
       END (*IF*) ; 
     } . 

(* Used for variable and field declarations. *)

   DeclType : /* Absent or present, do this. */ 
     { $$ . Scan . Position := $0 . Scan . Position ;
       FM3Pass1 . PutBwd_EP 
         ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok
         , $0 . Scan . Position 
         ) ;
     } .
     
   OptDeclType : StkColon Type 
     { $$ . PaBool (* Present. *) := TRUE ; 
       $$ . Scan . Position := $2 . Scan . Position ;
     } .
     
   OptDeclType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkDeclTypeAbsent , $0 . Scan . Position ) ; 
     } .
     
   DeclValue : /* Absent or present, do this. */
     { $$ . Scan . Position := $0 . Scan . Position ;
       FM3Pass1 . PutBwd_ZP 
         ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok
         , $0 . Scan . Position 
         ) ;
     } .
     
   OptDeclValue : StkBecomes Expr 
     { $$ . PaBool (* Present *) := TRUE ;
       $$ . Scan . Position := $2 . Scan . Position ;
      } .
     
   OptDeclValue : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkDeclValAbsent , $0 . Scan . Position ) ; 
     } . 

   VarDecl : VarDeclIds DeclType OptDeclType DeclValue OptDeclValue  
     { IF FM3Pass1 . RequireTypeAndOrValue
            ( $5 . Scan . Position , $3 . PaBool , $5 . PaBool ) 
       (* ^Check this even if there are no valid ids. *)
          AND $1 . PaInt > 0 
       THEN
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         FM3Pass1 . PutBwd_LCP_rp (* The whole declaration. *) 
           ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           ) ; 
       ELSE (* Skip all but the empty id list. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $2 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ; 
         $$ . PaInt := 0 (* Contribution to BlockDeclCt. *) ; 
       END (*IF*)
     } . 

   VarDeclIds : DeclIdListElems 
     { $$ . Scan . Position := $1 . Scan . Position ;
       MakeListPos (* The identifier list. *) 
         ( $$
         , FM3Decls . TopDeclParseInfo ( ) . DiIdListTok
         , $1 . Scan . Position
         , ElemsAttr := $1
         ) ; 
     } .

(* --------------------------------- Types ----------------------------- *)

   Type : TypeName 
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ; (* Needed? *) } . 

(* ------------------------ Builtin type names ---------------------- *)

   Type : StkRidADDRESS . 
   Type : StkRidBOOLEAN . 
   Type : StkRidCARDINAL . 
   Type : StkRidCHAR . 
   Type : StkRidEXTENDED . 
   Type : StkRidINTEGER . 
   Type : StkRidLONGCARD . 
   Type : StkRidLONGINT . 
   Type : StkRidLONGREAL . 
   Type : StkRidMUTEX . 
   Type : StkRidNULL . 
   Type : StkRidREAL . 
   Type : StkRidREFANY . 
   Type : StkRidTEXT . 
   Type : StkRidTYPECODE . 
   Type : StkRidWIDECHAR .

(* ------------------------------- REF Types --------------------------- *)
(*
   RefTypeOptUntraced : /* Empty */
     { $$ . PaBool := FALSE (* Not UNTRACED. *) } .

   RefTypeOptUntraced : StkRwUNTRACED 
     { $$ . PaBool := TRUE (* UNTRACED. *) } .
*) 
(* ------------------------------ REF Types ---------------------------- *)

   Type : RefTypeTraced .

   Type : RefTypeUntraced .
   
(* L2R parsing can't distinguish the start of a REF from an OBJECT type, and
   a brand of possibly unbounded complexity can be in between here and where
   we find out.  In case it turns out later to be OBJECT, we need to
   consistently reduce something to a Supertype even if it is not explicit
   in the syntax.  So we reduce empty to SupertypeAbsent regardless of whether
   it will be REF or OBJECT.  If it's REF, there can actually be no supertype
   of any kind, but handling of the REF type later will just ignore and
   discard the SupertypeAbsent. This reduction will only happen if the
   lookahead is BRANDED, REF, or OBJECT.
*) 
   
   RefTypeTraced : SupertypeAbsent Brand StkRwREF Type 
     { FM3Pass1 . PutBwd_LCBP_eCP_rbP
         ( Itk . ItkREFTypeLt
         , $1 . PaPass1Coord
         , FALSE (* IsUntraced. *) 
         , $1 . Scan . Position

         , $4 . PaPass1Coord 
         , $3 . Scan . Position

         , $1 . Scan . Position 
         ) ;
     } .

   RefTypeUntraced : StkRwUNTRACED SupertypeAbsent Brand StkRwREF Type
   /* Here, StkRwUNTRACED is not a reserved ident, but a syntactic
      delimiter that can occur only in this context. Elsewhere, the
      pair StkRwUNTRACED StkRwROOT behave like a compound reserved
      identifier, but won't match this production RHS. 
   */
     { FM3Pass1 . PutBwd_LCBP_eCP_rbP
         ( Itk . ItkREFTypeLt
         , $1 . PaPass1Coord
         , TRUE (* IsUntraced. *) 
         , $1 . Scan . Position

         , $5 . PaPass1Coord 
         , $4 . Scan . Position

         , $1 . Scan . Position 
         ) ;
     } .

(* ----------------------------- Array Types --------------------------- *)

   Type : OpenArrayType .

   OpenArrayTypeLt : StkRwARRAY StkRwOF
     { (* Default coord, position. *)
       FM3Pass1 . PutBwd_TP
         ( Itk .ItkSubscriptTypeAbsent , $2 . Scan . Position ) ;
       FM3Pass1 . PutBwd_TBP 
         ( Itk . ItkArrayTypeElmt , TRUE , $2 . Scan . Position ) ;
     } .

   OpenArrayType : OpenArrayTypeLt Type 
     { FM3Pass1 . PutBwd_LCBP_rbp
         ( Itk . ItkArrayTypeLt
         , $1 . PaPass1Coord
         , TRUE (* Open. *)  
         , $1 . Scan . Position 
         ) ;
     } .

   Type : FixedArrayType .

   FixedArrayTypeLt : StkRwARRAY SubrType StkRwOF 
     { (* Default coord, position. *)
       FM3Pass1 . PutBwd_TBP 
         ( Itk . ItkArrayTypeElmt , FALSE , $3 . Scan . Position ) ;
     } . 

   FixedArrayType : FixedArrayTypeLt Type 
     { FM3Pass1 . PutBwd_LCBP_rbp
         ( Itk . ItkArrayTypeLt
         , $1 . PaPass1Coord
         , FALSE (* Open. *)  
         , $1 . Scan . Position 
         ) ;
     } .

   SubrType : StkOpenBracket Expr StkEllipsis Expr StkCloseBracket 
     { FM3Pass1 . PutBwd_LCP_eCP_rP
         ( Itk . ItkSubrTypeLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         
         , $3 .  PaPass1Coord
         , $3 . Scan . Position
         
         , $1 . Scan . Position
         ) ;
     } .

(* ---------------------------- Enumeration types ---------------------- *)

   EnumTypeLt : StkOpenBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkEnum
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END; 
     } .

   EnumType : EnumTypeLt EnumLitList StkCloseBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkEnum *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . MakeListPos
           ( LHSAttr := $$ 
           , TokLt := Itk . ItkEnumLitListLt
           , Position := $1 . Scan . Position
           , ElemsAttr := $2 
           ) ; 
       END; 
     } .

   EnumLitList : /*Empty*/
     { $$ . PaInt (* Decl count. *) := 0 ; } .

   EnumLitList : EnumLitPlus
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } . 

   EnumLitPlus : EnumLit  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   EnumLitPlus : EnumLitPlus StkComma EnumLit
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ; } .
     
   EnumLit : StkIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R
                    ( Dkt . DkEnumLit
                    , IdAttribute := $1
                    , SepTok := Itk . ItkEnumLitListSep
                    , SepPosition := $0 . Scan . Position
                    , PriorIdCt := $-1 . PaInt 
                    )
                ) ;
       IF $$ . PaInt > 0
       THEN
       END (*IF*) 
     } . 

   Type : EnumType . 

(* --------------------------Field decl lists ------------------------- *)


(* Used in both record types and object types. *) 

   FieldDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty
          ( $$
          , Itk . ItkFieldDeclListLt
          , FM3Scanner . Attribute . Position
          ) ;
      } .

   FieldDeclList : FieldDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkFieldDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   FieldDeclPlus : VarDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   FieldDeclPlus : FieldDeclPlus StkSemicolon VarDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFieldDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ;
         $$ . PaDeclDepth (* DeclParseInfoDepth *) 
           := FM3Decls . PushDeclParseInfo
                ( FM3Decls . DeclParseInfoTyp
                    { DiDeclTok := Itk . ItkFieldDeclLt
                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                    , DiIdSepTok
                        := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                    , DiKind := Dkt . DkRecField 
                    }
                ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkRec
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the record type. *) 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END; 
     } . 
 
   Type : RecTypeLt FieldDeclList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkRec *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>  
         FM3Pass1 . PutBwd_LCIP_rip
           ( Itk . ItkRecTypeLt
           , $1 . PaPass1Coord
           , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
           , $1 . Scan . Position
           ) ;
         <* ASSERT FM3Decls . PopDeclParseInfo ( )
                   = $1 . PaDeclDepth (* DeclParseInfoDepth. *)
         *> 
       END; 
     } .

(* ------------------------------- Method Lists ----------------------------- *)

   MethodDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkMethodDeclListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   MethodDeclList : StkRwMETHODS 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkMethodDeclListLt , 0 , $1 . Scan . Position ) ; 
      } .

   MethodDeclList : StkRwMETHODS MethodDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkMethodDeclListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   MethodDeclPlus : MethodDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   MethodDeclPlus : MethodDeclPlus StkSemicolon MethodDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkMethodDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Method Signatures -------------------------- *)

   MethodDeclLt : StkIdent 
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkMethod , IdAttribute := $1 ) ) ;
     } . 

   MethodDecl : MethodDeclLt Signature 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . PaInt (* Valid method count. *) := $1 . PaInt ; 
         IF $$ . PaInt > 0
         THEN
           FM3Pass1 . PutBwd_LCIP_rip
             ( Itk . ItkMethodDeclLt
             , $1 . PaPass1Coord
             , $1 . Scan . SaAtom
             , $1 . Scan . Position 
             ) ;
         ELSE (* Method Id was invalid. *) 
           FM3Pass1 . PutBwd_LCI_ri
             ( Itk . ItkSkipLt , $2 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         END (*IF*) ; 
         LScopeRef := FM3Scopes . PopDeclScopeRef ( ) (* Formals. *) ;
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkFormals *>
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END (*Block*) 
     } . 

(* ------------------------------ Override Lists ---------------------------- *)

   OverrideList : /*Empty*/ /* No "OVERRIDES". */
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkOverrideListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   OverrideList : StkRwOVERRIDES /* "OVERRIDES" but none follow. */ 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkOverrideListLt , 0 , $1 . Scan . Position ) ; 
      } .

   OverrideList : StkRwOVERRIDES OverridePlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkOverrideListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   OverridePlus : Override  
     { $$ . PaInt (* Override count. *) := $1 . PaInt ; } .

   OverridePlus : OverridePlus StkSemicolon Override
     { $$ . PaInt (* Override count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkOverrideListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* -------------------------------- Overrides ------------------------------- *)

   OverrideLt : StkIdent 
     { $$ . PaInt (* valid ident count, 0 or 1. *)
              := ORD ( FM3Pass1 . OverrideIdentRefL2R ( $1 ) )
     } . 

   Override : OverrideLt StkEqual Expr 
     { IF $1 . PaInt < 1
       THEN (* Skip the whole override. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       ELSE
         $$ . PaInt (* Override count. *) := $1 . PaInt ;
         FM3Pass1 . PutBwd_LCP_eCP_rP
           ( Itk . ItkOverrideLt
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           
           , $2 . PaPass1Coord
           , $2 . Scan . Position

           , $1 . Scan . Position
           ) ;
       END (*IF*) 
     } . 

(* --------------------------------- Brands --------------------------------- *)

   Brand : /*Empty*/
     /* Happens when & only when REF or OBJECT is the lookahead. */
     { $$ . PaByte := ORD ( Bkt . BkAbsent ) ;
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkBrandAbsent , FM3Scanner . Attribute . Position ) ;
     } . 

   Brand : StkRwBRANDED
     { $$ . PaByte := ORD ( Bkt . BkAnon ) ;
       FM3Pass1 . PutBwd_LP 
         ( Itk . ItkBrandAnon , $1 . Scan . Position ) ;
     } . 

   Brand : StkRwBRANDED Expr
     { $$ . PaPass1Coord := $2 . PaPass1Coord ;
       $$ . Scan . Position := $2 . Scan . Position ;
       $$ . PaByte := ORD ( Bkt . BkExplicit ) ;
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkBrandExplicitLt
         , $2 . PaPass1Coord
         , $1 . Scan . Position
         ) ; 
     } . 

(* ------------------------------ Object Types ------------------------------ *)

   SupertypeAbsent : /* Empty */
     /* See comments at REF type. */ 
     { FM3Pass1 . PutBwd_LP
         ( Itk . ItkSupertypeAbsent , FM3Scanner . Attribute . Position ) ;
     } . 

   SupertypePresent : TypeName { (* Default Position & Coord. *) } .  
   
   SupertypePresent : ObjType { (* Default Position & Coord. *) } . 

   SupertypeSem : SupertypePresent  
     { (* Default Position & Coord. *) 
       (* ^The supertype will end up nested within its object type. *) 
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkSupertypeLt
         , $1 . PaPass1Coord 
         , $1 . Scan . Position
         ) ;
     } .

   ObjTypeLt : ObjSubtypeLt /* I.e., it has an explicit supertype. */
     { $$ . PaDeclDepth := $1 . PaDeclDepth ; 
       $$ . PaBool := TRUE (* Has explicit subtype. *) ;
       $$ . PaInt := $1 . PaInt (* Scope num. *) ;  
       $$ . PaByte := $1 . PaByte (* Brand kind, Bkt. *) ;
     } . 
     
   ObjSubtypeLt : SupertypeSem Brand StkRwOBJECT
     { (* Default Position & Coord. *) 
       FM3Pass1 . ObjTypeLtL2R
         ( $$ , $2 . PaByte (* Brand kind, Bkt. *) , $3 . Scan . Position ) ;   
     } .

   ObjTypeLt : ObjRootTypeLt
     /* Its supertype is implicitly ROOT, but syntactically absent. */  
     { $$ . PaDeclDepth := $1 . PaDeclDepth ; 
       $$ . PaBool := FALSE (* Has explicit subtype. *) ;
       $$ . PaInt := $1 . PaInt (* Scope num. *) ; 
       $$ . PaByte := $1 . PaByte (* Brand kind, Bkt. *) ; 
     } .

   ObjRootTypeLt : SupertypeAbsent Brand StkRwOBJECT
     { (* Default Position & Coord. *) 
       FM3Pass1 . ObjTypeLtL2R
         ( $$ , $2 . PaByte (* Brand kind, Bkt. *) , $2 . Scan . Position ) ;   
     } .

   ObjType : ObjTypeLt FieldDeclList MethodDeclList OverrideList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         (* Default Position & Coord. *)
         (* NOTE: This keeps the decl scope of the object type around during
                  the OverrideList, but it's harmless, because parsing will
                  ensure there are no decls in the OverrideList.
         *) 
         LScopeRef := FM3Scopes . PopDeclScopeRef ( ) ;
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkObj *>
         <* ASSERT LScopeRef ^ . ScpSelfScopeNo = $1 . PaInt *> 
         FM3Pass1 . PutBwd_LCIIP_riip
           ( Itk . ItkObjTypeLt
           , $1 . PaPass1Coord
           , $1 . PaByte (* BrandKind, Bkt. *)
           , LScopeRef ^ . ScpSelfScopeNo
           , $1 . Scan . Position 
           ) ;
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ;
         <* ASSERT FM3Decls . PopDeclParseInfo ( ) = $1 . PaDeclDepth *> 
       END; 
     } .
   Type : ObjType . 

(* ------------------ Procedure Types and Signatures ------------------- *)

   Type : StkRwPROCEDURE Signature  
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . PopDeclScopeRef ( ) (* Formals. *) ;
         <* ASSERT LScopeRef ^ . ScpKind = Skt . SkFormals *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ;
         FM3Pass1 . PutBwd_LCP_rp
           ( Itk . ItkProcTypeLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
       END (*Block*)
     } . 

(* Procedure signature (Without PROCEDURE or Ident).
   Works for procedure decl, procedure definition, type decl, method decl. *)  

   Signature : Formals ResultType Raises
     { VAR LToken : Itk . TokTyp ;
       BEGIN
         IF $2 . PaBool (* Is present. *) 
         THEN LToken := Itk . ItkSignatureFuncLt
         ELSE LToken := Itk . ItkSignatureProperLt 
         END (*IF*) ; 
         FM3Pass1 . PutBwd_LCP_rp
           ( LToken , $1 . PaPass1Coord , $1 . Scan . Position ) ;
       END (*Block*) 
     } . 

(* List of formal decls. *)

(* FormalsLt Formals.PaInt, FormalPlus.PaInt, and FormalsList.PaInt
   are formals count. *)

   FormalsLt : StkOpenParen 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LScopeRef (* Formals scope. *) 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkFormals  
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END ;
     } .

   Formals : FormalsLt FormalsList StkCloseParen
     { MakeListPos
         ( $$ , Itk . ItkFormalsListLt , $2 . Scan . Position , $2 ) ;
(* FIXME^ Maybe different tokens for different formal modes? *)
     } . 

   FormalsList : /* Empty formals list. */
     { $$ . PaInt := 0 (* Formals count. *) ; } .

   FormalsList : FormalPlus OptSemicolon
     { $$ . PaInt := $1 . PaInt (* Formals count. *) ; } . 
     
   FormalPlus : Formal 
     { $$ . PaInt := $1 . PaInt (* Formals count. *) ; } .

   FormalPlus : FormalPlus StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt (* Formals count. *);
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFormalsListLt 
         , $2 . PaPass1Coord 
         , $1 . PaInt (* Number of formals to left. *) 
         , $2 . Scan . Position
         ) ; 
     } .
     
(* Formal parameter modes. *) 
   FormalLt : /*Empty*/
     { (* Default coord. *)
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
       $$ . PaTok2 := Itk . ItkVALUEFormalLt ; 
       $$ . PaDeclDepth (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .
   FormalLt : StkRwVALUE 
     { (* Default position and cooord. *)
       $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
       $$ . PaTok2 := Itk . ItkVALUEFormalLt ; 
       $$ . PaDeclDepth (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { (* Default position and cooord. *)
       $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkVARFormal ) ;
       $$ . PaTok2 := Itk . ItkVARFormalLt ; 
       $$ . PaDeclDepth (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVARFormalLt
                  , DiIdListTok := Itk . ItkVARFormalIdListLt 
                  , DiIdSepTok := Itk . ItkVARFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVARFormal
                  }
              ) ;
     } .

   FormalLt : StkRwREADONLY
     { (* Default position and cooord. *)
       $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkROFormal ) ;
       $$ . PaTok2 := Itk . ItkROFormalLt ; 
       $$ . PaDeclDepth (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkROFormalLt
                  , DiIdListTok := Itk . ItkROFormalIdListLt 
                  , DiIdSepTok := Itk . ItkROFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkROFormal
                  }
              ) ;
     } .

   FormalType /* At Left of type. */ : FormalLt VarDeclIds 
     { (* Default coord. *)
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       $$ . PaByte := $1 . PaByte (* Decl kind. *) ; 
       $$ . PaTok2 := $1 . PaTok2 (* Lt tok of formal. *) ;
       $$ . PaDeclDepth := $1 . PaDeclDepth (* DeclParseInfoDepth. *) ;
       $$ . PaInt := $2 . PaInt ; 
       FM3Pass1 . PutBwd_EP 
         ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok
         , FM3Scanner . Attribute . Position
         ) ;
     } .

   FormalValue /* At left of value. */ : FormalType OptDeclType 
     { (* default coord. *)
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       $$ . PaByte := $1 . PaByte (* Decl kind. *) ; 
       $$ . PaTok2 := $1 . PaTok2 (* Lt tok of formal. *) ;
       $$ . PaDeclDepth := $1 . PaDeclDepth (* DeclParseInfoDepth. *) ;
       $$ . PaBool := $2 . PaBool (* Type is present. *) ;
       $$ . PaInt := $1 . PaInt ;
       IF VAL ( $1 . PaByte , Dkt ) = Dkt . DkVARFormal AND NOT $2 . PaBool 
       THEN
         FM3Messages . ErrorArr
           ( ARRAY OF REFANY 
               { "VAR formal must have a type (2.2.8)." } 
           , $2 . Scan . Position
           ) ;
       END (*IF*) ; 
       FM3Pass1 . PutBwd_ZP 
         ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok
         , FM3Scanner . Attribute . Position
         ) ;
     } .

   Formal : /* At right of entire formal. */ FormalValue OptDeclValue 
     { (* Default position. *) 
       $$ . PaByte := $1 . PaByte (* Decl kind. *) ; 
       $$ . PaTok2 := $1 . PaTok2 (* Lt tok of formal. *) ;
       $$ . PaDeclDepth := $1 . PaDeclDepth (* DeclParseInfoDepth. *) ;
       $$ . PaInt := $1 . PaInt ; 

       IF VAL ( $1 . PaByte , Dkt ) = Dkt . DkVARFormal   
       THEN 
         $$ . PaBool (* OK. *) := $1 . PaBool AND NOT $1 . PaBool ; 
         IF $2 . PaBool (* value is present? *) 
         THEN
           $$ . PaBool (* OK. *) := FALSE ; 
           FM3Messages . ErrorArr
             ( ARRAY OF REFANY 
                 { "VAR formal cannot have a default (2.2.8)." }
             , $2 . Scan . Position
             ) ;
         END (*IF*) ;
       ELSE (* VALUE or READONLY *)
         $$ . PaBool (* OK. *)
           := FM3Pass1 . RequireTypeAndOrValue
                ( $2 . Scan . Position , $1 . PaBool , $2 . PaBool ) 
       END (*IF*)
     ; IF $$ . PaBool    
       THEN (* Emit the declaration. *) 
         FM3Pass1 . PutBwd_LCP_rp 
           ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           ) ;
       ELSE (* Skip the decl, except for the idents. *)
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
       <* ASSERT FM3Decls . PopDeclParseInfo ( ) = $1 . PaDeclDepth *>
     } .

(* Result type of signature. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
       $$ . PaTok1 := Itk . ItkSignatureFuncLt ; 
       FM3Pass1 . PutBwd_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaPass1Coord , $1 . Scan . Position); 
     } .
     
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       $$ . PaTok1 := Itk . ItkSignatureProperLt ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
       $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ; 
     } .

(* RAISES of signature. *) 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *) ;
       FM3Pass1 . MakeListEmpty
         ( $$ , Itk . ItkRaisesSetLt , FM3Scanner . Attribute . Position ) ; 
     } .

   Raises : StkRwRAISES StkRwANY 
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3Pass1 . PutBwd_LP_rp
         ( Itk . ItkRaisesANY , $1 . Scan . Position ) ; 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace IdentOrQualRefStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $3 ) ;
     } . 
(* ------------------------------ Procedures ------------------------------ *)
   (* Body is absent: *) 
   OptProcBody : StkSemicolon
     /* Procedure body is absent in source code, not necessarily legally. */ 
     { VAR LScopeRefDecl : FM3Scopes . ScopeRefTyp ;
       BEGIN 
         $$ . PaTok1 := Itk . ItkProcDeclLt ;  
         IF FM3Units . CurrentUnitIsModule ( )
         THEN 
           FM3Messages . ErrorArr
             ( ARRAY OF REFANY
                 { "A procedure in a module must have a body (2.5)." } 
             , $0 . Scan . Position
             ) ;
         END (*IF*) ;  
         LScopeRefDecl := FM3Scopes . PopDeclScopeRef ( ) (* Formals. *) ;
         <* ASSERT LScopeRefDecl ^ . ScpKind = Skt . SkFormals *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRefDecl ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRefDecl ^ . ScpSelfScopeNo ) ;
         FM3Pass1 . PutBwd_TIP
           ( Itk . ItkProcDeclRt , $0 . Scan . SaAtom , $0 . Scan . Position ) ;
       END (*Block*) 
     } .

   ProcBodyLt : StkEqual
     /* Procedure has a body in source code, not necessarily legally. */
     { VAR LFormalsScopeRef : FM3Scopes . ScopeRefTyp ; 
       VAR LBodyScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         (* Default Coord and Position. *) 
         $$ . PaTok1 := Itk . ItkProcDefLt ; 
         FM3Pass1 . PutBwd_TP
           ( Itk . ItkProcDefBody , $1 . Scan . Position ) ;
         (* Make formals decl scope also open. *) 
         LFormalsScopeRef := FM3Scopes . PopDeclScopeRef ( ) (* Formals. *) ; 
         FM3Pass1 . DeclScopeRtL2R ( LFormalsScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LFormalsScopeRef ^ . ScpSelfScopeNo  ) ;
         FM3Scopes . PushOpenScopeRef ( LFormalsScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeLt , LFormalsScopeRef ^ . ScpSelfScopeNo ) ;
           
         (* Create Body scope, for both decls and refs:*)
         LBodyScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkProcBody  
                , $1 . Scan . Position 
                ) ;
         LBodyScopeRef ^ . ScpFormalsScopeRef := LFormalsScopeRef ; 
         FM3Scopes . PushDeclScopeRef ( LBodyScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeLt , LBodyScopeRef ^ . ScpSelfScopeNo ) ; 
         FM3Scopes . PushOpenScopeRef ( LBodyScopeRef ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeLt , LBodyScopeRef ^ . ScpSelfScopeNo ) ;
       END (*Block*) ; 
     } .

   (* Body itself: *) 
   OptProcBody : ProcBodyLt ProcBlock NonreservedIdent StkSemicolon 
     { VAR LScopeRefDecl : FM3Scopes . ScopeRefTyp ; 
       VAR LScopeRefOpen : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         (* Default Coord and position. *) 
         $$ . PaTok1 := $1 . PaTok1 ;
         (* Body Scope: *) 
         LScopeRefOpen := FM3Scopes . PopOpenScopeRef ( ) ; 
         <* ASSERT LScopeRefOpen ^ . ScpKind = Skt . SkProcBody *> 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeRt , LScopeRefOpen ^ . ScpSelfScopeNo ) ;
         LScopeRefDecl := FM3Scopes . PopDeclScopeRef ( ) ;
         <* ASSERT LScopeRefDecl = LScopeRefOpen *>
         FM3Pass1 . DeclScopeRtL2R ( LScopeRefDecl ) ;
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkDeclScopeRt , LScopeRefDecl ^ . ScpSelfScopeNo ) ;
           
         (* Formals scope, open only: *)
         LScopeRefOpen := FM3Scopes . PopOpenScopeRef ( ) ; 
         <* ASSERT LScopeRefOpen ^ . ScpKind = Skt . SkFormals *> 
         FM3Pass1 . PutBwd_TI
           ( Itk . ItkOpenScopeRt , LScopeRefOpen ^ . ScpSelfScopeNo ) ;

         FM3Pass1 . PutBwd_TIP
           ( Itk . ItkProcDefRt , $3 . Scan . SaAtom , $0 . Scan . Position ) ;
             
         IF NOT FM3Units . CurrentUnitIsModule ( )
         THEN 
           FM3Messages . ErrorArr
             ( ARRAY OF REFANY 
               { "A procedure in an interface must not have a body (2.5.2)." }
             , $1 . Scan . Position
             ) ;

           FM3Pass1 . PutBwd_LCI_ri (* Skip the body. *) 
             ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         END (*IF*) ; 
         
       END (*Block*) ;
     } .
    
   ProcDeclLt : StkRwPROCEDURE StkIdent 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       VAR LScopeKind : Skt ;
       BEGIN
         (* Default coord and position. *) 
         $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
         $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkProc , IdAttribute := $2 ) ) ;
       END (*Block*) 
     } . 

   ProcDecl : ProcDeclLt Signature OptProcBody
     { (* Default coord and position. *)
         $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
         $$ . PaInt (* Valid decl count. *) := $1 . PaInt ; 
         FM3Pass1 . PutBwd_LCIP
           ( $3 . PaTok1
           , $1 . PaPass1Coord
           , $1 . Scan . SaAtom
           , $1 . Scan . Position
           ) ;
     } . 

(* ---------------------------- Expressions ---------------------------- *)

   (* QualIdent and Expr each derive Ident dot Ident, with copies of the
      same semantic action.  Hopefully, difference in the left context
      will disabiguate this. 
   *)

   BinOpOp : /* Empty */
     { } . 

   Expr : E0  { (* Default position and coordinate. *) } .

   E0 : E1 { (* Default position and coordinate. *) } .
   
   E0Lt : E0 StkRwOR  
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkBinaryOpOperator , Stk . StkRwOR , $2 . Scan . Position ) ; 
     } .
     
   E0 : E0Lt E1
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , Stk . StkRwOR
         , $1 . Scan . Position 
         ) 
     } . 
   
   E1 : E2  { (* Default position and coordinate. *) } .
   
   E1Lt : E1 StkRwAND  
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkBinaryOpOperator , Stk . StkRwAND , $2 . Scan . Position ) ; 
     } .
     
   E1 : E1Lt E2
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord 
         , Stk . StkRwAND
         , $1 . Scan . Position 
         ) 
     } . 
   
   E2 : E3  { (* Default position and coordinate. *) } .
   
   E2 : StkRwNOT E3   
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkUnaryOpLt
         , $1 . PaPass1Coord 
         , Stk . StkRwNOT 
         , $1 . Scan . Position 
         ) 
     } . 

   E3 : E4  { (* Default position and coordinate. *) } .
   
   E3Lt : E3 ExprRelOp 
     { (*Default position and coordinate. *)
       $$ . PaTok1 := $2 . PaTok1 ;
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkBinaryOpOperator
         , $2 . PaTok1  
         , $2 . Scan . Position 
         ) ; 
     } .
     
   ExprRelOp : StkEqual        { $$ . PaTok1 := Stk . StkEqual ; } . 
   ExprRelOp : StkUnequal      { $$ . PaTok1 := Stk . StkUnequal ; } . 
   ExprRelOp : StkLess         { $$ . PaTok1 := Stk . StkLess ; } . 
   ExprRelOp : StkGreater      { $$ . PaTok1 := Stk . StkGreater ; } . 
   ExprRelOp : StkLessEqual    { $$ . PaTok1 := Stk . StkLessEqual ; } . 
   ExprRelOp : StkGreaterEqual { $$ . PaTok1 := Stk . StkGreaterEqual ; } .
   ExprRelOp : StkRwIN         { $$ . PaTok1 := Stk . StkRwIN ; } .

   E3 : E3Lt E4
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord 
         , $1 . PaTok1
         , $1 . Scan . Position 
         ) 
     } . 
   
   E4 : E5  { (* Default position and coordinate. *) } .
   
   E4Lt : E4 ExprAddOp 
     { (*Default position and coordinate. *)
       $$ . PaTok1 := $2 . PaTok1 ;
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkBinaryOpOperator
         , $2 . PaTok1  
         , $2 . Scan . Position 
         ) ; 
     } .
     
   ExprAddOp : StkPlus         { $$ . PaTok1 := Stk . StkPlus ; } . 
   ExprAddOp : StkMinus        { $$ . PaTok1 := Stk . StkMinus ; } . 
   ExprAddOp : StkAmpersand    { $$ . PaTok1 := Stk . StkAmpersand ; } .
 
   E4 : E4Lt E5
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord 
         , $1 . PaTok1
         , $1 . Scan . Position 
         ) 
     } . 
   
   E5 : E6 { (* Default position and coordinate. *) } .
   
   E5Lt : E5 ExprMulOp 
     { (*Default position and coordinate. *)
       $$ . PaTok1 := $2 . PaTok1 ;
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkBinaryOpOperator
         , $2 . PaTok1  
         , $2 . Scan . Position 
         ) ; 
     } .
     
   ExprMulOp : StkStar         { $$ . PaTok1 := Stk . StkStar ; } . 
   ExprMulOp : StkSlash        { $$ . PaTok1 := Stk . StkSlash ; } . 
   ExprMulOp : StkRwDIV        { $$ . PaTok1 := Stk . StkRwDIV ; } .
   ExprMulOp : StkRwMOD        { $$ . PaTok1 := Stk . StkRwMOD ; } . 

   E5 : E5Lt E6
     { (*Default position and coordinate. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord 
         , $1 . PaTok1
         , $1 . Scan . Position 
         ) 
     } . 

   E6 : E7 { (* Default position and coordinate. *) }  .
   
   E6 : ExprUnaryAddOp E7
     { (* Let's leave the unary + in there, just in case there is a need
          to note its position, for some reason.
       *) 
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkUnaryOpLt
         , $1 . PaPass1Coord
         , $1 . PaTok1
         , $1 . Scan . Position
         ) ; 
     } .

   (* These are distinguished syntactically by the parser. *) 
   ExprUnaryAddOp : StkPlus    { $$ . PaTok1 := Stk . StkUnaryPlus ; } . 
   ExprUnaryAddOp : StkMinus   { $$ . PaTok1 := Stk . StkUnaryMinus ; } . 
 
   (* E7 is a partial Cartesian product:
          { E8WOId, Id }
        X { Deref, Subscripts, Actuals, dot-id, absent-selector }
      Not cartesion-factored, because combinations Id-dot-Id and Id-Actuals
      are special cases. 
   *) 

   E7 : E8WOId StkDeref 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkDerefLt , $1 . PaPass1Coord , $2 . Scan . Position ) ; 
     } .
     
   E7 : E8WOId Subscripts 
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkSubscriptLt 
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position

         , $2 . PaPass1Coord 
         ) ; 
     } .
     
   E7 : E8WOId Actuals
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkCallLt 
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position

         , $2 . PaPass1Coord
         ) ; 
     } . 
     
   E7 : E8WOId StkDot NonreservedIdent 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkExprDotLt 
         , $1 . PaPass1Coord
         , $3 . Scan . SaAtom 
         , $2 . Scan . Position
         ) ; 
     } .

   E7 : E8WOId /* No selector. */ . 

   E7 : IdentRef StkDeref 
     { IF FM3Pass1 . VerifyIdentNotReserved
            ( $1 , $2 . Scan . Position , "be dereferenced" ) 
       THEN (* OK *) 
         FM3Pass1 . PutBwd_LCP_rp
           ( Itk . ItkDerefLt , $1 . PaPass1Coord , $2 . Scan . Position ) ;
       ELSE
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
         FM3Pass1 . PutNotUsable ( $1 . Scan . SaAtom , $1 . Scan . Position ) ;
       END (*IF*) ; 
     } .
     
   E7 : IdentRef Subscripts 
     { IF FM3Pass1 . VerifyIdentNotReserved
            ( $1 , $2 . Scan . Position , "be subscripted" ) 
       THEN (* OK *)
         FM3Pass1 . PutBwd_LCIP_eCip_rip
           ( Itk . ItkSubscriptLt 
           , $1 . PaPass1Coord 
           , $2 . PaInt 
           , $2 . Scan . Position

           , $2 . PaPass1Coord 
           ) ;
       ELSE
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
         FM3Pass1 . PutNotUsable ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       END (*IF*) ; 
     } .

   E7 : IdentRef Actuals 
     { IF FM3Pass1 . CheckReservedActualsCt ( ActualsAttr := $2 , TokAttr := $1 )
       THEN (* Actuals non problematic.  Handle it here *)
         FM3Pass1 . PutBwd_LCIP_eCip_rip
           ( Itk . ItkCallLt 
           , $1 . PaPass1Coord 
           , $2 . PaInt 
           , $2 . Scan . Position
           
           , $2 . PaPass1Coord
           ) ; 
       END (*IF*) ; 
     } . 
     
   E7 : StkIdent /* Empty */ { FM3Pass1 . IdentRefLone ( $1 ) ; } . 

   E7 : QualIdentRef
          /* Special case. Ident dot Ident. Can occur in other contexts. */
        . 
   
   (* Array subscript list.
      Commas are always separators, so parsed here as part of the list.
      List may not be empty.
   *) 
   Subscripts : StkOpenBracket SsPlusList StkCloseBracket
     { FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkSubscriptsPlusListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ; 
     } .
   
   SsPlusList : Expr 
     { $$ . PaInt (* Expression count *) :=  1 ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
     } . 
   
   SsPlusListLt : SsPlusList StkComma 
     { $$ . PaInt (* Expression count *) := $1 . PaInt ; 
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkSubscriptsPlusListSep
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

   SsPlusList : SsPlusListLt Expr 
     { $$ . PaInt (* Expression count *) := $1 . PaInt + 1 ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
     } . 

  (* Actual parameter list of call.
     Commas are always separators. so parsed as part of the list.
     List may be empty
  *)
  
   Actuals : StkOpenParen ActualList StkCloseParen
     { FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkActualsListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ;
       $$ . PaInt := $2 . PaInt ; 
     } .

   ActualList : /*Empty*/
     { $$ . PaInt (* Actual count *) :=  0 ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
     } . 

   ActualList : Actual 
     { $$ . PaInt (* Actual count *) :=  1 ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
     } . 
   
   ActualListLt : ActualList StkComma 
     { $$ . PaInt (* Actual count *) := $1 . PaInt ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
       FM3Pass1 . PutBwd_TIP
         ( Itk . ItkActualsListSep
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

   ActualList : ActualListLt Actual  
     { $$ . PaInt (* Actual count *) := $1 . PaInt + 1 ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
     } .

   Actual : Expr
     { (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkAnonActualLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
     } .

   Actual : NonreservedIdent StkBecomes Expr
     { (* Default PaPos. *) 
       (* Default PaPass1Coord. *)
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkNamedExprLt
         , $1 . PaPass1Coord
         , $1 . Scan . SaAtom  
         , $1 . Scan . Position
         ) ;
     } .

  (* E8WOId, Other than a single Ident, things that can be followed by
     some kinds of selectors:
  *) 

  (* Qualified (non-ident) expression . *) 
   E8WOId /* This is not a single ident.  It can have additional selectors. */ 
     : E8WOId StkDot NonreservedIdent
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkExprDotLt
         , $1 . PaPass1Coord
         , $3 . Scan . SaAtom
         , $2 . Scan . Position 
         )
     } .

  (* Literals.  *) 

   E8WOId : StkIntLit
     { FM3Pass1 . PutBwd_LNP
         ( Itk . ItkIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkLongIntLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkBasedLit
     { FM3Pass1 . PutBwd_LNNP 
         ( Itk . ItkBasedLit
         , $1 . Scan . SaArgValue 
         , 16L (* Base--default.*) 
(* FIXME ^ Get the real base from the scanner.
           As of 2024-4-5, only FM3DisAsm uses this. *) 
         , $1 . Scan . Position
         ) ;
     } .   
   E8WOId : StkLongBasedLit
     { FM3Pass1 . PutBwd_LNNP 
         ( Itk . ItkLongBasedLit
         , $1 . Scan . SaArgValue 
         , 16L (* Base--default.*) 
(* FIXME ^ Get the real base from the scanner.
           As of 2024-4-5, only FM3DisAsm uses this. *) 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkLongRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkExtendedLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkExtendedLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .
     
   E8WOId : StkCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkWideCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkWideCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .

   E8WOId : StkTextLit { FM3Pass1 . PutBwd_TextLit ( $1 ) ; } .
   
   E8WOId : StkWideTextLit { FM3Pass1 . PutBwd_WideTextLit ( $1 ) ; } .  

   E8WOId : StkOpenParen E0 StkCloseParen . 

(* ------------------------------ Blocks ------------------------------- *)

   AnonBlockLt : /*EMPTY*/
     {
     } .

   AnonBlock : AnonBlockLt OpenDeclList StkRwBEGIN StmtList StkRwEND
     {
     } .

   ProcBlockLt : /*EMPTY*/
     {
     } .

   ProcBlock : ProcBlockLt OpenDeclList StkRwBEGIN StmtList StkRwEND
     {
     } .

(* ------------------------ Block declarations ------------------------- *)

   BlockDecl : ConstDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : TypeDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ExceptDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : VarDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ProcDecl
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : RevelationGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
 
   (* A block declaration always includes a terminating semicolon in the
      source syntax, so it is parsed as part of the list element.  But
      we emit only Itk *separators*, as part of the list actions. 
      List may be empty.
   *) 

   OpenDeclList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkOpenDeclListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .
     
   OpenDeclList : BlockDeclPlus 
     { (* Default PaPos. *) 
       (* Default PaPass1Coord. *) 
       MakeListPos
         ( $$
         , Itk . ItkOpenDeclListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .
     
   BlockDeclPlus : BlockDecl 
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ;
       (* Default PaPos. *) 
       (* Default PaPass1Coord. *) 
       $$ . PaPos2 := $1 . PaPos2 ;
     } .

   BlockDeclPlusSepLt : BlockDeclPlus 
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ;
       (* Default PaPos. *) 
       $$ . PaPos2 := $1 . PaPos2 ;
       (* Default PaPass1Coord. *) 
       IF $1 . PaInt > 0
       THEN
         FM3Pass1 . PutBwd_TIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListSep
           , $1 . PaInt
           , $1 . Scan . Position 
           ) ;
       END (*IF*) ; 
     } .

   BlockDeclPlus : BlockDeclPlusSepLt BlockDecl  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt (* Decl count. *) ;
       (* Default PaPos. *)
       (* Default PaPass1Coord. *) 
       $$ . PaPos2 := $2 . PaPos2 ;
     } .

(* ---------------------------- Statements ----------------------------- *)

(* Semicolons are optional, parsed as components of the list. *)
(* List may be empty. *) 

   StmtList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkStmtListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .

   StmtList : StmtPlus 
     { (* Default PaPos. *)
       (* Default PaPass1Coord. *) 
       MakeListPos
         ( $$
         , Itk . ItkStmtListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .

   StmtPlus : Stmt
     { $$ . PaInt := 0 ;
       (* Default PaPos. *)
       (* Default PaPass1Coord. *) 
     } .

   StmtPlusSepLt : StmtPlus OptSemicolon 
     { $$ . PaInt := $1 . PaInt (* Count of stmts to left. *) ;
       $$ . PaPos2 := $2 . PaPos2 ;
       (* Default PaPos. *)
       (* Default PaPass1Coord. *) 

       FM3Pass1 . PutBwd_TIP (* Internal separator. *)
         ( Itk . ItkStmtListSep 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .
   
   StmtPlus : StmtPlusSepLt Stmt
     { $$ . PaInt := $1 . PaInt + 1 ;
       $$ . PaPos2 := $2 . PaPos2 ;
       (* Default PaPos. *)
       (* Default PaPass1Coord. *) 
     } .   
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { FM3Pass1 . PutBwd_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaPass1Coord
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


