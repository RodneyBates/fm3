(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023,       Rodney M. Bates.                                    *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in a semantic action, e.g.:
            (* Don't do this. *).  Probably applies to double quote too.
            lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error. *)
            
SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the parser interface. */ 
EXPORT
  { IMPORT FM3IntToks;
    IMPORT FM3ParsePass;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  { IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3ParsePass;
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_L , Push_LP , Push_LCr , Push_LCP_rp , Push_LCPeCrP , Push_LCPeCprp ,
      Push_ECPrP , Push_LCBr , Push_LCIri , Push_LI3 , Push_LI6 , Push_LCeCr ,
      Push_LCIeCri , Push_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeList , MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Sk = FM3Scopes . ScopeKindTyp ;
    TYPE Dk = FM3Decls . DeclKindTyp ; 
    TYPE Uk = FM3Units . UnitKindTyp ;

PROCEDURE Test ( READONLY Attr : tParsAttribute )
= VAR Debug : INTEGER := 0
; BEGIN
    IF Attr . PaInt = FIRST ( INTEGER)
    THEN
      Debug := 19
    END 
  END Test ;

  }

/* Parser module initialization. */ 
BEGIN
  { } 
/* Parser module final cleanup. */ 
CLOSE { }

(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code will use the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)

(* These are probably not used by lalr: 
    TkMinTok                                     =     1

    StkUnknown                                   =     1 (*16_01 *)
    StkBOF                                       =     2 (*16_02 *)
    StkEOF                                       =     3 (*16_03 *)
*)

    (* Reserved words: *) 
    StkRwAND                                     =     5 (*16_05 *)
    StkRwANY                                     =     6 (*16_06 *)
    StkRwARRAY                                   =     7 (*16_07 *)
    StkRwAS                                      =     8 (*16_08 *)
    StkRwBEGIN                                   =     9 (*16_09 *)
    StkRwBITS                                    =    10 (*16_0a *)
    StkRwBRANDED                                 =    11 (*16_0b *)
    StkRwBY                                      =    12 (*16_0c *)
    StkRwCASE                                    =    13 (*16_0d *)
    StkRwCONST                                   =    14 (*16_0e *)
    StkRwDIV                                     =    15 (*16_0f *)
    StkRwDO                                      =    16 (*16_10 *)
    StkRwELSE                                    =    17 (*16_11 *)
    StkRwELSIF                                   =    18 (*16_12 *)
    StkRwEND                                     =    19 (*16_13 *)
    StkRwEVAL                                    =    20 (*16_14 *)
    StkRwEXCEPT                                  =    21 (*16_15 *)
    StkRwEXCEPTION                               =    22 (*16_16 *)
    StkRwEXIT                                    =    23 (*16_17 *)
    StkRwEXPORTS                                 =    24 (*16_18 *)
    StkRwFINALLY                                 =    25 (*16_19 *)
    StkRwFOR                                     =    26 (*16_1a *)
    StkRwFROM                                    =    27 (*16_1b *)
    StkRwGENERIC                                 =    28 (*16_1c *)
    StkRwIF                                      =    29 (*16_1d *)
    StkRwIMPORT                                  =    30 (*16_1e *)
    StkRwIN                                      =    31 (*16_1f *)
    StkRwINTERFACE                               =    32 (*16_20 *)
    StkRwLOCK                                    =    33 (*16_21 *)
    StkRwLOOP                                    =    34 (*16_22 *)
    StkRwMETHODS                                 =    35 (*16_23 *)
    StkRwMOD                                     =    36 (*16_24 *)
    StkRwMODULE                                  =    37 (*16_25 *)
    StkRwNOT                                     =    38 (*16_26 *)
    StkRwOBJECT                                  =    39 (*16_27 *)
    StkRwOF                                      =    40 (*16_28 *)
    StkRwOR                                      =    41 (*16_29 *)
    StkRwOVERRIDES                               =    42 (*16_2a *)
    StkRwPROCEDURE                               =    43 (*16_2b *)
    StkRwRAISE                                   =    44 (*16_2c *)
    StkRwRAISES                                  =    45 (*16_2d *)
    StkRwREADONLY                                =    46 (*16_2e *)
    StkRwRECORD                                  =    47 (*16_2f *)
    StkRwREF                                     =    48 (*16_30 *)
    StkRwREPEAT                                  =    49 (*16_31 *)
    StkRwRETURN                                  =    50 (*16_32 *)
    StkRwREVEAL                                  =    51 (*16_33 *)
    StkRwROOT                                    =    52 (*16_34 *)
    StkRwSET                                     =    53 (*16_35 *)
    StkRwTHEN                                    =    54 (*16_36 *)
    StkRwTO                                      =    55 (*16_37 *)
    StkRwTRY                                     =    56 (*16_38 *)
    StkRwTYPE                                    =    57 (*16_39 *)
    StkRwTYPECASE                                =    58 (*16_3a *)
    StkRwUNSAFE                                  =    59 (*16_3b *)
    StkRwUNTIL                                   =    60 (*16_3c *)
    StkRwUNTRACED                                =    61 (*16_3d *)
    StkRwVALUE                                   =    62 (*16_3e *)
    StkRwVAR                                     =    63 (*16_3f *)
    StkRwWHILE                                   =    64 (*16_c0 00 *)
    StkRwWITH                                    =    65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =    66 (*16_c2 00 *)
    StkDot                                       =    67 (*16_c3 00 *)
    StkEqual                                     =    68 (*16_c4 00 *)
    StkOpenParen                                 =    69 (*16_c5 00 *)
    StkCloseParen                                =    70 (*16_c6 00 *)
    StkComma                                     =    71 (*16_c7 00 *)
    StkColon                                     =    72 (*16_c8 00 *)
    StkSubtype                                   =    73 (*16_c9 00 *)
    StkBecomes                                   =    74 (*16_ca 00 *)
    StkOpenBrace                                 =    75 (*16_cb 00 *)
    StkCloseBrace                                =    76 (*16_cc 00 *)
    StkStroke                                    =    77 (*16_cd 00 *)
    StkArrow                                     =    78 (*16_ce 00 *)
    StkEllipsis                                  =    79 (*16_cf 00 *)
    StkOpenBracket                               =    80 (*16_d0 00 *)
    StkCloseBracket                              =    81 (*16_d1 00 *)
    StkUnequal                                   =    82 (*16_d2 00 *)
    StkLess                                      =    83 (*16_d3 00 *)
    StkGreater                                   =    84 (*16_d4 00 *)
    StkLessEqual                                 =    85 (*16_d5 00 *)
    StkGreaterEqual                              =    86 (*16_d6 00 *)
    StkPlus                                      =    87 (*16_d7 00 *)
    StkMinus                                     =    88 (*16_d8 00 *)
    StkAmpersand                                 =    89 (*16_d9 00 *)
    StkStar                                      =    90 (*16_da 00 *)
    StkSlash                                     =    91 (*16_db 00 *)
    StkDeref                                     =    92 (*16_dc 00 *)
    StkOpenPragma                                =    93 (*16_dd 00 *)
    StkClosePragma                               =    94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =    95 (*16_df 00 *)
    StkIntLit                                    =    96 (*16_e0 00 *)
    StkLongIntLit                                =    97 (*16_e1 00 *)
    StkBasedLit                                  =    98 (*16_e2 00 *)
    StkLongBasedLit                              =    99 (*16_e3 00 *)
    StkRealLit                                   =   100 (*16_e4 00 *)
    StkLongRealLit                               =   101 (*16_e5 00 *)
    StkExtendedLit                               =   102 (*16_e6 00 *)
    StkTextLit                                   =   103 (*16_e7 00 *)
    StkWideTextLit                               =   104 (*16_e8 00 *)
    StkCharLit                                   =   105 (*16_e9 00 *)
    StkWideCharLit                               =   106 (*16_ea 00 *)
    StkLexErrChars                               =   107 (*16_eb 00 *)
    StkReservedId                                =   108 (*16_ec 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *) 

(* ------------------------------- Productions. ---------------------------- *)

(* NOTE regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the leftmost RHS's attribute.
*) 


RULE

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstModule ; } . 

   Interface : 
       OptUnsafe StkRwINTERFACE StkIdent InterfaceKind StkSemicolon
       Imports DeclList StkRwEND StkIdent StkDot .

   Module :
       OptUnsafe StkRwMODULE StkIdent Exports ModuleKind StkSemicolon
       Imports Block StkIdent StkDot .

   GenInterface :
       StkRwGENERIC StkRwINTERFACE StkIdent GenInterfaceKind GenFormalList
       StkSemicolon Imports DeclList StkRwEND StkIdent StkDot . 

   GenModule :
       StkRwGENERIC StkRwMODULE StkIdent GenModuleKind GenFormalList
       StkSemicolon Imports Block StkIdent StkDot . 

   InstInterface :
       OptUnsafe StkRwINTERFACE StkIdent InstInterfaceKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   InstModule :
       OptUnsafe StkRwMODULE StkIdent Exports InstModuleKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   CaptureCoord : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
     
   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 
 
(* ----------------------------- Identifier lists ---------------------- *)
(* List of one or more comma-separated Idents.*)
   IdPlusList : StkIdent 
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma StkIdent
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } .

   (* DeclIdListElems . PaInt > 0 is count of valid Idents. *) 

   DeclIdListElems : StkIdent
   /* PRE: $0 . PaTok1 is the Id list left token. */ 
     { $$ . PaUnnestCoord := $0 . PaUnnestCoord ; 
       $$ . PaInt (* Valid Id count. *)
         := ORD
              ( FM3ParsePass . DeclIdL2R
                  ( FM3Base . PositionNull
                  , $1
                  , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                  , PriorIdCt := 0 
                  )
              ) ;
EVAL $$ . PaInt ; 
Test ( $$ ) ; 
     } .
     
   DeclIdListElems : DeclIdListElems StkComma StkIdent
   /* PRE: $0 . PaTok1 is the Id list left token. */ 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord (* Needed? *) ;
       IF FM3ParsePass . DeclIdL2R
            ( $2 . Scan . Position
            , $3
            , FM3Decls . TopDeclInfo ( ) . DiIdListTok
            , PriorIdCt := $1 . PaInt
            ) 
       THEN (* Use this ident. *) $$ . PaInt := $1 . PaInt + 1 ;  
       ELSE $$ . PaInt := $1 . PaInt (* Valid Id count, no increase. *) ; 
       END (*IF*) ; 
EVAL $$ . PaInt ; 
Test ( $$ ) ; 
     } .

(* TODO: Inline this any remaining places: *) 
   DeclIdListRt : /* Empty */
   /* $0 must be a top-level DeclIdListElems.  */
     { IF $0 . PaInt = 0 (* No usable idents. *)
       THEN (* Skip entire decl, along with any Ids. *) 
         $$ . PaInt := FM3ParsePass . StartSkipping ( ) ;
       ELSE
         $$ . PaInt := FM3ParsePass . SkipDepth ; 
         MakeListPos (* The identifier list. *) 
           ( $$
           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
           , $0 . Scan . Position
           , ElemsAttr := $0
           ) ; 
       END (*IF*)
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated qualified Idents. *)
   QualIdStarList : QualIdStarList StkComma QualId
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   QualIdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 
     
(* Qualified ident. *)   
   QualId : StkIdent .
   QualId : StkIdent StkDot StkIdent
     { Push_LCeCr
         ( Itk . ItkQualIdLt ,  $1 . PaUnnestCoord , $3 . PaUnnestCoord );
     } .

(*  ----------------------------- Imports -----------------------. *) 

   Imports : ImportsLt ImportsRecurse ImportsRt 
     { $$ . PaInt := $2 . PaInt (* Imported interface Count. *) ;
       $$ . PaLong := $2 . PaLong (* Imported unqualified Ident Count. *) ;
     } .
   ImportsLt : /*Empty*/ { FM3ParsePass . ImportsLt ( ) ; } . 
   ImportsRt : /*Empty*/ { FM3ParsePass . ImportsRt ( ) ; } . 
   ImportsRecurse : ImportsRecurse ImportItem  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt ;
       $$ . PaLong := $1 . PaLong + $2 . PaLong ;
     } .
   ImportsRecurse : /*Empty*/
     { $$ . PaInt := 0; 
       $$ . PaLong := 0L; 
     } . 

   (* IMPORT .. *) 
   ImportItem : StkRwIMPORT ImportIntfPlusList StkSemicolon  
     { $$ . PaInt := $2 . PaInt ;
       $$ . PaLong := 0L ; 
     } .
   ImportIntfPlusList : StkIdent 
     { $$ . PaInt := 1 ;
       FM3ParsePass . Import
         ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       Push_LI3
         ( Itk . ItkImport
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         ) ;
     } . 
   ImportIntfPlusList : ImportIntfPlusList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ;
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3ParsePass . Import
         ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
       Push_LI3
         ( Itk . ItkImport
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

   (* FROM Id IMPORT ... *) 
   ImportItem : FromImportPlusList StkSemicolon 
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaLong := $1 . PaLong ; 
     } .
   FromImportPlusList : StkRwFROM StkIdent StkRwIMPORT StkIdent
     { $$ . PaInt := 1 (* InterfaceCt. *) ;
       $$ . PaLong := 1L ;
       $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
       $$ . Scan . Position := $2 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $2 . Scan . SaAtom
         , $2 . Scan . Position 
         , $4 . Scan . SaAtom
         , $4 . Scan . Position 
         ) ; 
       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $2 . Scan . SaAtom
         , $2 . Scan . Position . Line
         , $2 . Scan . Position . Column
         , $4 . Scan . SaAtom
         , $4 . Scan . Position . Line
         , $4 . Scan . Position . Column
         ) ;
     } . 
   FromImportPlusList : FromImportPlusList StkComma StkIdent
     { $$ . PaInt := 1 ;
       $$ . PaLong := $1 . PaLong + 1L ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $1 . Scan . SaAtom
         , $1 . Scan . Position 
         , $3 . Scan . SaAtom
         , $3 . Scan . Position 
         ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

(* IMPORT Id AS Id; *)
(*
   ImportItem : StkRwFROM StkIdent StkRwIMPORT IdPlusList StkSemicolon 
     { $$ . PaInt := 1 ;
       $$ . PaLong := VAL ( $4 . PaInt (* IdPlusList Ct. *) , LONGINT ) ;
       Push_LCIeCri
         ( Itk . ItkImportAsLt
         , $1 . PaUnnestCoord
         , $4 . PaInt
         , $3 . PaUnnestCoord
         );
     } .
*)
(* ------------------------------- Exports ------------------------- . *)

(* Exports.  Possibly absent, in which case construct "EXPORTS Main".
   Otherwise contains at least one ident. Bracket with ItkportList*.
*) 

   ExportsLt : StkRwEXPORTS
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaTok1 := Itk . ItkExportIdListLt ; 
(* TODO: check push/pop of scope numbers, similarly to DeclInfoDepth. *)
       $$ . PaConstructNo 
         := FM3ParsePass . ScopeLtL2R
              ( FM3Scopes . ScopeKindTyp . SkExports , $1 . Scan . Position ) ;
       (* Although an export list is not exactly a scope, we Use the scope
          and DeclInfo mechanisms to check reserved and duplicated idents.
          ScopeRtL2R will handle the legal ones specially.
       *)
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkExportIdListLt
                  , DiDeclTok := Itk . ItkNull
                  , DiKind := Dk . DkExports 
                  }
              ) ;
     
     } . 

   Exports : ExportsLt DeclIdListElems  
     { IF $2 . PaInt <= 0 (* No usable idents. *)
       THEN (* Skip entire decl, along with any Ids. *) 
         $$ . PaInt := FM3ParsePass . StartSkipping ( ) ;
       ELSE 
         MakeListPos (* The identifier list. *) 
           ( $$
           , Itk . ItkExportIdListLt
           , $2 . Scan . Position
(* CHECK: MakeListPos could take the position from ElemsAttr.
          Do ther calls have the same property? *) 
           , ElemsAttr := $2
           ) ; 
       END (*IF*) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt (* Scope No. *) *>
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ; 
     } .

   Exports : /*Empty*/
     { FM3ParsePass . PushEXPORTSMain ( $0 . Scan . Position ) ; } .

(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos
         ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* -------------------------- Type Declarations. --------------------- . *)

   TypeDeclGroup : StkRwTYPE TypeDecls .
   TypeDecls : TypeDecl . 
   TypeDecls : TypeDecls TypeDecl . 
   TypeDecl : StkIdent StkEqual Type StkSemicolon
     { Push_LCPeCrP
         ( Itk . ItkTypeDeclLt
         , $0 . PaUnnestCoord
         , $1 . Scan . Position
         , $2 . PaUnnestCoord
         , $4 . Scan . Position
         ) ; 
     } .

(* ------------------------- Constant Declarations -------------------- . *) 

   ConstDeclGroup : StkRwCONST ConstDecls .
   ConstDecls : ConstDecl . 
   ConstDecls : ConstDecls ConstDecl . 
   ConstDecl : StkIdent OptConstType StkEqual Expr StkSemicolon .
   OptConstType : StkColon Type
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ; } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDecls, VarDecl . PaInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   
   VarDeclGroupLt : StkRwVAR
     { $$ . PaTok1 := Itk . ItkVarDeclIdListLt ; 
       $$ . PaTok2 := Itk . ItkVarDeclLt ; 
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkVarDeclIdListLt
                  , DiDeclTok := Itk . ItkVarDeclLt
                  , DiKind := Dk . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDecls StkSemicolon 
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
      } . 

   (* VarDecls is also used for record and object fields. *)
   (* Also see DeclIdListElems. *)
   VarDecls : VarDecl
   /* PRE: $0 . PaTok1 is the Id list left token. */ 
   /* PRE: $0 . PaTok2 is the variable decl left token */  
     { $$ . PaInt (* Decl count, could be zero. *) := $1 . PaInt ;
       $$ . PaTok1 := $0 . PaTok1 ; 
       $$ . PaTok2 := $0 . PaTok2 ; 
     } .
   VarDeclsSemicolon : StkSemicolon
   /* PRE: $0 . PaTok1 is the id list left token. */
   /* PRE: $0 . PaTok2 is the variable decl left token */  
     { $$ . PaTok1 := $0 . PaTok1 ;  
       $$ . PaTok2 := $0 . PaTok2 ;
     } . 
   VarDecls : VarDecls VarDeclsSemicolon VarDecl
   /* PRE: $0 . PaTok1 is the Id list left token. */ 
   /* PRE: $0 . PaTok2 is the variable decl left token */  
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       $$ . PaTok1 := $0 . PaTok1 ; 
       $$ . PaTok2 := $0 . PaTok2 ; 
     } .

   VarDecl : VarDeclIds OptVarType OptVarValue
     { FM3ParsePass . RequireTypeAndOrValue
         ( $1 . Scan . Position , $2 . PaBool , $3 . PaBool ) ;
       (* ^Check this even if there are no valid ids. *)
       IF $1 . PaInt < 0 (* Skipping this decl?  *) 
       THEN (* Have been omitting the declaration. *)
         <* ASSERT FM3ParsePass . StopSkipping ( ) = - $1 . PaInt *> 
       ELSIF FM3ParsePass . SkipDepth > 0
             (* Skipping some containing construct? *)
       THEN (* No output. *) 
       ELSE
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
         DO 
           Push_LCP_eCP_zCP_rP (* The declaration itself. *) 
             ( WDeclInfo . DiDeclTok 
             , $1 . PaUnnestCoord
             , $1 . Scan . Position
             , $2 . PaUnnestCoord
             , $2 . Scan . Position
             , $3 . PaUnnestCoord
             , $3 . Scan . Position 
             , $1 . Scan . Position 
            ) ;
         END (*WITH*) 
       END (*IF*) 
     } . 

   VarDeclIds : DeclIdListElems 
   /* PRE: $0 . PaTok1 is the Id list left token. */ 
   /* PRE: $0 . PaTok2 is the variable decl left token */  
     { $$ . Scan . Position := $1 . Scan . Position ;

       IF $1 . PaInt = 0 (* No usable idents. *)
       THEN (* Start skipping this decl. *) 
         $$ . PaInt (* Negative Skipping depth. *) 
           := - FM3ParsePass . StartSkipping ( ) ;
       ELSE
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         MakeListPos (* The identifier list. *) 
           ( $$
           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
           , $1 . Scan . Position
           , ElemsAttr := $1
           ) ; 
       END (*IF*) ;
     } .

   OptVarType : StkColon Type 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptVarType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 
   OptVarValue : StkBecomes Expr 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptVarValue : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type : StkIdent .

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { $$ . Scan . Position :=  $1 . Scan . Position ;
       $$ . PaTok1 := Itk . ItkRecFieldIdListLt ;
       $$ . PaTok2 := Itk . ItkRecFieldIdListElem ;
       $$ . PaConstructNo  
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkRec , $1 . Scan . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkRecFieldIdListLt
                  , DiDeclTok := Itk . ItkRecFieldLt
                  , DiKind := Dk . DkRecField 
                  }
              ) ;
     } . 

   Type : RecTypeLt VarDecls OptSemicolon StkRwEND
     { FM3ParsePass . Push_LCPI_rpi
         ( Itk . ItkRecDefLt
         , $1 . PaUnnestCoord
         , $1 . Scan . Position
         , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
         ) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *> 
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ; 
     } .

(* ------------------ Procedure Types and Signatures ------------------- *)

   Type : StkRwPROCEDURE Signature
     { Push_LCP_rp
         ( Itk . ItkProcTypeLt , $2 . PaUnnestCoord , $1 . Scan . Position ) ;
     } . 

(* Procedure signature (without PROCEDURE or Ident). *) 
   Signature : Formals ResultType Raises
     { VAR LTok : Itk . TokTyp;
       BEGIN
         IF $2 . PaBool (* Has result type *) 
         THEN LTok := Itk . ItkFuncSignatureLt ;
         ELSE LTok := Itk . ItkProcSignatureLt ;
         END (*IF*);
         Push_LCP_rp ( LTok,  $1 . PaUnnestCoord , $1 . Scan . Position );
       END (*Block*) 
     }.

(* List of formal decls. *)

(* Formals, FormalsPlusList, Formal . PaInt
   is formals count. *)

   Formals : StkOpenParen StkCloseParen /* Empty formals list. */
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := 0 ; 
       FM3ParsePass . ScopeEmpty ( Sk . SkFormals ) ; 
       PushUnnest ( Itk . ItkFormalsListEmpty )
     } .
   Formals : FormalsLt FormalsPlusList OptSemicolon StkCloseParen
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := $2 . PaInt ; 
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ;
       MakeListPos
         ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $2 ) ;
(* FIXME^ different tokens for different formal modes. *) 
     } .
   FormalsLt : StkOpenParen 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaConstructNo 
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkFormals , $1 . Scan . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
     } . 
   FormalsPlusList : FormalsPlusList StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt ; } .  
   FormalsPlusList : Formal 
     { $$ . PaInt := $1 . PaInt ; } .

(* Formal parameter modes. *) 
   FormalLt : /*Empty*/
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       $$ . PaTok1 := Itk . ItkVALUEFormalLt ;
       $$ . PaTok2 := Itk . ItkVALUEFormalIdListLt ;
       $$ . PaByte := ORD ( Dk . DkValueFormal ) ;  
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .
   FormalLt : StkRwVALUE 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaTok1 := Itk . ItkVALUEFormalIdListLt ;
       $$ . PaTok2 := Itk . ItkVALUEFormalLt ;
       $$ . PaByte := ORD ( Dk . DkValueFormal ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaTok1 := Itk . ItkVARFormalIdListLt ;
       $$ . PaTok2 := Itk . ItkVARFormalLt ;
       $$ . PaByte := ORD ( Dk . DkVarFormal ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkVARFormalIdListLt 
                  , DiDeclTok := Itk . ItkVARFormalLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .
   FormalLt : StkRwREADONLY
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaTok1 := Itk . ItkROFormalIdListLt ;
       $$ . PaTok2 := Itk . ItkROFormalLt ;
       $$ . PaByte := ORD ( Dk . DkROFormal ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdListTok := Itk . ItkROFormalIdListLt 
                  , DiDeclTok := Itk . ItkROFormalLt
                  , DiKind := Dk . DkROFormal
                  }
              ) ;
     } .

(* Formal is a formal declaration with PaInt valid ids. *)

   Formal : FormalLt FormalIds FormalType FormalExpr
/* TODO^ Inline DeclIdListRt and adjust $s. */ 
     { $$ . PaInt := $2 . PaInt (* Decl count. *) ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
       DO (* Check this even if no valid ids. *) 
         IF VAL ( $1 . PaByte , Dk ) = Dk . DkVarFormal   
         THEN
           IF NOT $3 . PaBool (* Formal type is present (absent?). *)
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal must have a type (2.2.8)." } 
               , $3 . Scan . Position
               );
           END (*IF*) ; 
           IF $4 . PaBool (* Formal expression is present? *) 
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal cannot have a default expression (2.2.8)." }
               , $4 . Scan . Position
               );
           END (*IF*) ;
         ELSE (* VALUE or READONLY *)  
           FM3ParsePass . RequireTypeAndOrValue
             ( $3 . Scan . Position 
             , $3 . PaBool
             , $4 . PaBool
             )
         END (*IF*) ;

         IF $2 . PaInt < 0 (* Skipping this formal? *)
         THEN (* No output and skip remainder of decl. *) 
           <* ASSERT FM3ParsePass . StopSkipping ( ) = $2 . PaInt *>
         ELSIF FM3ParsePass . SkipDepth > 0
               (* Skipping some containing construct? *)
         THEN (* No output. *) 
         ELSE 
           $$ .PaInt := $2 . PaInt (* Valid Id Ct. *) ;  
           Push_LCP_eCP_zCP_rP 
             ( WDeclInfo . DiDeclTok 
             , $1 . PaUnnestCoord
             , $1 . Scan . Position
             , $3 . PaUnnestCoord
             , $3 . Scan . Position
             , $4 . PaUnnestCoord
             , $4 . Scan . Position 
             , $1 . Scan . Position 
             ) ;
         END (*WITH*) 
       END (*IF*) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
     } .

   FormalIds : DeclIdListElems 
/* TODO^ Inline DeclIdListRt and adjust $s. */ 
     { $$ . Scan . Position  := $1 . Scan . Position ; 
       IF $1 . PaInt = 0 (* No valid ids. *)
       THEN (* Start skipping this formal. *) 
         $$ . PaInt (* Negative Skipping depth. *) 
           := - FM3ParsePass . StartSkipping ( ) ;
       ELSE
         $$ .PaInt := $1 . PaInt (* Valid Id Ct. *) ; 
         MakeListPos
           ( $$
           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
           , $1 . Scan . Position
           , ElemsAttr := $1
           ) ; 
       END (*IF*) ;
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . PaBool (* Type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
(* This looks redundant to Itk<mode>FormalType & Itk<mode>FormalVal,
   which already bracket the type of a formal. 
       Push_LCP_rp
         ( Itk . ItkFormalTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
*) 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
(* This looks redundant to Itk<mode>FormalVal & Itk<mode>FormalRt,
   which already bracket the type of a formal. 
       Push_LCP_rp
         (  Itk . ItkFormalExprLt, $1 . PaUnnestCoord , $1 . Scan . Position );
*) 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature result type. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
     } .

(* Signature RAISES. *) 
   Raises : StkRwRAISES StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkRaisesANY ,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $2 ) ;
     } . 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------------ Procedures ------------------------------ *)

   ProcDecl : StkRwPROCEDURE StkIdent Signature OptBody 
     { VAR LTokLt : Itk . TokTyp; 
       BEGIN 
         CASE FM3Units . UnitStackTopRef ^ . UntKind OF 
         | Uk . UkInterface 
         , Uk . UkGenInterface  
         , Uk . UkInstInterface  
         => IF $4 . PaBool 
            THEN
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY 
                  { " A procedure in an interface must not have a body (2.5.2)." }
                , $4 . Scan . Position
                );  

            END (*IF*); 
            LTokLt := Itk . ItkProcNoBodyLt ; 
         | Uk . UkModule  
         , Uk . UkGenModule  
         , Uk . UkInstModule  
         => IF NOT $4 . PaBool 
            THEN 
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY
                    { " A procedure in a module must have a body (2.5)." } 
                , $4 . Scan . Position
                ); 
            END (*IF*); 
            LTokLt := Itk . ItkProcWBodyLt ; 
(* TODO: Error recovery.  Insert or remove body. *) 
         END (*CASE*);
         Push_LCIri
           ( LTokLt,  $1 . PaUnnestCoord, $2 . Scan . SaAtom ); 
       END (*Block*) 
     } . 

(*
   OptBody : OptBodyAbsent .  
   OptBody : OptBodyPresent .
*)
   OptBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       $$ . PaConstructNo := FM3Base . AtomNull ; 
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LP ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } . 
   OptBody : StkEqual ProcBodyScopeLt Block StkIdent StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := TRUE ; 
       $$ . PaConstructNo := $4 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkProcBodyLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
       FM3ParsePass . ScopeRtL2R ( $2 . PaConstructNo ) ; 
     } .
   ProcBodyScopeLt : /* Empty */
     { $$ . PaConstructNo
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkProcBody , $0 . Scan . Position ) ;
     } .

(* ---------------------------- Expressions ---------------------------- *)

Expr: StkIdent .
Expr: StkIntLit . 

(* ------------------------------ Blocks ------------------------------- *)

   Block : BlockLt DeclList StkRwBEGIN Stmts StkRwEND
     { Push_ECPrP
         ( Itk . ItkBlockLt , $3 . PaUnnestCoord
         , $3 . Scan . Position
         , $5 . Scan . Position
         ) ;
     } .
   BlockLt : /*EMPTY*/
     { FM3ParsePass . BeginBlock ( ) ;
       Push_LP ( Itk . ItkBlockLt , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------ Declaration lists -------------------------- *)

   DeclList : DeclListRecurse
     { MakeListPos
         ( $$ , Itk . ItkDeclListLt , $1 . Scan . Position , $1 ) ;
     } .  
   DeclListRecurse : DeclListRecurse Decl  
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   DeclListRecurse : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
     } .

   Decl : ConstDeclGroup .
   Decl : VarDeclGroup .
   Decl : TypeDeclGroup . 
   Decl : ProcDecl . 
 
(* ---------------------------- Statements ----------------------------- *)

   Stmts : StmtPlusList OptSemicolon .
   StmtPlusList : Stmt . 
   StmtPlusList : StmtPlusList StkSemicolon Stmt . 
   Stmts : /*Empty*/ . 
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { Push_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaUnnestCoord
         , $2 . PaUnnestCoord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


