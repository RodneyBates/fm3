
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023,       Rodney M. Bates.                                    *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in a semantic action, e.g.:
            (* Don't do this. *).  Probably applies to double quote too.
            lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error. *)
            
SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the parser interface. */ 
EXPORT
  { IMPORT FM3IntToks;
    IMPORT FM3ParsePass;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  { IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3ParsePass;
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_L , Push_LP , Push_LCr , Push_LCP_rp , Push_LCPeCrP , Push_LCPeCprp ,
      Push_ECPrP , Push_LCBr , Push_LCIri , Push_LI3 , Push_LI6 , Push_LCeCr ,
      Push_LCIeCri , Push_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeList , MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Sk = FM3Scopes . ScopeKindTyp ;
    TYPE Dk = FM3Decls . DeclKindTyp ; 
    TYPE Uk = FM3Units . UnitKindTyp ; 
  }

/* Parser module initialization. */ 
BEGIN
  { }

/* Parser module final cleanup. */ 
CLOSE { }

(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code will use the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)

(* These are probably not used by lalr: 
    TkMinTok                                     =     1

    StkUnknown                                   =     1 (*16_01 *)
    StkBOF                                       =     2 (*16_02 *)
    StkEOF                                       =     3 (*16_03 *)
*)

    (* Reserved words: *) 
    StkRwAND                                     =     5 (*16_05 *)
    StkRwANY                                     =     6 (*16_06 *)
    StkRwARRAY                                   =     7 (*16_07 *)
    StkRwAS                                      =     8 (*16_08 *)
    StkRwBEGIN                                   =     9 (*16_09 *)
    StkRwBITS                                    =    10 (*16_0a *)
    StkRwBRANDED                                 =    11 (*16_0b *)
    StkRwBY                                      =    12 (*16_0c *)
    StkRwCASE                                    =    13 (*16_0d *)
    StkRwCONST                                   =    14 (*16_0e *)
    StkRwDIV                                     =    15 (*16_0f *)
    StkRwDO                                      =    16 (*16_10 *)
    StkRwELSE                                    =    17 (*16_11 *)
    StkRwELSIF                                   =    18 (*16_12 *)
    StkRwEND                                     =    19 (*16_13 *)
    StkRwEVAL                                    =    20 (*16_14 *)
    StkRwEXCEPT                                  =    21 (*16_15 *)
    StkRwEXCEPTION                               =    22 (*16_16 *)
    StkRwEXIT                                    =    23 (*16_17 *)
    StkRwEXPORTS                                 =    24 (*16_18 *)
    StkRwFINALLY                                 =    25 (*16_19 *)
    StkRwFOR                                     =    26 (*16_1a *)
    StkRwFROM                                    =    27 (*16_1b *)
    StkRwGENERIC                                 =    28 (*16_1c *)
    StkRwIF                                      =    29 (*16_1d *)
    StkRwIMPORT                                  =    30 (*16_1e *)
    StkRwIN                                      =    31 (*16_1f *)
    StkRwINTERFACE                               =    32 (*16_20 *)
    StkRwLOCK                                    =    33 (*16_21 *)
    StkRwLOOP                                    =    34 (*16_22 *)
    StkRwMETHODS                                 =    35 (*16_23 *)
    StkRwMOD                                     =    36 (*16_24 *)
    StkRwMODULE                                  =    37 (*16_25 *)
    StkRwNOT                                     =    38 (*16_26 *)
    StkRwOBJECT                                  =    39 (*16_27 *)
    StkRwOF                                      =    40 (*16_28 *)
    StkRwOR                                      =    41 (*16_29 *)
    StkRwOVERRIDES                               =    42 (*16_2a *)
    StkRwPROCEDURE                               =    43 (*16_2b *)
    StkRwRAISE                                   =    44 (*16_2c *)
    StkRwRAISES                                  =    45 (*16_2d *)
    StkRwREADONLY                                =    46 (*16_2e *)
    StkRwRECORD                                  =    47 (*16_2f *)
    StkRwREF                                     =    48 (*16_30 *)
    StkRwREPEAT                                  =    49 (*16_31 *)
    StkRwRETURN                                  =    50 (*16_32 *)
    StkRwREVEAL                                  =    51 (*16_33 *)
    StkRwROOT                                    =    52 (*16_34 *)
    StkRwSET                                     =    53 (*16_35 *)
    StkRwTHEN                                    =    54 (*16_36 *)
    StkRwTO                                      =    55 (*16_37 *)
    StkRwTRY                                     =    56 (*16_38 *)
    StkRwTYPE                                    =    57 (*16_39 *)
    StkRwTYPECASE                                =    58 (*16_3a *)
    StkRwUNSAFE                                  =    59 (*16_3b *)
    StkRwUNTIL                                   =    60 (*16_3c *)
    StkRwUNTRACED                                =    61 (*16_3d *)
    StkRwVALUE                                   =    62 (*16_3e *)
    StkRwVAR                                     =    63 (*16_3f *)
    StkRwWHILE                                   =    64 (*16_c0 00 *)
    StkRwWITH                                    =    65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =    66 (*16_c2 00 *)
    StkDot                                       =    67 (*16_c3 00 *)
    StkEqual                                     =    68 (*16_c4 00 *)
    StkOpenParen                                 =    69 (*16_c5 00 *)
    StkCloseParen                                =    70 (*16_c6 00 *)
    StkComma                                     =    71 (*16_c7 00 *)
    StkColon                                     =    72 (*16_c8 00 *)
    StkSubtype                                   =    73 (*16_c9 00 *)
    StkBecomes                                   =    74 (*16_ca 00 *)
    StkOpenBrace                                 =    75 (*16_cb 00 *)
    StkCloseBrace                                =    76 (*16_cc 00 *)
    StkStroke                                    =    77 (*16_cd 00 *)
    StkArrow                                     =    78 (*16_ce 00 *)
    StkEllipsis                                  =    79 (*16_cf 00 *)
    StkOpenBracket                               =    80 (*16_d0 00 *)
    StkCloseBracket                              =    81 (*16_d1 00 *)
    StkUnequal                                   =    82 (*16_d2 00 *)
    StkLess                                      =    83 (*16_d3 00 *)
    StkGreater                                   =    84 (*16_d4 00 *)
    StkLessEqual                                 =    85 (*16_d5 00 *)
    StkGreaterEqual                              =    86 (*16_d6 00 *)
    StkPlus                                      =    87 (*16_d7 00 *)
    StkMinus                                     =    88 (*16_d8 00 *)
    StkAmpersand                                 =    89 (*16_d9 00 *)
    StkStar                                      =    90 (*16_da 00 *)
    StkSlash                                     =    91 (*16_db 00 *)
    StkDeref                                     =    92 (*16_dc 00 *)
    StkOpenPragma                                =    93 (*16_dd 00 *)
    StkClosePragma                               =    94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =    95 (*16_df 00 *)
    StkIntLit                                    =    96 (*16_e0 00 *)
    StkLongIntLit                                =    97 (*16_e1 00 *)
    StkBasedLit                                  =    98 (*16_e2 00 *)
    StkLongBasedLit                              =    99 (*16_e3 00 *)
    StkRealLit                                   =   100 (*16_e4 00 *)
    StkLongRealLit                               =   101 (*16_e5 00 *)
    StkExtendedLit                               =   102 (*16_e6 00 *)
    StkTextLit                                   =   103 (*16_e7 00 *)
    StkWideTextLit                               =   104 (*16_e8 00 *)
    StkCharLit                                   =   105 (*16_e9 00 *)
    StkWideCharLit                               =   106 (*16_ea 00 *)
    StkLexErrChars                               =   107 (*16_eb 00 *)
    StkReservedId                                =   108 (*16_ec 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *) 

(* ------------------------------- Productions. ---------------------------- *)

(* NOTE regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the leftmost RHS's attribute.
*) 


RULE

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstModule ; } . 

   Interface : 
       OptUnsafe StkRwINTERFACE StkIdent InterfaceKind StkSemicolon
       Imports DeclList StkRwEND StkIdent StkDot .

   Module :
       OptUnsafe StkRwMODULE StkIdent Exports ModuleKind StkSemicolon
       Imports Block StkIdent StkDot .

   GenInterface :
       StkRwGENERIC StkRwINTERFACE StkIdent GenInterfaceKind GenFormalList
       StkSemicolon Imports DeclList StkRwEND StkIdent StkDot . 

   GenModule :
       StkRwGENERIC StkRwMODULE StkIdent GenModuleKind GenFormalList
       StkSemicolon Imports Block StkIdent StkDot . 

   InstInterface :
       OptUnsafe StkRwINTERFACE StkIdent InstInterfaceKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   InstModule :
       OptUnsafe StkRwMODULE StkIdent Exports InstModuleKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   CaptureCoord : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
     
   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 
 
(* ----------------------------- Identifier lists ---------------------- *)

(* List of one or more comma-separated Idents.*)
   IdPlusList : StkIdent 
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma StkIdent
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } .

(* List of one or more comma-separated declaring occurrences of Idents.*)

   (* DeclIdPlusList . PaInt > 0 is count of valid Idents. *) 

   DeclIdPlusList : StkIdent 
     { (* PaUnnestCoord already copied from $1 to $$ by parser. *)
       $$ . PaInt (* Valid Id count. *)
         := ORD ( FM3ParsePass . DeclIdL2R ( $1 ) ) ; 
     } . 
   DeclIdPlusList : DeclIdPlusList StkComma StkIdent
     { (* PaUnnestCoord already copied from $1 to $$ by parser. *)
       IF FM3ParsePass . DeclIdL2R ( $3 ) (* Use this ident. *) 
       THEN 
         $$ . PaInt := $1 . PaInt + 1 ;  
         FM3ParsePass . Push_ListSepPatchPos 
           ( FM3Decls . TopDeclInfo ( ) . DiIdTok
           , $1 . PaUnnestCoord
           , $2 . Scan . Position 
           ) ;
       ELSE $$ . PaInt := $1 . PaInt ; 
       END (*IF*) 
     } .

   DeclIdSkipDecl : /* Empty */
   /* Must follow a top-level DeclIdPlusList.  */ 
     { IF $0 . PaInt <= 0 (* No usable idents. *)
       THEN $$ . PaInt := FM3ParsePass . StartSkipping ( ) ;
       ELSE $0 . PaInt := 0 ;
       END (*IF*)
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated qualified Idents. *)
   QualIdStarList : QualIdStarList StkComma QualId
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   QualIdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 
     
(* Qualified ident. *)   
   QualId : StkIdent .
   QualId : StkIdent StkDot StkIdent
     { Push_LCeCr
         ( Itk . ItkQualIdLt ,  $1 . PaUnnestCoord , $3 . PaUnnestCoord );
     } .

(*  ----------------------------- Imports -----------------------. *) 

   Imports : ImportsLt ImportsRecurse ImportsRt 
     { $$ . PaInt := $2 . PaInt (* Imported interface Count. *) ;
       $$ . PaLong := $2 . PaLong (* Imported unqualified Ident Count. *) ;
     } .
   ImportsLt : /*Empty*/ { FM3ParsePass . ImportsLt ( ) ; } . 
   ImportsRt : /*Empty*/ { FM3ParsePass . ImportsRt ( ) ; } . 
   ImportsRecurse : ImportsRecurse ImportItem  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt ;
       $$ . PaLong := $1 . PaLong + $2 . PaLong ;
     } .
   ImportsRecurse : /*Empty*/
     { $$ . PaInt := 0; 
       $$ . PaLong := 0L; 
     } . 

   (* IMPORT .. *) 
   ImportItem : StkRwIMPORT ImportIntfPlusList StkSemicolon  
     { $$ . PaInt := $2 . PaInt ;
       $$ . PaLong := 0L ; 
     } .
   ImportIntfPlusList : StkIdent 
     { $$ . PaInt := 1 ;
       FM3ParsePass . Import
         ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       Push_LI3
         ( Itk . ItkImport
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         ) ;
     } . 
   ImportIntfPlusList : ImportIntfPlusList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ;
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3ParsePass . Import
         ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
       Push_LI3
         ( Itk . ItkImport
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

   (* FROM Id IMPORT ... *) 
   ImportItem : FromImportPlusList StkSemicolon 
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaLong := $1 . PaLong ; 
     } .
   FromImportPlusList : StkRwFROM StkIdent StkRwIMPORT StkIdent
     { $$ . PaInt := 1 (* InterfaceCt. *) ;
       $$ . PaLong := 1L ;
       $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
       $$ . Scan . Position := $2 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $2 . Scan . SaAtom
         , $2 . Scan . Position 
         , $4 . Scan . SaAtom
         , $4 . Scan . Position 
         ) ; 
       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $2 . Scan . SaAtom
         , $2 . Scan . Position . Line
         , $2 . Scan . Position . Column
         , $4 . Scan . SaAtom
         , $4 . Scan . Position . Line
         , $4 . Scan . Position . Column
         ) ;
     } . 
   FromImportPlusList : FromImportPlusList StkComma StkIdent
     { $$ . PaInt := 1 ;
       $$ . PaLong := $1 . PaLong + 1L ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $1 . Scan . SaAtom
         , $1 . Scan . Position 
         , $3 . Scan . SaAtom
         , $3 . Scan . Position 
         ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

(* IMPORT Id AS Id; *)
(*
   ImportItem : StkRwFROM StkIdent StkRwIMPORT IdPlusList StkSemicolon 
     { $$ . PaInt := 1 ;
       $$ . PaLong := VAL ( $4 . PaInt (* IdPlusList Ct. *) , LONGINT ) ;
       Push_LCIeCri
         ( Itk . ItkImportAsLt, $1 . PaUnnestCoord, $4 . PaInt , $3 . PaUnnestCoord );
     } .
*)
(* ------------------------------- Exports ------------------------- . *)

(* Exports.  Possibly absent, in which case construct "EXPORTS Main".
   Otherwise contains at least one ident. Bracket with ItkportList*.
*) 

   Exports : StkRwEXPORTS IdPlusList 
     { MakeListPos
         ( $$ , Itk . ItkExportIdListLt , $1 . Scan . Position , $2 ) ;
     } .
   Exports : /*Empty*/
     { FM3ParsePass . PushEXPORTSMain ( $0 . Scan . Position ) ; } .

(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos
         ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* -------------------------- Type Declarations. --------------------- . *)

   TypeDeclGroup : StkRwTYPE TypeDecls .
   TypeDecls : TypeDecl . 
   TypeDecls : TypeDecls TypeDecl . 
   TypeDecl : StkIdent StkEqual Type StkSemicolon
     { Push_LCPeCrP
         ( Itk . ItkTypeDeclLt
         , $0 . PaUnnestCoord
         , $1 . Scan . Position
         , $2 . PaUnnestCoord
         , $4 . Scan . Position
         ) ; 
     } .

(* ------------------------- Constant Declarations -------------------- . *) 

   ConstDeclGroup : StkRwCONST ConstDecls .
   ConstDecls : ConstDecl . 
   ConstDecls : ConstDecls ConstDecl . 
   ConstDecl : StkIdent OptConstType StkEqual Expr StkSemicolon .
   OptConstType : StkColon Type
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ;
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDecls, VarDecl . PsInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   
   VarDeclGroupLt : StkRwVAR
     { $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkVarDeclId
                  , DiDeclTok := Itk . ItkVarDeclIdListLt
                  , DiKind := Dk . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDecls StkSemicolon 
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
      } . 

   (* VarDecls is also used for record and object fields. *)
   (* Also see DeclIdPlusList. *)
   VarDecls : VarDecl
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } . 
   VarDecls : VarDecls StkSemicolon VarDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ; } . 

   VarDecl : DeclIdPlusList DeclIdSkipDecl OptVarType OptVarValue 
     { $$ . PaInt (* Decl count. *) := $1 . PaInt (* Valid id count. *) ; 
       FM3ParsePass . RequireTypeAndOrValue 
         ( $1 . Scan . Position  
         , $3 . PaBool
         , $4 . PaBool
         ) ;
       (* ^Do this Even if there are zero valid decl ids. *)

       IF $2 . PaInt > 0 (* Have been skipping this decl. *) 
       THEN (* Have been omitting the declaration. *)
         <* ASSERT FM3ParsePass . StopSkipping ( ) = $2 . PaInt *> 
       ELSE
         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
         DO 
           MakeListPos
             ( $$ , WDeclInfo . DiDeclTok , $1 . Scan . Position , $1 ) ; 
           Push_LCP_eCP_zCP_rP 
             ( WDeclInfo . DiDeclTok 
             , $2 . PaUnnestCoord
             , $2 . Scan . Position
             , $3 . PaUnnestCoord
             , $3 . Scan . Position
             , $4 . PaUnnestCoord
             , $4 . Scan . Position 
             , $1 . Scan . Position 
            ) ;
         END (*WITH*) 
       END (*IF*) 
     } .

   OptVarType : StkColon Type 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptVarType : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ); 
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 
   OptVarValue : StkBecomes Expr 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptVarValue : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ); 
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type : StkIdent .

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { $$ . Scan . Position :=  $1 . Scan . Position ;
       $$ . PaInt (* ScopeNo. *) 
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkRec , $1 . Scan . Position ) ;
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkRecFieldId
                  , DiDeclTok := Itk . ItkRecFieldIdListLt
                  , DiKind := Dk . DkRecField 
                  }
              ) ;
     } . 

   Type : RecTypeLt VarDecls OptSemicolon StkRwEND
     { FM3ParsePass . Push_LCPI_rpi
         ( Itk . ItkRecDefLt
         , $1 . PaUnnestCoord
         , $1 . Scan . Position
         , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
         ) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *> 
       FM3ParsePass . ScopeRtL2R ( ) ; 
     } .

(* ------------------ Procedure Types and Signatures ------------------- *)

   Type : StkRwPROCEDURE Signature
     { Push_LCP_rp
         ( Itk . ItkProcTypeLt , $2 . PaUnnestCoord , $1 . Scan . Position ) ;
     } . 

(* Procedure signature (without PROCEDURE or Ident). *) 
   Signature : Formals ResultType Raises
     { VAR LTok : Itk . TokTyp;
       BEGIN
         IF $2 . PaBool
         THEN LTok := Itk . ItkFuncSignatureLt ;
         ELSE LTok := Itk . ItkProcSignatureLt ;
         END (*IF*);
         Push_LCP_rp ( LTok,  $1 . PaUnnestCoord , $1 . Scan . Position );
       END (*Block*) 
     }.

(* List of formal decls. *)

(* Formals, FormalsPlusList, Formal . PaInt
   is formals count. *)

   Formals : StkOpenParen StkCloseParen /* Empty formals list. */
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := 0 ; 
       FM3ParsePass . ScopeEmpty ( Sk . SkFormals ) ; 
       PushUnnest ( Itk . ItkFormalsListEmpty )
     } .
   Formals : FormalsLt FormalsPlusList OptSemicolon StkCloseParen
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := $2 . PaInt ; 
       FM3ParsePass . ScopeRtL2R ( ) ;
       MakeListPos
         ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $2 ) ;
     } .
   FormalsLt : StkOpenParen 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt (* ScopeNo. *) 
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkFormals , $1 . Scan . Position ) ;
     } . 
   FormalsPlusList : FormalsPlusList StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt ; } .  
   FormalsPlusList : Formal 
     { $$ . PaInt := $1 . PaInt ; } .

(* Formal parameter modes. *) 
   FormalLt : StkRwVALUE 
     { $$ . Scan . Position := $1 . Scan . Position;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkVALUEFormalId 
                  , DiDeclTok := Itk . ItkVALUEFormalIdListLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { $$ . Scan . Position := $1 . Scan . Position; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkVARFormalId 
                  , DiDeclTok := Itk . ItkVARFormalIdListLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .
   FormalLt : StkRwREADONLY
     { $$ . Scan . Position := $1 . Scan . Position; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkROFormalId 
                  , DiDeclTok := Itk . ItkROFormalIdListLt
                  , DiKind := Dk . DkROFormal
                  }
              ) ;
     } .
   FormalLt : /*Empty*/
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiIdTok := Itk . ItkVALUEFormalId 
                  , DiDeclTok := Itk . ItkVALUEFormalIdListLt
                  , DiKind := Dk . DkValueFormal
                  }
              ) ;
     } .

(* Formal is a formal declaration with PaInt valid ids. *)

   Formal : FormalLt DeclIdPlusList DeclIdSkipDecl FormalType FormalExpr
     { $$ . PaInt := $2 . PaInt (* Decl count. *) ;
       $$ . Scan . Position  := $1 . Scan . Position ; 
         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
         DO 
           IF WDeclInfo . DiKind = Dk . DkVarFormal   
           THEN
             IF NOT $4 . PaBool (* Formal type is present (absent). *)
             THEN
               FM3Messages . ErrorArr
                 ( ARRAY OF REFANY 
                     { " VAR formal must have a type (2.2.8)." } 
                 , $4 . Scan . Position
                 );
             END (*IF*) ; 
             IF $5 . PaBool (* Formal expression is present. *) 
             THEN
               FM3Messages . ErrorArr
                 ( ARRAY OF REFANY 
                     { " VAR formal cannot have a default expression  (2.2.8)." }
                 , $5 . Scan . Position
                 );
             END (*IF*) ;
           ELSE (* VALUE or READONLY *)  
             FM3ParsePass . RequireTypeAndOrValue
               ( $1 . Scan . Position 
               , $4 . PaBool
               , $5 . PaBool
               )
           END (*IF*) ;

         IF $3 . PaInt > 0 (* Have been skipping this decl. *) 
         THEN (* Have been omitting the declaration. *)
           <* ASSERT FM3ParsePass . StopSkipping ( ) = $3 . PaInt *> 
         ELSE
           MakeListPos
             ( $$ , WDeclInfo . DiDeclTok , $2 . Scan . Position , $2 ) ; 
           Push_LCP_eCP_zCP_rP 
             ( WDeclInfo . DiDeclTok 
             , $1 . PaUnnestCoord
             , $1 . Scan . Position
             , $4 . PaUnnestCoord
             , $4 . Scan . Position
             , $5 . PaUnnestCoord
             , $5 . Scan . Position 
             , $1 . Scan . Position 
            ) ;
         END (*WITH*) 
       END (*IF*) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkFormalTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position ); 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         (  Itk . ItkFormalExprLt, $1 . PaUnnestCoord , $1 . Scan . Position ); 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature result type. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature RAISES. *) 
   Raises : StkRwRAISES StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkRaisesANY ,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $2 ) ;
     } . 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------------ Procedures ------------------------------ *)

   ProcDecl : StkRwPROCEDURE StkIdent Signature OptBody 
     { VAR LTokLt : Itk . TokTyp; 
       BEGIN 
         CASE FM3Units . UnitStackTopRef ^ . UntKind OF 
         | Uk . UkInterface 
         , Uk . UkGenInterface  
         , Uk . UkInstInterface  
         => IF $4 . PaBool 
            THEN
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY 
                  { " A procedure in an interface must not have a body (2.5.2)." }
                , $4 . Scan . Position
                );  

            END (*IF*); 
            LTokLt := Itk . ItkProcNoBodyLt ; 
         | Uk . UkModule  
         , Uk . UkGenModule  
         , Uk . UkInstModule  
         => IF NOT $4 . PaBool 
            THEN 
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY
                    { " A procedure in a module must have a body (2.5)." } 
                , $4 . Scan . Position
                ); 
            END (*IF*); 
            LTokLt := Itk . ItkProcWBodyLt ; 
(* TODO: Error recovery.  Insert or remove body. *) 
         END (*CASE*);
         Push_LCIri
           ( LTokLt,  $1 . PaUnnestCoord, $2 . Scan . SaAtom ); 
       END (*Block*) 
     } . 

(*
   OptBody : OptBodyAbsent .  
   OptBody : OptBodyPresent .
*)
   OptBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       $$ . PaConstructNo := FM3Base . AtomNull ; 
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LP ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } . 
   OptBody : StkEqual ProcBodyScopeLt Block StkIdent StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := TRUE ; 
       $$ . PaConstructNo := $4 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkProcBodyLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
       FM3ParsePass . ScopeRtL2R ( ) ; 
     } .
   ProcBodyScopeLt : /* Empty */
     { EVAL FM3ParsePass . ScopeLtL2R
         ( Sk . SkProcBody , $0 . Scan . Position ) ;
     } .

(* ---------------------------- Expressions ---------------------------- *)

Expr: StkIdent .
Expr: StkIntLit . 

(* ------------------------------ Blocks ------------------------------- *)

   Block : BlockLt DeclList StkRwBEGIN Stmts StkRwEND
     { Push_ECPrP
         ( Itk . ItkBlockLt , $3 . PaUnnestCoord
         , $3 . Scan . Position
         , $5 . Scan . Position
         ) ;
     } .
   BlockLt : /*EMPTY*/
     { FM3ParsePass . BeginBlock ( ) ;
       Push_LP ( Itk . ItkBlockLt , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------ Declaration lists -------------------------- *)

   DeclList : DeclListRecurse
     { MakeListPos
         ( $$ , Itk . ItkDeclListLt , $1 . Scan . Position , $1 ) ;
     } .  
   DeclListRecurse : DeclListRecurse Decl  
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   DeclListRecurse : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
     } .

   Decl : ConstDeclGroup .
   Decl : VarDeclGroup .
   Decl : TypeDeclGroup . 
   Decl : ProcDecl . 
 
(* ---------------------------- Statements ----------------------------- *)

   Stmts : StmtPlusList OptSemicolon .
   StmtPlusList : Stmt . 
   StmtPlusList : StmtPlusList StkSemicolon Stmt . 
   Stmts : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { Push_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaUnnestCoord
         , $2 . PaUnnestCoord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


