 
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in brace-enclosed code, e.g., do not
            write "{ (* Don't do this. *) }".  This probably applies to double
            quote too.  lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error.
*)

(* Use metaprogram lalr to generate FM3Parser.i3, FM3Parser.m3, and
   _Debug, from this file, using command line:
   "../lib/lalr -M -g -i -t -d -D -k FM3Parser.lalr"
*)

SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the front of the parser interface. */ 
EXPORT
  {
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3IntToks;
    IMPORT FM3Pass1;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  {

(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2025 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3SrcToks AS Stk;
    IMPORT FM3Pass1;
    IMPORT FM3ExpImp;
    FROM FM3Pass1 IMPORT Coord;
    FROM FM3Pass1 IMPORT PutBwd_Attribute;
    FROM FM3Pass1 IMPORT tParsAttribute;
    FROM FM3Pass1 IMPORT ParsAttrNull;
    FROM FM3Pass1 IMPORT
      PutBwd_L , PutBwd_LP , PutBwd_LCr , PutBwd_LCP_rp , PutBwd_LCP_eCP_rP ,
      PutBwd_LCPeCprp , PutBwd_LIP , PutBwd_LIP_rip , PutBwd_EIP , PutBwd_ECIP , 
      PutBwd_ECIP_riP , PutBwd_LCBr , PutBwd_LI3 , PutBwd_LI6 , 
      PutBwd_LCIeCri , PutBwd_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3Pass1 IMPORT MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Skt = FM3Scopes . ScopeKindTyp ;
    TYPE Dkt = FM3Decls . DeclKindTyp ; 
    TYPE Ukt = FM3Units . UnitKindTyp ;

    PROCEDURE Test ( READONLY Attr : tParsAttribute )
    = VAR Debug : INTEGER := 0
    ; BEGIN
        IF Attr . PaInt = FIRST ( INTEGER)
        THEN
          Debug := 19
        END 
      END Test ;

  }

/* Parser module initialization. */ 
BEGIN
  { }
  
/* Parser module final cleanup. */ 
CLOSE { }
(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code uses the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)
(* These are not used by lalr: 

    StkUnknown                                   =     -1 (*16_01 *)
    StkBOF                                       =     -2 (*16_02 *)
    StkEOF                                       =     -3 (*16_03 *)
*)

    (* This column ---------------------------------------V
       is wrong, now that values are negative.
    *) 

    (* Reserved words: *) 
    StkRwAND                                     =      5 (*16_05 *)
    StkRwANY                                     =      6 (*16_06 *)
    StkRwARRAY                                   =      7 (*16_07 *)
    StkRwAS                                      =      8 (*16_08 *)
    StkRwBEGIN                                   =      9 (*16_09 *)
    StkRwBITS                                    =     10 (*16_0a *)
    StkRwBRANDED                                 =     11 (*16_0b *)
    StkRwBY                                      =     12 (*16_0c *)
    StkRwCASE                                    =     13 (*16_0d *)
    StkRwCONST                                   =     14 (*16_0e *)
    StkRwDIV                                     =     15 (*16_0f *)
    StkRwDO                                      =     16 (*16_10 *)
    StkRwELSE                                    =     17 (*16_11 *)
    StkRwELSIF                                   =     18 (*16_12 *)
    StkRwEND                                     =     19 (*16_13 *)
    StkRwEVAL                                    =     20 (*16_14 *)
    StkRwEXCEPT                                  =     21 (*16_15 *)
    StkRwEXCEPTION                               =     22 (*16_16 *)
    StkRwEXIT                                    =     23 (*16_17 *)
    StkRwEXPORTS                                 =     24 (*16_18 *)
    StkRwFINALLY                                 =     25 (*16_19 *)
    StkRwFOR                                     =     26 (*16_1a *)
    StkRwFROM                                    =     27 (*16_1b *)
    StkRwGENERIC                                 =     28 (*16_1c *)
    StkRwIF                                      =     29 (*16_1d *)
    StkRwIMPORT                                  =     30 (*16_1e *)
    StkRwIN                                      =     31 (*16_1f *)
    StkRwINTERFACE                               =     32 (*16_20 *)
    StkRwLOCK                                    =     33 (*16_21 *)
    StkRwLOOP                                    =     34 (*16_22 *)
    StkRwMETHODS                                 =     35 (*16_23 *)
    StkRwMOD                                     =     36 (*16_24 *)
    StkRwMODULE                                  =     37 (*16_25 *)
    StkRwNOT                                     =     38 (*16_26 *)
    StkRwOBJECT                                  =     39 (*16_27 *)
    StkRwOF                                      =     40 (*16_28 *)
    StkRwOR                                      =     41 (*16_29 *)
    StkRwOVERRIDES                               =     42 (*16_2a *)
    StkRwPROCEDURE                               =     43 (*16_2b *)
    StkRwRAISE                                   =     44 (*16_2c *)
    StkRwRAISES                                  =     45 (*16_2d *)
    StkRwREADONLY                                =     46 (*16_2e *)
    StkRwRECORD                                  =     47 (*16_2f *)
    StkRwREF                                     =     48 (*16_30 *)
    StkRwREPEAT                                  =     49 (*16_31 *)
    StkRwRETURN                                  =     50 (*16_32 *)
    StkRwREVEAL                                  =     51 (*16_33 *)
    StkRwROOT                                    =     52 (*16_34 *)
    StkRwSET                                     =     53 (*16_35 *)
    StkRwTHEN                                    =     54 (*16_36 *)
    StkRwTO                                      =     55 (*16_37 *)
    StkRwTRY                                     =     56 (*16_38 *)
    StkRwTYPE                                    =     57 (*16_39 *)
    StkRwTYPECASE                                =     58 (*16_3a *)
    StkRwUNSAFE                                  =     59 (*16_3b *)
    StkRwUNTIL                                   =     60 (*16_3c *)
    StkRwUNTRACED                                =     61 (*16_3d *)
    StkRwVALUE                                   =     62 (*16_3e *)
    StkRwVAR                                     =     63 (*16_3f *)
    StkRwWHILE                                   =     64 (*16_c0 00 *)
    StkRwWITH                                    =     65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =     66 (*16_c2 00 *)
    StkDot                                       =     67 (*16_c3 00 *)
    StkEqual                                     =     68 (*16_c4 00 *)
    StkOpenParen                                 =     69 (*16_c5 00 *)
    StkCloseParen                                =     70 (*16_c6 00 *)
    StkComma                                     =     71 (*16_c7 00 *)
    StkColon                                     =     72 (*16_c8 00 *)
    StkSubtype                                   =     73 (*16_c9 00 *)
    StkBecomes                                   =     74 (*16_ca 00 *)
    StkOpenBrace                                 =     75 (*16_cb 00 *)
    StkCloseBrace                                =     76 (*16_cc 00 *)
    StkStroke                                    =     77 (*16_cd 00 *)
    StkArrow                                     =     78 (*16_ce 00 *)
    StkEllipsis                                  =     79 (*16_cf 00 *)
    StkOpenBracket                               =     80 (*16_d0 00 *)
    StkCloseBracket                              =     81 (*16_d1 00 *)
    StkUnequal                                   =     82 (*16_d2 00 *)
    StkLess                                      =     83 (*16_d3 00 *)
    StkGreater                                   =     84 (*16_d4 00 *)
    StkLessEqual                                 =     85 (*16_d5 00 *)
    StkGreaterEqual                              =     86 (*16_d6 00 *)
    StkPlus                                      =     87 (*16_d7 00 *)
    StkMinus                                     =     88 (*16_d8 00 *)
    StkAmpersand                                 =     89 (*16_d9 00 *)
    StkStar                                      =     90 (*16_da 00 *)
    StkSlash                                     =     91 (*16_db 00 *)
    StkDeref                                     =     92 (*16_dc 00 *)
    StkOpenPragma                                =     93 (*16_dd 00 *)
    StkClosePragma                               =     94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =     95 (*16_df 00 *)
    StkIntLit                                    =     96 (*16_e0 00 *)
    StkLongIntLit                                =     97 (*16_e1 00 *)
    StkBasedLit                                  =     98 (*16_e2 00 *)
    StkLongBasedLit                              =     99 (*16_e3 00 *)
    StkRealLit                                   =    100 (*16_e4 00 *)
    StkLongRealLit                               =    101 (*16_e5 00 *)
    StkExtendedLit                               =    102 (*16_e6 00 *)
    StkTextLit                                   =    103 (*16_e7 00 *)
    StkWideTextLit                               =    104 (*16_e8 00 *)
    StkCharLit                                   =    105 (*16_e9 00 *)
    StkWideCharLit                               =    106 (*16_ea 00 *)
    StkLexErrChars                               =    107 (*16_eb 00 *)
    StkPragmaId                                  =    108 (*16_ec 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *)


(* Reserved identifier numeric lex codes need not be known to lalr for parsing,
   thus embedded semantic actions can refer to them directly as FM3SrcToks.Rid*,
   and no copying into here is necessary.
*) 

(* NOTE: Modula-3's idea that semicolons can optionally be separators
   or terminators fails to apply to imports, exports, or declarations,
   where they can only be terminators.  And BTW, commas are always separators.
   Regardless of the source syntax, in the internal token streams, a list
   always has separator tokens, never element terminators that are not part
   of the element itself. (But there is a *list* terminator, "*Rt".) 
*) 

(* --------------------- Precedence and associativity ---------------------- *)

OPER LEFT StkRwRAISES 
(*
  LEFT StkRwOR
  LEFT StkRwAND
  LEFT StkRwNOT 
  NONE StkEqual StkUnequal StkLess StkGreater StkLessEqual StkGreaterEqual
  LEFT StkPlus StkMinus StkAmpersand
  LEFT StkStar StkSlasn StkRwDIV StkRwMod
(*  LEFT StkPlus StkMinus *) 
  LEFT StkDeref
*)

(* ------------------------------- Productions. ---------------------------- *)

RULE

(* NOTE: regarding the parser's default setting of the PaPass1Coord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaPass1Coord.  For a reduce, and if the semantic
   action doesn't set PaPass1Coord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the attribute of the RHS's
   leftmost token.

   NOTE: regarding the parser's default setting of the field Scan . Position:
   If it is not set by semantic actions, it too is set by the generated parser.
   If the RHS is empty, this is the current position.  If the reduce is
   nonempty, iot is a copy from the attribute of the RHS's leftmost token.
*) 

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; } . 

   InterfaceLt : OptUnsafe StkRwINTERFACE NonreservedIdent IntfPragmas
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
       BEGIN
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         FM3Pass1 . InterfaceId ( LUnitRef , $3 . Scan ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkInterface , $1 . Scan . Position ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } .

   InstInterface :
     InterfaceLt StkEqual NonreservedIdent GenActualList StkRwEND NonreservedIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ;
(*INCOMPLETE.*)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $6 . Scan , Ukt . UkInstInterface ) ; 
     } . 

   InterfaceMiddle : InterfaceLt StkSemicolon ImportList ExpImpDone 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Scopes . PushOpenScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } . 

   Interface : InterfaceMiddle OpenDeclList StkRwEND NonreservedIdent StkDot
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LScopeRef := FM3Scopes . OpenScopeStackTopRef ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ; 
         <* ASSERT FM3Scopes . PopOpenScopeRef ( ) = LScopeRef *>
         <* ASSERT LScopeRef = FM3Scopes . DeclScopeStackTopRef *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ; 
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef , $4 . Scan , Ukt . UkInterface ) ; 
         FM3Pass1 . PutBwd_LCIP_rip 
           ( Itk . ItkInterfaceLt
           , $1 . PaPass1Coord
           , FM3Units . UnitStackTopRef ^ . UntSelfUnitNo 
           , $1 . Scan . Position
           ) ; 
       END ; 
     } .

   ModuleLt : OptUnsafe StkRwMODULE NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
       BEGIN
         $$ . PaPos := $3 . Scan . Position ;
         (* ^Module name position, in case no explicit EXPORTS. *) 
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         FM3Pass1 . ModuleId ( LUnitRef , $3 . Scan ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkModule , $1 . Scan . Position ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ; 
       END ; 
     } .

   InstModule :
     ModuleLt StkEqual NonreservedIdent GenActualList StkRwEND NonreservedIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ;
(*INCOMPLETE.*)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $6 . Scan , Ukt . UkInstModule ) ; 
     } . 

   ModuleMiddle : ModuleLt Exports StkSemicolon ImportList ExpImpDone 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Scopes . PushOpenScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END ; 
     } . 

   Module : ModuleMiddle OpenDeclList
            StkRwBEGIN StmtList StkRwEND NonreservedIdent StkDot
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LScopeRef := FM3Scopes . OpenScopeStackTopRef ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ;
         <* ASSERT FM3Scopes . PopOpenScopeRef ( ) = LScopeRef *>
         <* ASSERT LScopeRef = FM3Scopes . DeclScopeStackTopRef *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo ) ; 
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef , $6 .Scan , Ukt . UkModule ) ; 
         FM3Pass1 . PutBwd_LCIP_eCiP_riP 
           ( Itk . ItkModuleLt
           , $1 . PaPass1Coord
           , FM3Units . UnitStackTopRef ^ . UntSelfUnitNo 
           , $1 . Scan . Position
           , $3 . PaPass1Coord
           , $3 . Scan . Position
           , $1 . Scan . Position 
           ) ; 
       END ; 
     } .

   GenInterfaceLt : StkRwGENERIC StkRwINTERFACE NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkInterface ) ; 
         LUnitRef := FM3Units . UnitStackTopRef ;
         FM3Pass1 . InterfaceId ( LUnitRef , $3 . Scan ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( LUnitRef 
                , Skt . SkInterface
                , FM3Scanner . Attribute . Position
                ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef ;
       END ; 
     } .  

   GenInterface :
       GenInterfaceLt GenInterfaceKind GenFormalList
       StkSemicolon ImportList ExpImpDone OpenDeclList StkRwEND NonreservedIdent StkDot 
     { (* Scope ref:
        FM3Pass1 . PutBwd_LI ( Itk . ItkDeclScopeLt , $1 . PaConstructNo ) ;
       *)
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $8 . Scan , Ukt . UkGenInterface ) ; 
     } .

   GenModuleLt : StkRwGENERIC StkRwMODULE NonreservedIdent  
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkGenModule ) ;
         LUnitRef := FM3Units . UnitStackTopRef ;
         FM3Pass1 . ModuleId ( LUnitRef , $3 . Scan ) ;
         LScopeRef  
           := FM3Scopes . NewScopeRef
                ( LUnitRef
                , Skt . SkModule
                , FM3Scanner . Attribute . Position
                ) ;
         LUnitRef ^ . UntScopeRef := LScopeRef  ; 
       END ; 
     } . 

   GenModule :
       GenModuleLt GenModuleKind GenFormalList
       StkSemicolon ImportList ExpImpDone Block NonreservedIdent StkDot 
     { (* scope ref
          FM3Pass1 . PutBwd_LI ( Itk . ItkDeclScopeLt , $1 . PaConstructNo ) ;
       *) 
       FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; 
       FM3Pass1 . CheckUnitFinalId
         ( FM3Units . UnitStackTopRef , $8 . Scan , Ukt . UkGenModule ) ;
     } .


   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 
 
(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { (* Handle this in pass 1.
          MakeListPos
            ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
       *) 
     } .

(*  ----------------------------- Imports -----------------------. *) 

   ImportList : /*Empty*/ . 

   ImportList : ImportList Import .
     
   (* ASImport, including plain IMPORT *) 
   Import : StkRwIMPORT ImportItemPlusList StkSemicolon .
     
   ImportItemPlusList : ImportItem .
   ImportItemPlusList : ImportItemPlusList StkComma ImportItem . 

   ImportItem : NonreservedIdent
      { FM3ExpImp . ImportAS ( $1 . Scan , $1 . Scan ) } .
     
   ImportItem : NonreservedIdent StkRwAS NonreservedIdent
     { FM3ExpImp . ImportAS ( $1 . Scan , $3 . Scan ) } .
     
   (* FROM Id IMPORT ... *)
   FromImportLt : StkRwFROM NonreservedIdent StkRwIMPORT
     { $$ . PaRefany 
         := FM3ExpImp . GetInterface
              ( $2 . Scan . SaChars
              , $2 . Scan . Position
              , IsExport := FALSE
              ) ; 
     } . 
 
   Import : FromImportLt FromImportIdPlusList StkSemicolon . 

   FromImportIdPlusList : NonreservedIdent
     { EVAL FM3ExpImp . ImportDeclByIdent
              ( $0 . PaRefany (* Implied NARROW *) , $1 . Scan ) ; 
     } . 
   
   FromImportIdPlusList : FromImportIdPlusList StkComma NonreservedIdent
     { EVAL FM3ExpImp . ImportDeclByIdent
              ( $0 . PaRefany (* Implied NARROW *) , $3 . Scan ) ; 
     } .

   ExpImpDone : /* Empty */
     { FM3ExpImp . Done ( ) ; } . 

(* ------------------------------- Exports ------------------------- . *)

(* Exports are handled directly in pass 1, without writing internal tokens. *)

   Exports : /* Empty */ 
     { VAR LUnitRef : FM3Units . UnitRefTyp ;
       BEGIN
         LUnitRef
           := FM3ExpImp . GetInterface 
                ( FM3Units . UnitStackTopRef ^ . UntUnitIdent
                , $0 . PaPos
                , IsExport := TRUE
                ) ;
         FM3ExpImp . ImportAllDecls
           ( LUnitRef , FM3Scanner . Attribute . Position ) ;
       END (* Block. *) ;  
     } .

   Exports : StkRwEXPORTS ExportIdPlusList .

   ExportIdPlusList : ExportIdent . 

   ExportIdPlusList : ExportIdPlusList StkComma ExportIdent . 

   ExportIdent : NonreservedIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ;
       BEGIN
          LUnitRef
            := FM3ExpImp . GetInterface
                 ( $1 . Scan . SaChars
                 , $1 . Scan . Position
                 , IsExport := TRUE
                 ) ;
         FM3ExpImp . ImportAllDecls ( LUnitRef , $1 . Scan . Position ) ;
       END (* Block. *) ;  
     } .

(* ----------------------------- Identifiers ---------------------------- *)

   NonreservedIdent : StkIdent .

   NonreservedIdent : StkReservedIdent
     { FM3Pass1 . FlagReservedIdent ( $1 ) ; } .  

   IdentRef : NonreservedIdent
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
       FM3Pass1 . IdentRefL2R ( $1 ) ;
     } .

   QualIdentRef : NonreservedIdent StkDot NonreservedIdent   
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;  
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
       FM3Pass1 . QualIdentL2R ( $1 , $3 ) ;
     } .

(* List of one or more comma-separated Idents.*)
   IdPlusList : IdentRef 
     { (* PaPass1Coord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma IdentRef
     { (* PaPass1Coord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } .

   (* DeclIdListElems . PaInt > 0 is count of valid Idents. *)
   (* In source syntax, one of these is never empty and always
      comma-separated.  Internally, invalid (reserved or repeated)
      idents may be removed, which could leave it empty.  If so,
      the entire declaration is removed after issuing error messages.
   *) 

   DeclIdListElems : NonreservedIdent
     { IF FM3Pass1 . DeclIdL2R
            ( FM3Decls . TopDeclParseInfo ( ) . DiKind , IdAttribute := $1 )
       THEN (* Use this ident. *) 
         $$ . PaInt := 1 ;
         $$ . PaRefany := IntSets . Singleton ( $1 . Scan . SaAtom ) 
       ELSE
         $$ . PaInt := 0 ;
         $$ . PaRefany := IntSets . Empty ( ) 
       END (*IF*) ; 
     } . 
     
   DeclIdListElems : DeclIdListElems StkComma NonreservedIdent
     { IF FM3Pass1 . DeclIdL2R
            ( FM3Decls . TopDeclParseInfo ( ) . DiKind , IdAttribute := $3 )
       (* ^No Itk separators here.  It would be kinda silly. *) 
       THEN (* Use this ident. *)
         $$ . PaInt := $1 . PaInt + 1 ;
         $$ . PaRefany
           := IntSets . Include
                ( NARROW ( $3 . PaRefany , IntSets . T ) , $3 . Scan . SaAtom ) ;
       ELSE
         $$ . PaInt := $3 . PaInt (* Valid Id count, no increase. *) ;
         $$ . PaRefany := $3 . PaRefany ; 
       END (*IF*) ;
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma IdentRef
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* Qualified or unqualified ident. *)

   MaybeQualIdent : IdentRef
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;

     } . 
   MaybeQualIdent : QualIdent 
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
     } . 
   
   QualIdent : NonreservedIdent
     { $$ . Scan . SaChars := $1 . Scan . SaChars ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . SaBuiltinTok := $1 . Scan . SaBuiltinTok ;
       FM3Pass1 . IdentRefL2R ( $1 ) ;
     } .

(* List of zero or more comma-separated maybe-qualified Idents. *)
   MaybeQualIdentStarList : /*Empty*/
     { $$ . PaInt := 0 ; } .
   MaybeQualIdentStarList : MaybeQualIdentPlusList
     { $$ . PaInt := $1 . PaInt ; } .
   MaybeQualIdentPlusList : MaybeQualIdent
     { $$ . PaInt := 1 } . 
   MaybeQualIdentPlusList : MaybeQualIdentPlusList StkComma MaybeQualIdent
     { $$ . PaInt := $1 . PaInt + 1 ; } .
     
   TypeId : MaybeQualIdent.

   (* Make ROOT and UNTRACED ROOT look to later passes like reserved idents,
      even though they are necessarily reserved words in source syntax,
      because their syntactic contexts differ from those of identifiers:
   *) 

   TypeId : StkRwROOT
     { FM3Pass1 . PutBwd_LIP
         ( Itk . ItkReservedIdRef , Stk . RidROOT , $1 . Scan . Position ) ; 
     } . 

   TypeId : StkRwUNTRACED StkRwROOT
     { FM3Pass1 . PutBwd_LIP
         ( Itk . ItkReservedIdRef
         , Stk . RidUNTRACEDROOT
         , $1 . Scan . Position
         ) ; 
     } . 

(* ------------------------- Constant Declarations -------------------- . *) 

   OptConstType : StkColon Type
     { $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ; } . 

   (* ConstDeclGroup is a list of type declarations all following
      a single occurrence of "CONST".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   ConstDeclGroupLt : StkRwCONST 
     { $$ . Scan . Position := $1 . Scan . Position; } .

   ConstDeclGroup : ConstDeclGroupLt ConstDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   ConstDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   ConstDeclList : ConstDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   ConstDeclPlus : ConstDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   ConstDeclPlus : ConstDeclPlus ConstDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .

(* TODO:Maybe combine this with TypeDeclId and others, which differ
         only in Dkt. *) 
   ConstDeclId : NonreservedIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkConst , $1 ) ) ;
     } .

   ConstDecl : ConstDeclId OptDeclType StkEqual Expr   
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN 
         FM3Pass1 . PutBwd_LCP_eCPB_zCP_rP
           ( Itk . ItkConstDeclLt 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           
           , $2 . PaPass1Coord
           , $2 . Scan . Position
           , $2 . PaBool (* Is present. *) 
           
           , $4 . PaPass1Coord
           , $3 . Scan . Position
           
           , $1 . Scan . Position 
           ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* -------------------------- Type Declarations. --------------------- . *)

   TypeRelation : StkEqual { $$ . PaTok1 := Itk . ItkTypeDeclLt ; } .

   TypeRelation : StkSubtype { $$ . PaTok1 := Itk . ItkSubtypeDeclLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. type decls. *) 

   (* TypeDeclGroup is a list of type declarations all following
      a single occurrence of "TYPE".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   TypeDeclGroupLt : StkRwTYPE
     { $$ . Scan . Position := $1 . Scan . Position; } .

   TypeDeclGroup : TypeDeclGroupLt TypeDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   TypeDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   TypeDeclList : TypeDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   TypeDeclPlus : TypeDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   TypeDeclPlus : TypeDeclPlus TypeDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .
 
   TypeDeclId : NonreservedIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkType , $1 ) ) ; 
     } .

   TypeDecl : TypeDeclId TypeRelation Type  
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN 
         FM3Pass1 . PutBwd_LCP_eCP_rP
           ( $2 . PaTok1 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           , $2 . PaPass1Coord
           , $2 . Scan . Position
           , $1 . Scan . Position 
           ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* ----------------------------- Revelations ---------------------------- *) 

   RevelationRelation : StkEqual { $$ . PaTok1 := Itk . ItkFullRevealLt ; } .

   RevelationRelation : StkSubtype { $$ . PaTok1 := Itk . ItkPartialRevealLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. revelations. *) 

   (* RevelationGroup is a list of revelations all following
      a single occurrence of "REVEAL".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "REVEAL".  
   *)
   
   RevelationGroupLt : StkRwREVEAL
     {  $$. Scan . Position := $1 . Scan . Position  } .

   RevelationGroup : RevelationGroupLt RevelationList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   RevelationList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists. *)
         := FM3Scanner . Attribute . Position ; 
     } .

   RevelationList : RevelationPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   
   RevelationPlus : Revelation StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $2 . Scan . Position ; 
     } .

   RevelationPlus : RevelationPlus Revelation StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt semicolon. *) := $3 . Scan . Position ; 
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
       END (*IF*) ; 
     } .

   Revelation : TypeId RevelationRelation Type  
     { $$ . PaInt := 1 (* BlockDecl count. *) ;
(* CHECK^ Do we really want to count this as a block decl?  It occupies a 
          space in the Blockdecl list, but does not introduce a new identifier,
          but adds decl info about the identifier.
*) 
       FM3Pass1 . PutBwd_LCP_eCP_rP
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         , $1 . Scan . Position 
         ) ;
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDeclList, VarDecl . PaInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   
   VarDeclGroupLt : StkRwVAR
     { $$ . PaInt (* DeclParseInfoDepth *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVarDeclLt
                  , DiIdListTok := Itk . ItkVarDeclIdListLt
                  , DiIdSepTok := Itk . ItkVarDeclIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDeclList 
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt Semicolon. *) := $2 . PaPos ;  
        <* ASSERT FM3Decls . PopDeclParseInfo ( ) = $1 . PaInt *>
      } . 

   VarDeclList : /*Empty*/ 
      { $$ . PaInt := 0 (* Decl count. *) ;
        $$ . PaPos (* No trailing semicolon exists. *)
          := FM3Scanner.Attribute . Position ; 
      } .

   VarDeclList : VarDeclPlus  
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ; 

       (*FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkVarDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
       *) 
     } . 
   
   VarDeclPlus : VarDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt Semicolon. *) := $2 . Scan . Position ;  
     } .

   VarDeclPlus : VarDeclPlus VarDecl StkSemicolon 
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt Semicolon. *) := $3 . Scan . Position ;  
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ;  
       END (*IF*) ; 
     } . 

(* Used for variable and field declarations. *)

   VarDecl : VarDeclIds OptDeclType OptDeclValue 
     { IF FM3Pass1 . RequireTypeAndOrValue
             ( $1 . Scan . Position , $2 . PaBool , $3 . PaBool ) 
       (* ^Check this even if there are no valid ids. *)
          AND $1 . PaInt > 0 
       THEN 
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         WITH WDeclParseInfo = FM3Decls . TopDeclParseInfo ( )
         DO 
           FM3Pass1 . PutBwd_LCP_eCP_zCP_rP (* The declaration itself. *) 
             ( WDeclParseInfo . DiDeclTok 
             , $1 . PaPass1Coord
             , $1 . Scan . Position
             , $2 . PaPass1Coord
             , $2 . Scan . Position
             , $3 . PaPass1Coord
             , $3 . Scan . Position 
             , $1 . Scan . Position 
            ) ;
         END (*WITH*)
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ; 
         $$ . PaInt := 0 (* Contribution to BlockDeclCt. *) ; 
       END (*IF*)
     } . 

   VarDeclIds : DeclIdListElems 
     { $$ . Scan . Position := $1 . Scan . Position ;
       MakeListPos (* The identifier list. *) 
         ( $$
         , FM3Decls . TopDeclParseInfo ( ) . DiIdListTok
(* CHECK: Do we still want different decl id tokens? *) 
         , $1 . Scan . Position
         , ElemsAttr := $1
         ) ; 
     } .

   OptDeclType : StkColon Type 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkDeclTypeAbsent , FM3Scanner . Attribute . Position ) ; 
     } . 
   OptDeclValue : StkBecomes Expr 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclValue : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkDeclValAbsent , FM3Scanner . Attribute . Position ) ; 
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type :  TypeId . 

(* ------------------------ Builtin type names ---------------------- *)

   Type : StkRidADDRESS . 
   Type : StkRidBOOLEAN . 
   Type : StkRidCARDINAL . 
   Type : StkRidCHAR . 
   Type : StkRidEXTENDED . 
   Type : StkRidINTEGER . 
   Type : StkRidLONGCARD . 
   Type : StkRidLONGINT . 
   Type : StkRidLONGREAL . 
   Type : StkRidMUTEX . 
   Type : StkRidNULL . 
   Type : StkRidREAL . 
   Type : StkRidREFANY . 
   Type : StkRidTEXT . 
   Type : StkRidTYPECODE . 
   Type : StkRidWIDECHAR .

(* ------------------------------- REF Types --------------------------- *)

   Type : StkRwREF Type 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkREFTypeLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position 
         ) ;
     } .

   Type : StkUNTRACED StkRwREF Type 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkUNTRACEDREFTypeLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position 
         ) ;
     } .

(* ----------------------------- Array Types --------------------------- *)

   Type : OpenArrayType .

   OpenArrayType : StkRwARRAY StkRwOF Type 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkOpenArrayTypeLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position 
         ) ;
     } .

   Type : FixedArrayType .

   FixedArrayType : .


(* ---------------------------- Enumeration types ---------------------- *)

   EnumTypeLt : StkOpenBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkEnum
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END; 
     } .

   EnumType : EnumTypeLt EnumLitList StkCloseBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . MakeListPos
           ( LHSAttr := $$ 
           , TokLt := Itk . ItkEnumLitListLt
           , Position := $1 . Scan . Position
           , ElemsAttr := $2 
           ) ; 
       END; 
     } .

   EnumLitList : /*Empty*/
     { $$ . PaInt (* Decl count. *) := 0 ; } .

   EnumLitList : EnumLitPlus
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } . 

   EnumLitPlus : EnumLit  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   EnumLitPlus : EnumLitPlus StkComma EnumLit
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ; } .
     
   EnumLit : NonreservedIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R
                    ( Dkt . DkEnumLit
                    , $1
                    , SepTok := Itk . ItkEnumLitListSep
                    , SepPosition := $0 . Scan . Position
                    , PriorIdCt := $-1 . PaInt 
                    )
                ) ;
       IF $$ . PaInt > 0
       THEN
       END (*IF*) 
     } . 

   Type : EnumType . 

(* --------------------------Field decl lists ------------------------- *)


(* Used in both record types and object types. *) 

   FieldDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty
          ( $$
          , Itk . ItkFieldDeclListLt
          ,  FM3Scanner . Attribute . Position
          ) ;
      } .

   FieldDeclList : FieldDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkFieldDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   FieldDeclPlus : VarDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   FieldDeclPlus : FieldDeclPlus StkSemicolon VarDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFieldDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ;
         $$ . PaInt (* DeclParseInfoDepth *) 
           := FM3Decls . PushDeclParseInfo
                ( FM3Decls . DeclParseInfoTyp
                    { DiDeclTok := Itk . ItkFieldDeclLt
                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                    , DiIdSepTok := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                    , DiKind := Dkt . DkRecField 
                    }
                ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkRec
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the record type. *) 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END; 
     } . 
 
   Type : RecTypeLt FieldDeclList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>  
         FM3Pass1 . PutBwd_LCIP_rip
           ( Itk . ItkRecTypeLt
           , $1 . PaPass1Coord
           , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
           , $1 . Scan . Position
           ) ;
         <* ASSERT FM3Decls . PopDeclParseInfo ( )
                   = $1 . PaInt (* DeclParseInfoDepth. *)
         *> 
       END; 
     } .

(* ------------------------------- Method Lists ----------------------------- *)

   MethodDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkMethodDeclListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   MethodDeclList : StkRwMETHODS 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkMethodDeclListLt , 0 , $1 . Scan . Position ) ; 
      } .

   MethodDeclList : StkRwMETHODS MethodDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkMethodDeclListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   MethodDeclPlus : MethodDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   MethodDeclPlus : MethodDeclPlus StkSemicolon MethodDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkMethodDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Method Signatures -------------------------- *)

   MethodDeclLt : NonreservedIdent 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
         $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkMethod , $1 ) ) ;
         IF $$ . PaInt > 0
         THEN 
           LScopeRef
             := FM3Scopes . NewScopeRef
                  ( FM3Units . UnitStackTopRef
                  , Skt . SkFormals  
                  , FM3Scanner . Attribute . Position
                  ) ;
           FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         END (*IF*) 
       END (*Block*) 
     } . 

   MethodDecl : MethodDeclLt Signature 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . PaInt (* Valid method count. *) := $1 . PaInt ; 
         IF $$ . PaInt > 0
         THEN
(* Reduction to Formals, within Signature, will have  already popped
   the formals' scope. 
           LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
           FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
           <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
*) 
           FM3Pass1 . PutBwd_LCIP_rip
             ( Itk . ItkMethodDeclLt
             , $1 . PaPass1Coord
             , $1 . Scan . SaAtom
             , $1 . Scan . Position 
             ) ;
         ELSE (* Method Id was invalid. *) 
           FM3Pass1 . PutBwd_LCI_ri
             ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         END (*IF*) 
       END (*Block*) 
     } . 

(* ------------------------------ Override Lists ---------------------------- *)

   OverrideList : /*Empty*/
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkOverrideListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   OverrideList : StkRwOVERRIDES 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkOverrideListLt , 0 , $1 . Scan . Position ) ; 
      } .

   OverrideList : StkRwOVERRIDES OverridePlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkOverrideListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   OverridePlus : Override  
     { $$ . PaInt (* Override count. *) := $1 . PaInt ; } .

   OverridePlus : OverridePlus StkSemicolon VarDecl
     { $$ . PaInt (* Override count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkOverrideListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* -------------------------------- Overrides ------------------------------- *)

   OverrideLt : NonreservedIdent 
     { $$ . PaInt (* override count, 0 or 1. *) 
         := ORD ( FM3Pass1 . OverrideIdentRefL2R ( $1 ) ) ;
       (* ^Full legality requires looking through supertypes -- do it later. *) 
     } . 

   Override : OverrideLt StkEqual Expr 
     { $$ . PaInt (* Override count. *) := $1 . PaInt ;
       FM3Pass1 . PutBwd_LCP_eCp_rp
         ( Itk . ItkOverrideLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         , $2 . PaPass1Coord
         ) ;
     } . 

(* --------------------------------- Brands --------------------------------- *)

   Brand : /*Empty*/
     { FM3Pass1 . PutBwd_LP
         ( Itk . ItkAbsentBrand , FM3Scanner . Attribute . Position ) ;
     } . 

   Brand : StkRwBRANDED
     { FM3Pass1 . PutBwd_LP 
         ( Itk . ItkBrandAnon , $1 . Scan . Position ) ;
     } . 

   Brand : StkRwBRANDED Expr
     { FM3Pass1 . PutBwd_LP_rp 
         ( Itk . ItkBrandLt , $1 . Scan . Position ) ;
     } . 

(* ------------------------------ Object Types ------------------------------ *)

   Supertype : /*Empty*/ 
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkAbsentSupertype , FM3Scanner . Attribute . Position ) ;
     } . 

   Supertype : TypeId 
     { $$ . Scan . Position := $1 . Scan . Position ;
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkSupertypeLt
         , $1 . PaPass1Coord 
         , $1 . Scan . Position
         ) ;
     } .

   Supertype : ObjType 
     { $$ . Scan . Position := $1 . Scan . Position ;
       (* ^The supertype will be nested within this object tyhpe. *) 
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkSupertypeLt
         , $1 . PaPass1Coord 
         , $1 . Scan . Position
         ) ;
     } .


   ObjTypeLt : Supertype Brand StkRwOBJECT
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . Scan . Position := $1 . Scan . Position ;
         $$ . PaInt (* DeclParseInfoDepth *) 
           := FM3Decls . PushDeclParseInfo
                ( FM3Decls . DeclParseInfoTyp
                    { DiDeclTok := Itk . ItkFieldDeclLt
                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                    , DiIdSepTok := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                    , DiKind := Dkt . DkObjField 
                    }
                ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkObj
                , $3 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the object type. *) 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END; 
     } .

   ObjType : ObjTypeLt FieldDeclList MethodDeclList OverrideList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>  
         FM3Pass1 . PutBwd_LCP_rp
           ( Itk . ItkObjTypeLt
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           ) ;
         <* ASSERT FM3Decls . PopDeclParseInfo ( )
                   = $1 . PaInt (* DeclParseInfoDepth. *)
         *> 
       END; 
     } .

   Type : ObjType . 

(* ------------------ Procedure Types and Signatures ------------------- *)

   ProcTypeLt : StkRwPROCEDURE 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkFormals 
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;  
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ;
       END (*Block*)
     } . 
   
   Type : ProcTypeLt Signature  
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkProcTypeLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
     } . 

(* Procedure signature (Without PROCEDURE or Ident).
   Works for procedure decl, procedure definition, type decl, method decl. *)  

   Signature : Formals ResultType Raises
     { VAR LToken : Itk . TokTyp ;
       BEGIN
         IF $2 . PaBool (* Is present. *) 
         THEN LToken := Itk . ItkSignatureFuncLt
         ELSE LToken := Itk . ItkSignatureProperLt 
         END (*IF*) ; 
         FM3Pass1 . PutBwd_LCP_rp
           ( LToken 
           , $1 . PaPass1Coord 
           , $1 . Scan . Position
           ) ;
       END (*Block*) 
     } . 

(* List of formal decls. *)

(* Formals, FormalPlus, Formal . PaInt
   is formals count. *)

   Formals : StkOpenParen FormalsList StkCloseParen
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         $$ . PaInt := $2 . PaInt ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         IF LScopeRef ^ . ScpKind = Skt . SkFormals
         THEN (* Proc type, method, or in an interface, formals-only. *) 
           FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
           <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         END (*IF*) ;
         MakeListPos
           ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $2 ) ;
(* FIXME^ different tokens for different formal modes? *)
       END ;
     } .

   FormalsList : /* Empty formals list. */
     { $$ . PaInt := 0 ; } .

   FormalsList : FormalPlus OptSemicolon . 
     
   FormalPlus : FormalPlus StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFormalsListLt 
         , $2 . PaPass1Coord 
         , $1 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   FormalPlus : Formal 
     { $$ . PaInt := $1 . PaInt ; } .

(* Formal parameter modes. *) 
   FormalLt : /*Empty*/
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;  
       $$ . PaInt (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdSepTok := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .
   FormalLt : StkRwVALUE 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
       $$ . PaInt (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdSepTok := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkVARFormal ) ;
       $$ . PaInt (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkVARFormalLt
                  , DiIdListTok := Itk . ItkVARFormalIdListLt 
                  , DiIdSepTok := Itk . ItkVARFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVARFormal
                  }
              ) ;
     } .
   FormalLt : StkRwREADONLY
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkROFormal ) ;
       $$ . PaInt (* DeclParseInfoDepth after push. *) 
         := FM3Decls . PushDeclParseInfo
              ( FM3Decls . DeclParseInfoTyp
                  { DiDeclTok := Itk . ItkROFormalLt
                  , DiIdListTok := Itk . ItkROFormalIdListLt 
                  , DiIdSepTok := Itk . ItkROFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkROFormal
                  }
              ) ;
     } .

(* Formal is a formal declaration with PaInt valid ids. *)

   Formal : FormalLt FormalIds FormalType FormalExpr
     { $$ . Scan . Position := $1 . Scan . Position ; 
       VAR LOk := TRUE ; 
       BEGIN (* Do these checks even if no valid ids. *) 
         IF VAL ( $1 . PaByte , Dkt ) = Dkt . DkVARFormal   
         THEN
           IF NOT $3 . PaBool (* Formal type is present (absent?). *)
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal must have a type (2.2.8)." } 
               , $2 . Scan . Position
               ) ;
             LOk := FALSE ; 
           END (*IF*) ; 
           IF $4 . PaBool (* Formal expression is present? *) 
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal cannot have a default expression (2.2.8)." }
               , $4 . Scan . Position
               ) ;
             LOk := FALSE ; 
           END (*IF*) ;
         ELSE (* VALUE or READONLY *)  
           LOk := FM3Pass1 . RequireTypeAndOrValue
                    ( $2 . Scan . Position , $3 . PaBool , $4 . PaBool )
         END (*IF*) ;

         LOk := LOk AND $2 . PaInt > 0 ;
         
         IF NOT LOk 
         THEN (* Skip the whole decl, including possibly multiple idents. *)
           $$ . PaInt := 0 ;
           FM3Pass1 . PutBwd_LCI_ri
             ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         ELSE 
           $$ .PaInt := $2 . PaInt (* Valid Id count. *) ;  
           FM3Pass1 . PutBwd_LCP_eCP_zCP_rP 
             ( FM3Decls . TopDeclParseInfo ( ) . DiDeclTok 
             , $1 . PaPass1Coord
             , $2 . Scan . Position
             , $3 . PaPass1Coord
             , $3 . Scan . Position
             , $4 . PaPass1Coord
             , $4 . Scan . Position 
             , $1 . Scan . Position 
             ) ;
         END (*IF*) ;
         <* ASSERT FM3Decls . PopDeclParseInfo ( ) = $1 . PaInt *>
       END (*Block*) 
     } .

   (* FormalIds.PaInt > 0 is ident count. *) 
   FormalIds : DeclIdListElems 
     { $$ . Scan . Position  := $1 . Scan . Position ; 
       MakeListPos
         ( $$
         , FM3Decls . TopDeclParseInfo ( ) . DiIdListTok
         , $1 . Scan . Position
         , ElemsAttr := $1
         ) ; 
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . PaBool (* Type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
(* This looks redundant to Itk<mode>FormalType & Itk<mode>FormalVal,
   which already bracket the type of a formal. 
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkFormalTypeLt,  $1 . PaPass1Coord , $1 . Scan . Position );
*) 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
(* This looks redundant to Itk<mode>FormalVal & Itk<mode>FormalRt,
   which already bracket the type of a formal. 
       FM3Pass1 . PutBwd_LCP_rp
         (  Itk . ItkFormalExprLt, $1 . PaPass1Coord , $1 . Scan . Position );
*) 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Result type of signature. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
       $$ . PaTok1 := Itk . ItkSignatureFuncLt ; 
       FM3Pass1 . PutBwd_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaPass1Coord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       $$ . PaTok1 := Itk . ItkSignatureProperLt ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
       $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ; 
     } .

(* RAISES of signature. *) 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *) ;
       FM3Pass1 . MakeListEmpty
         ( $$ , Itk . ItkRaisesSetLt , FM3Scanner . Attribute . Position ) ; 
     } .

   Raises : StkRwRAISES StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3Pass1 . PutBwd_LP_rp
         ( Itk . ItkRaisesANY , $1 . Scan . Position ) ; 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdentStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $3 ) ;
     } . 
(* ------------------------------ Procedures ------------------------------ *)

   ProcDeclLt : StkRwPROCEDURE NonreservedIdent 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       VAR LScopeKind : Skt ;
       BEGIN
         $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
         $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R ( Dkt . DkProc , $2 ) ) ;
         IF FM3Units . CurrentUnitIsModule ( )
         THEN (* Body scope.*) 
           LScopeRef
             := FM3Scopes . NewScopeRef
                  ( FM3Units . UnitStackTopRef
                  , Skt . SkModule  
                  , FM3Scanner . Attribute . Position
                  ) ;
           FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         END (*IF*) ; 
         LScopeRef (* Formals scope. *) 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkFormals  
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpSelfScopeNo  ) ;
       END (*Block*) 
     } . 

   ProcDecl : ProcDeclLt Signature OptProcBody
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       VAR LProcTok : Itk . TokTyp ; 
       BEGIN
         $$ . PaInt (* Valid decl count. *) := $1 . PaInt ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         IF FM3Units . CurrentUnitIsModule ( )
         THEN (* => treat as having a body, regardless of source code. *) 
           IF NOT $3 . PaBool (* This procedure has no body in source code. *)
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY
                   { " A procedure in a module must have a body (2.5)." } 
               , $3 . Scan . Position
               ) ;
           END (*IF*) ;
           LProcTok := Itk . ItkProcWBodyLt ; 
         ELSE (* In an interface => treat as having no body, regardless of source. *) 
           IF $3 . PaBool (* This procedure has a body in source code. *) 
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                 { " A procedure in an interface must not have a body (2.5.2)."
                 }
               , $3 . Scan . Position
               ) ;
             FM3Pass1 . PutBwd_LCI_ri (* Skip the body. *) 
               ( Itk . ItkSkipLt
               , $3 . PaPass1Coord
               , FM3Globals . NextSkipNo  
               ) ;
             INC ( FM3Globals . NextSkipNo ) ; 
           END (*IF*);
           LProcTok := Itk . ItkProcNoBodyLt ; 
         END (*IF*) ;
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         FM3Pass1 . PutBwd_LCI_ri
           ( LProcTok , $1 . PaPass1Coord , $1 . Scan . SaAtom ) ; 
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
       END (*Block*) 
     } . 

   OptProcBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } .



(* CHECK: What happens for a forced empty body in a module? *) 
   ProcBodyLt : StkEqual 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         FM3Pass1 . PutBwd_LP
           ( Itk . ItkProcBodyLt , $1 . Scan . Position ) ;
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         FM3Scopes . PushOpenScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeLt , LScopeRef ^ . ScpSelfScopeNo ) ; 
       END (*Block*) ; 
     } .

   OptProcBody : ProcBodyLt Block NonreservedIdent StkSemicolon 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . PaBool (* Procedure has a body. *) := TRUE ; 
         $$ . Scan . Position := $1 . Scan . Position ;
         LScopeRef := FM3Scopes . OpenScopeStackTopRef ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkOpenScopeRt , LScopeRef ^ . ScpSelfScopeNo  ) ;
         <* ASSERT FM3Scopes . PopOpenScopeRef ( ) = LScopeRef *>
         FM3Pass1 . PutBwd_LP
           ( Itk . ItkProcBodyRt , $1 . Scan . Position ) ;
       END;
     } .
     
(* ---------------------------- Expressions ---------------------------- *)

   (* QualIdent and Expr each derive Ident dot Ident, with copies of the
      same semantic action.  Hopefully, difference in the left context
      will disabiguate this. 
   *)
   
   Expr : E0 .

   E0 : E1 . 
   E0 : E0 StkRwOR E1
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , Stk . StkRwOR
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E1 : E2 . 
   E1 : E1 StkRwAND E2
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , Stk . StkRwAND 
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E2 : E3 . 
   E2 : StkRwNOT E3
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkUnaryOpLt
         , $1 . PaPass1Coord
         , Stk . StkRwNOT
         , $1 . Scan . Position
         ) ; 
     } . 
   
   E3 : E4 . 
   E3 : E3 ExprRelOp E4
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , $2 . PaTok1 
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E4 : E5 . 
   E4 : E4 ExprAddOp E5
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , $2 . PaTok1 
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E5 : E6 . 
   E5 : E5 ExprMulOp E6
     { FM3Pass1 . PutBwd_LCIP_eCip_rip
         ( Itk . ItkBinaryOpLt
         , $1 . PaPass1Coord
         , $2 . PaTok1 
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E6 : E7 . 
   E6 : ExprUnaryAddOp E7
     { (* Let's leave the unary + in there, just in case there is a need
          to note its position, for some reason.
       *) 
       FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkUnaryOpLt
         , $1 . PaPass1Coord
         , $1 . PaTok1
         , $1 . Scan . Position
         ) ; 
     } .

   (* E7 is a partial Cartesian product:
          { E8WOId, Id }
        X { Deref, Subscripts, Actuals, dot-id, absent-selector }
      Not cartesion-factored, because combinations Id-dot-Id and Id-Actuals
      are special cases. 
   *) 

   E7 : E8WOId StkDeref 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkDerefLt , $1 . PaPass1Coord , $2 . Scan . Position ) ; 
     } .
     
   E7 : E8WOId Subscripts 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkSubscriptLt 
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   E7 : E8WOId Actuals  
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkCallLt 
         , $1 . PaPass1Coord
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   E7 : E8WOId StkDot NonreservedIdent 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkExprDotLt 
         , $1 . PaPass1Coord
         , $3 . Scan . SaAtom 
         , $2 . Scan . Position
         ) ; 
     } .

   E7 : E8WOId /* No selector. */ . 

   E7 : IdentRef StkDeref 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkDerefLt , $1 . PaPass1Coord , $2 . Scan . Position ) ;
     } .
     
   E7 : StkIdent Subscripts 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkSubscriptLt 
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .

   E7 : IdentRef Actuals 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkCallLt 
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } . 
     
   E7 : StkIdent /* No selector */
     { FM3Pass1 . IdentRefL2R ( $1 ) ; } .

   E7 : QualIdent /* Special case. Ident dot Ident. Can occur in other contexts. */ . 
   
  (* Array subscript list. *) 
   Subscripts : StkOpenBracket SsPlusList StkCloseBracket 
     { FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkSubscriptsPlusListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ; 
     } .
   
   SsPlusList : Expr 
     { $$ . PaInt (* Expression count *) :=  1 ; } . 
   
   SsPlusList : SsPlusList StkComma Expr 
     { $$ . PaInt (* Expression count *) := $1 . PaInt + 1 ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkSubscriptsPlusListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

  (* Actual parameter list of call. *) 
   Actuals : StkOpenParen ActualList StkCloseParen
     { FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkActualsListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ; 
     } .

   ActualList : /*Empty*/
     { $$ . PaInt (* Actual count *) :=  0 ; } . 

   ActualList : Actual 
     { $$ . PaInt (* Actual count *) :=  1 ; } . 
   
   ActualList : ActualList StkComma Actual  
     { $$ . PaInt (* Actual count *) := $1 . PaInt + 1 ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkActualsListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

   Actual : Expr
     { FM3Pass1 . PutBwd_LCP_rp
        ( Itk . ItkAnonActualLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
     } .

   Actual : NonreservedIdent StkBecomes Expr
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkNamedExprLt
         , $1 . PaPass1Coord
         , $1 . Scan . SaAtom  
         , $1 . Scan . Position
         ) ;
     } .

  (* E8WOId, Other than a single Ident, things that can be followed by
     some kinds of selectors:
  *) 

  (* Qualified (non-ident) expression . *) 
   E8WOId /* This is not a single ident.  It can have additional selectors. */ 
     : E8WOId StkDot NonreservedIdent
     { FM3Pass1 . QualIdentL2R ( $1 , $3 ) ; } .

  (* Literals.  *) 

   E8WOId : StkIntLit
     { FM3Pass1 . PutBwd_LNP
         ( Itk . ItkIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkLongIntLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkBasedLit
     { FM3Pass1 . PutBwd_LNNP 
         ( Itk . ItkBasedLit
         , $1 . Scan . SaArgValue 
         , 16L (* Base--default.*) 
(* FIXME ^ Get the real base from the scanner.
           As of 2024-4-5, only FM3DisAsm uses this. *) 
         , $1 . Scan . Position
         ) ;
     } .   
   E8WOId : StkLongBasedLit
     { FM3Pass1 . PutBwd_LNNP 
         ( Itk . ItkLongBasedLit
         , $1 . Scan . SaArgValue 
         , 16L (* Base--default.*) 
(* FIXME ^ Get the real base from the scanner.
           As of 2024-4-5, only FM3DisAsm uses this. *) 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkLongRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkExtendedLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkExtendedLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .
     
   E8WOId : StkCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkWideCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkWideCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .

   E8WOId : StkTextLit { FM3Pass1 . PutBwd_TextLit ( $1 ) ; } .
   
   E8WOId : StkWideTextLit { FM3Pass1 . PutBwd_WideTextLit ( $1 ) ; } .  

   E8WOId : StkOpenParen E0 StkCloseParen . 

   ExprRelOp : StkEqual        { $$ . PaTok1 := Stk . StkEqual ; } . 
   ExprRelOp : StkUnequal      { $$ . PaTok1 := Stk . StkUnequal ; } . 
   ExprRelOp : StkLess         { $$ . PaTok1 := Stk . StkLess ; } . 
   ExprRelOp : StkGreater      { $$ . PaTok1 := Stk . StkGreater ; } . 
   ExprRelOp : StkLessEqual    { $$ . PaTok1 := Stk . StkLessEqual ; } . 
   ExprRelOp : StkGreaterEqual { $$ . PaTok1 := Stk . StkGreaterEqual ; } .
   ExprRelOp : StkRwIN         { $$ . PaTok1 := Stk . StkRwIN ; } .


   ExprAddOp : StkPlus         { $$ . PaTok1 := Stk . StkPlus ; } . 
   ExprAddOp : StkMinus        { $$ . PaTok1 := Stk . StkMinus ; } . 
   ExprAddOp : StkAmpersand    { $$ . PaTok1 := Stk . StkAmpersand ; } .
 
   ExprMulOp : StkStar         { $$ . PaTok1 := Stk . StkStar ; } . 
   ExprMulOp : StkSlash        { $$ . PaTok1 := Stk . StkSlash ; } . 
   ExprMulOp : StkRwDIV        { $$ . PaTok1 := Stk . StkRwDIV ; } .
   ExprMulOp : StkRwMOD        { $$ . PaTok1 := Stk . StkRwMOD ; } . 

   (* These are distinguished syntactically by the parser. *) 
   ExprUnaryAddOp : StkPlus    { $$ . PaTok1 := Stk . StkUnaryPlus ; } . 
   ExprUnaryAddOp : StkMinus   { $$ . PaTok1 := Stk . StkUnaryMinus ; } . 
 
(* ------------------------------ Blocks ------------------------------- *)

   BlockLt : /*EMPTY*/
     {
     } .

   Block : BlockLt OpenDeclList StkRwBEGIN StmtList StkRwEND
     {
     } .

(* ------------------------ Block declarations ------------------------- *)

   BlockDecl : ConstDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : TypeDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ExceptDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : VarDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ProcDecl
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : RevelationGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
 
   (* A block declaration always includes a terminating semicolon in the
      source syntax, but we emit only Itk *separators*. *)

   OpenDeclList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkOpenDeclListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .
     
   OpenDeclList : BlockDeclPlus 
     { MakeListPos
         ( $$
         , Itk . ItkOpenDeclListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .
     
   BlockDeclPlus : BlockDecl 
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .

   BlockDeclPlus : BlockDeclPlus BlockDecl  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt (* Decl count. *) ;

       IF $2 . PaInt > 0
       THEN
         $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkOpenDeclListLt
           , $2 . PaPass1Coord
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
       END (*IF*) ; 
     } .

(* ---------------------------- Statements ----------------------------- *)

   StmtList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkStmtListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .

   StmtList : StmtPlus OptSemicolon 
     { MakeListPos
         ( $$
         , Itk . ItkStmtListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .

   StmtPlus : Stmt { $$ . PaInt := 0 ; } .
     
   StmtPlus : StmtPlus StkSemicolon Stmt  
     { $$ . PaInt := $1 . PaInt + 1 (* Stmt count. *) ;
       FM3Pass1 . PutBwd_ECIP (* Internal separator. *)
         ( Itk . ItkStmtListLt
         , $2 . PaPass1Coord
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { FM3Pass1 . PutBwd_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaPass1Coord
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


