
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in a semantic action, e.g.:
            (* Don't do this. *).  Probably applies to double quote too.
            lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error.
*)
            
SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the front of the parser interface. */ 
EXPORT
  {
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3IntToks;
    IMPORT FM3Pass1;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  {

(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3SrcToks AS Stk;
    IMPORT FM3Pass1;
    IMPORT FM3Extern; 
    FROM FM3Pass1 IMPORT Coord;
    FROM FM3Pass1 IMPORT PutBwd_Attribute;
    FROM FM3Pass1 IMPORT tParsAttribute;
    FROM FM3Pass1 IMPORT ParsAttrNull;
    FROM FM3Pass1 IMPORT
      PutBwd_L , PutBwd_LP , PutBwd_LCr , PutBwd_LCP_rp , PutBwd_LCP_eCP_rP ,
      PutBwd_LCPeCprp , PutBwd_LIP , PutBwd_LIP_rip , PutBwd_EIP , PutBwd_ECIP , 
      PutBwd_ECIP_riP , PutBwd_LCBr , PutBwd_LI3 , PutBwd_LI6 , 
      PutBwd_LCIeCri , PutBwd_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3Pass1 IMPORT MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Skt = FM3Scopes . ScopeKindTyp ;
    TYPE Dkt = FM3Decls . DeclKindTyp ; 
    TYPE Ukt = FM3Units . UnitKindTyp ;

    PROCEDURE Test ( READONLY Attr : tParsAttribute )
    = VAR Debug : INTEGER := 0
    ; BEGIN
        IF Attr . PaInt = FIRST ( INTEGER)
        THEN
          Debug := 19
        END 
      END Test ;

  }

/* Parser module initialization. */ 
BEGIN
  { }
  
/* Parser module final cleanup. */ 
CLOSE { }

(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code will use the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)

(* These are probably not used by lalr: 
    TkMinTok                                     =     1

    StkUnknown                                   =     1 (*16_01 *)
    StkBOF                                       =     2 (*16_02 *)
    StkEOF                                       =     3 (*16_03 *)
*)

    (* Reserved words: *) 
    StkRwAND                                     =     5 (*16_05 *)
    StkRwANY                                     =     6 (*16_06 *)
    StkRwARRAY                                   =     7 (*16_07 *)
    StkRwAS                                      =     8 (*16_08 *)
    StkRwBEGIN                                   =     9 (*16_09 *)
    StkRwBITS                                    =    10 (*16_0a *)
    StkRwBRANDED                                 =    11 (*16_0b *)
    StkRwBY                                      =    12 (*16_0c *)
    StkRwCASE                                    =    13 (*16_0d *)
    StkRwCONST                                   =    14 (*16_0e *)
    StkRwDIV                                     =    15 (*16_0f *)
    StkRwDO                                      =    16 (*16_10 *)
    StkRwELSE                                    =    17 (*16_11 *)
    StkRwELSIF                                   =    18 (*16_12 *)
    StkRwEND                                     =    19 (*16_13 *)
    StkRwEVAL                                    =    20 (*16_14 *)
    StkRwEXCEPT                                  =    21 (*16_15 *)
    StkRwEXCEPTION                               =    22 (*16_16 *)
    StkRwEXIT                                    =    23 (*16_17 *)
    StkRwEXPORTS                                 =    24 (*16_18 *)
    StkRwFINALLY                                 =    25 (*16_19 *)
    StkRwFOR                                     =    26 (*16_1a *)
    StkRwFROM                                    =    27 (*16_1b *)
    StkRwGENERIC                                 =    28 (*16_1c *)
    StkRwIF                                      =    29 (*16_1d *)
    StkRwIMPORT                                  =    30 (*16_1e *)
    StkRwIN                                      =    31 (*16_1f *)
    StkRwINTERFACE                               =    32 (*16_20 *)
    StkRwLOCK                                    =    33 (*16_21 *)
    StkRwLOOP                                    =    34 (*16_22 *)
    StkRwMETHODS                                 =    35 (*16_23 *)
    StkRwMOD                                     =    36 (*16_24 *)
    StkRwMODULE                                  =    37 (*16_25 *)
    StkRwNOT                                     =    38 (*16_26 *)
    StkRwOBJECT                                  =    39 (*16_27 *)
    StkRwOF                                      =    40 (*16_28 *)
    StkRwOR                                      =    41 (*16_29 *)
    StkRwOVERRIDES                               =    42 (*16_2a *)
    StkRwPROCEDURE                               =    43 (*16_2b *)
    StkRwRAISE                                   =    44 (*16_2c *)
    StkRwRAISES                                  =    45 (*16_2d *)
    StkRwREADONLY                                =    46 (*16_2e *)
    StkRwRECORD                                  =    47 (*16_2f *)
    StkRwREF                                     =    48 (*16_30 *)
    StkRwREPEAT                                  =    49 (*16_31 *)
    StkRwRETURN                                  =    50 (*16_32 *)
    StkRwREVEAL                                  =    51 (*16_33 *)
    StkRwROOT                                    =    52 (*16_34 *)
    StkRwSET                                     =    53 (*16_35 *)
    StkRwTHEN                                    =    54 (*16_36 *)
    StkRwTO                                      =    55 (*16_37 *)
    StkRwTRY                                     =    56 (*16_38 *)
    StkRwTYPE                                    =    57 (*16_39 *)
    StkRwTYPECASE                                =    58 (*16_3a *)
    StkRwUNSAFE                                  =    59 (*16_3b *)
    StkRwUNTIL                                   =    60 (*16_3c *)
    StkRwUNTRACED                                =    61 (*16_3d *)
    StkRwVALUE                                   =    62 (*16_3e *)
    StkRwVAR                                     =    63 (*16_3f *)
    StkRwWHILE                                   =    64 (*16_c0 00 *)
    StkRwWITH                                    =    65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =    66 (*16_c2 00 *)
    StkDot                                       =    67 (*16_c3 00 *)
    StkEqual                                     =    68 (*16_c4 00 *)
    StkOpenParen                                 =    69 (*16_c5 00 *)
    StkCloseParen                                =    70 (*16_c6 00 *)
    StkComma                                     =    71 (*16_c7 00 *)
    StkColon                                     =    72 (*16_c8 00 *)
    StkSubtype                                   =    73 (*16_c9 00 *)
    StkBecomes                                   =    74 (*16_ca 00 *)
    StkOpenBrace                                 =    75 (*16_cb 00 *)
    StkCloseBrace                                =    76 (*16_cc 00 *)
    StkStroke                                    =    77 (*16_cd 00 *)
    StkArrow                                     =    78 (*16_ce 00 *)
    StkEllipsis                                  =    79 (*16_cf 00 *)
    StkOpenBracket                               =    80 (*16_d0 00 *)
    StkCloseBracket                              =    81 (*16_d1 00 *)
    StkUnequal                                   =    82 (*16_d2 00 *)
    StkLess                                      =    83 (*16_d3 00 *)
    StkGreater                                   =    84 (*16_d4 00 *)
    StkLessEqual                                 =    85 (*16_d5 00 *)
    StkGreaterEqual                              =    86 (*16_d6 00 *)
    StkPlus                                      =    87 (*16_d7 00 *)
    StkMinus                                     =    88 (*16_d8 00 *)
    StkAmpersand                                 =    89 (*16_d9 00 *)
    StkStar                                      =    90 (*16_da 00 *)
    StkSlash                                     =    91 (*16_db 00 *)
    StkDeref                                     =    92 (*16_dc 00 *)
    StkOpenPragma                                =    93 (*16_dd 00 *)
    StkClosePragma                               =    94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =    95 (*16_df 00 *)
    StkIntLit                                    =    96 (*16_e0 00 *)
    StkLongIntLit                                =    97 (*16_e1 00 *)
    StkBasedLit                                  =    98 (*16_e2 00 *)
    StkLongBasedLit                              =    99 (*16_e3 00 *)
    StkRealLit                                   =   100 (*16_e4 00 *)
    StkLongRealLit                               =   101 (*16_e5 00 *)
    StkExtendedLit                               =   102 (*16_e6 00 *)
    StkTextLit                                   =   103 (*16_e7 00 *)
    StkWideTextLit                               =   104 (*16_e8 00 *)
    StkCharLit                                   =   105 (*16_e9 00 *)
    StkWideCharLit                               =   106 (*16_ea 00 *)
    StkLexErrChars                               =   107 (*16_eb 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *)

(* Reserved identifiers needn't be known to lalr for parsing, thus embedded
   semantic actions can refer to them directly as FM3SrcToks . Rid*, and
   no copying into here is necessary.
*) 

(* NOTE: Modula-3's idea that semicolons can optionally be separators
   or terminators fails to apply to imports, exports, or declarations,
   where they can only be terminators.  And commas are always separators.
   Regardless of the source syntax, in the internal token streams, a list
   always has separator tokens, never element terminators.   
*) 

(* --------------------- Precedence and associativity ---------------------- *)

OPER LEFT StkRwRAISES 
(*
  LEFT StkRwOR
  LEFT StkRwAND
  LEFT StkRwNOT 
  NONE StkEqual StkUnequal StkLess StkGreater StkLessEqual StkGreaterEqual
  LEFT StkPlus StkMinus StkAmpersand
  LEFT StkStar StkSlasn StkRwDIV StkRwMod
(*  LEFT StkPlus StkMinus *) 
  LEFT StkDeref
*)

(* ------------------------------- Productions. ---------------------------- *)

RULE

(* NOTE: regarding the parser's default setting of the PaPass1Coord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaPass1Coord.  For a reduce, and if the semantic
   action doesn't set PaPass1Coord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the attribute of the RHS's
   leftmost token.

   Field Scan . Position of reduced-to nonterminals is set by lalr-generated
   parsing code.  If PaPass1Coord is not set by semantic actions, it too
   is set by the generated parser.  Both are copied from the leftmost
   token of the production RHS, if it exists.  Otherwise, they are for
   the current position. 
*) 

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   UnitId : StkIdent
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
         $$ . Scan . Position := $1 . Scan . Position ;
         FM3Units . UnitStackTopRef ^ . UntUnitIdentAtom := $$ . Scan . SaAtom ;
         LScopeRef
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkModule
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
       END ; 
     } .
       
   UnitIdImpliedEXPORTS : UnitId 
     { $$ . Scan . Position := FM3Scanner . Attribute . Position;
       EVAL FM3Extern . GetExternInterface
              ( $1 . Scan . SaAtom , IsImport := FALSE ) ; 
     } .

   UnitIdAndExports : UnitIdImpliedEXPORTS
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . Scan . SaAtom (* Unit ident. *) := $1 . Scan . SaAtom ;
         $$ . Scan . Position (* Of unit ident. *) := $1 . Scan . Position ;
         LScopeRef  
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkModule
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
       END ;  
     } . 

   UnitIdAndExports : UnitId Exports 
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position ;
     } .



   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; } . 

   InterfaceLt : OptUnsafe StkRwINTERFACE StkIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
       BEGIN
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         FM3Pass1 . InterfaceId
           ( LUnitRef , $3 . Scan . SaAtom , $3 . Scan . Position ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkInterface , $1 . Scan . Position ) ;
         LUnitRef ^ . UntScopeNo := LScopeRef ^ . ScpScopeNo ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
       END ; 
     } .

   InstInterface :
     InterfaceLt StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; } . 

   InterfaceMiddle : InterfaceLt StkSemicolon Imports 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ;
       END ; 
     } . 

   Interface : InterfaceMiddle BlockDeclList StkRwEND StkIdent StkDot
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LScopeRef := FM3Scopes . LookupScopeStackTopRef ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
         <* ASSERT FM3Scopes . PopLookupScopeRef ( ) = LScopeRef *>
         <* ASSERT LScopeRef = FM3Scopes . DeclScopeStackTopRef *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef
           , $4 . Scan . SaAtom
           , Ukt . UkInterface
           , $4 . Scan . Position 
           ) ; 
         FM3Pass1 . PutBwd_LCIP_rip 
           ( Itk . ItkInterfaceLt
           , $1 . PaPass1Coord
           , FM3Units . UnitStackTopRef ^ . UntUnitNo 
           , $1 . Scan . Position
           ) ; 
       END ; 
     } .

   ModuleLt : OptUnsafe StkRwMODULE StkIdent 
     { VAR LUnitRef : FM3Units . UnitRefTyp ; 
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
       BEGIN
         LUnitRef := FM3Units . UnitStackTopRef ;
           (* ^Already pushed when source file was opened. *) 
         LUnitRef ^ . UntUnsafe := $1 . PaBool ; 
         LUnitRef ^ . UntKind := Ukt . UkModule
           (* ^Could change, if it turns out to be an instantiation. *) ; 
         FM3Pass1 . ModuleId
           ( LUnitRef , $3 . Scan . SaAtom , $3 . Scan . Position ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef 
                ( LUnitRef , Skt . SkModule , $1 . Scan . Position ) ;
         LUnitRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ; 
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
       END ; 
     } .

   InstModule :
     ModuleLt StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot 
     { FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; } . 

   ModuleMiddle : ModuleLt Exports StkSemicolon Imports 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ;
       END ; 
     } . 

   Module : ModuleMiddle BlockDeclList
            StkRwBEGIN StmtList StkRwEND StkIdent StkDot
     { VAR LUnitRef : FM3Units . UnitRefTyp ;
       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         LUnitRef := FM3Units . UnitStackTopRef ;
         LScopeRef := FM3Scopes . LookupScopeStackTopRef ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo ) ;
         <* ASSERT FM3Scopes . PopLookupScopeRef ( ) = LScopeRef *>
         <* ASSERT LScopeRef = FM3Scopes . DeclScopeStackTopRef *> 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . CheckUnitFinalId
           ( FM3Units . UnitStackTopRef
           , $6 . Scan . SaAtom
           , Ukt . UkModule
           , $6 . Scan . Position 
           ) ;
         FM3Pass1 . PutBwd_LCIP_eCiP_riP 
           ( Itk . ItkModuleLt
           , $1 . PaPass1Coord
           , LUnitRef ^ . UntUnitNo 
           , $1 . Scan . Position
           , $3 . PaPass1Coord
           , $3 . Scan . Position
           , $1 . Scan . Position 
           ) ; 
       END ; 
     } .

   GenInterfaceLt : StkRwGENERIC StkRwINTERFACE UnitId 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkInterface ) ; 
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkInterface
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
       END ; 
     } .  

   GenInterface :
       GenInterfaceLt GenInterfaceKind GenFormalList
       StkSemicolon Imports BlockDeclList StkRwEND StkIdent StkDot 
     { (* Scope ref:
        FM3Pass1 . PutBwd_LI ( Itk . ItkDeclScopeLt , $1 . PaConstructNo ) ;
       *) 
     } .

   GenModuleLt : StkRwGENERIC StkRwMODULE UnitId 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaBool := $1 . PaBool ;
         $$ . PaByte := ORD ( Ukt . UkGenModule ) ;
         LScopeRef  
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkModule
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
       END ; 
     } . 

   GenModule :
       GenModuleLt GenModuleKind GenFormalList
       StkSemicolon Imports Block StkIdent StkDot 
     { (* scope ref
          FM3Pass1 . PutBwd_LI ( Itk . ItkDeclScopeLt , $1 . PaConstructNo ) ;
       *) 
     } .


   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   CaptureCoord : /*Empty*/
     { $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ; } .
     
   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 
 
(* ----------------------------- Identifiers ---------------------------- *)

   IdentRef : StkIdent
     { FM3Pass1 . IdentRefL2R ( $1 ) ; } .

(* List of one or more comma-separated Idents.*)
   IdPlusList : IdentRef 
     { (* PaPass1Coord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma IdentRef
     { (* PaPass1Coord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } .

   (* DeclIdListElems . PaInt > 0 is count of valid Idents. *)
   (* In source syntax, one of these is never empty and always
      comma-separated.  Internally, invalid (reserved or repeated)
      idents may be removed, which could leave it empty.  But then
      the entire declaration is removed after issuing error messages.
   *) 

   DeclIdListElems : StkIdent
     { $$ . PaInt (* Valid Id count. *)
         := ORD
              ( FM3Pass1 . DeclIdL2R
                  ( Itk . ItkDeclId 
                  , FM3Decls . TopDeclInfo ( ) . DiKind
                  , IdAttribute := $1
                  )
              ) ;
     } . 
     
   DeclIdListElems : DeclIdListElems StkComma StkIdent
     { IF FM3Pass1 . DeclIdL2R
            ( Itk . ItkDeclId 
            , FM3Decls . TopDeclInfo ( ) . DiKind
            , IdAttribute := $3
            )
       (* ^No Itk separators here.  It would be kinda silly. *) 
       THEN (* Use this ident. *) $$ . PaInt := $1 . PaInt + 1 ;  
       ELSE $$ . PaInt := $1 . PaInt (* Valid Id count, no increase. *) ; 
       END (*IF*) ;
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma IdentRef
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated qualified Idents. *)
   QualIdentStarList : /*Empty*/
     { $$ . PaInt := 0 ; } .
   QualIdentStarList : QualIdentPlusList
     { $$ . PaInt := $1 . PaInt ; } .
   QualIdentPlusList : QualIdent
     { $$ . PaInt := 1 } . 
   QualIdentPlusList : QualIdentPlusList StkComma QualIdent
     { $$ . PaInt := $1 . PaInt + 1 ; } .
     
(* Qualified ident, which includes unqualified ident. *)   
   QualIdent : StkIdent { FM3Pass1 . IdentRefL2R ( $1 ) ; } .

   QualIdent : StkIdent StkDot StkIdent
     { FM3Pass1 . QualIdentL2R ( $1 , $3 ) ; } .

   TypeId : QualIdent.

   (* Make ROOT and UNTRACED ROOT look like reserved idents, even though
      they are reserved words in source syntax:
   *) 

   TypeId : StkRwROOT
     { FM3Pass1 . PutBwd_LIP
         ( Itk . ItkReservedId , Stk . RidROOT , $1 . Scan . Position ) ; 
     } . 

   TypeId : StkRwUNTRACED StkRwROOT
     { FM3Pass1 . PutBwd_LIP
         ( Itk . ItkReservedId , Stk . RidUNTRACEDROOT , $1 . Scan . Position ) ; 
     } . 

(*  ----------------------------- Imports -----------------------. *) 

   Imports : ImportsLt ImportsRecurse ImportsRt 
     { $$ . PaInt := $2 . PaInt (* Imported interface Count. *) ;
       $$ . PaLong := $2 . PaLong (* Imported unqualified Ident Count. *) ;
     } .
   ImportsLt : /*Empty*/ { FM3Pass1 . ImportsLt ( ) ; } . 
   ImportsRt : /*Empty*/ { FM3Pass1 . ImportsRt ( ) ; } . 
   ImportsRecurse : ImportsRecurse ImportItem  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt ;
       $$ . PaLong := $1 . PaLong + $2 . PaLong ;
     } .
   ImportsRecurse : /*Empty*/
     { $$ . PaInt := 0; 
       $$ . PaLong := 0L; 
     } . 

   (* IMPORT .. *) 
   ImportItem : StkRwIMPORT ImportIntfPlusList StkSemicolon  
     { $$ . PaInt := $2 . PaInt ;
       $$ . PaLong := 0L ; 
     } .
   ImportIntfPlusList : StkIdent 
     { $$ . PaInt := 1 ;
       FM3Pass1 . Import
         ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3Pass1 . PutBwd_LI3
         ( Itk . ItkImport
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         ) ;
     } . 
   ImportIntfPlusList : ImportIntfPlusList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ;
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3Pass1 . Import
         ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
       FM3Pass1 . PutBwd_LI3
         ( Itk . ItkImport
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

   (* FROM Id IMPORT ... *) 
   ImportItem : FromImportPlusList StkSemicolon 
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaLong := $1 . PaLong ; 
     } .
   FromImportPlusList : StkRwFROM IdentRef StkRwIMPORT StkIdent
     { $$ . PaInt := 1 (* InterfaceCt. *) ;
       $$ . PaLong := 1L ;
       $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
       $$ . Scan . Position := $2 . Scan . Position ; 
       FM3Pass1 . FromImport
         ( $2 . Scan . SaAtom
         , $2 . Scan . Position 
         , $4 . Scan . SaAtom
         , $4 . Scan . Position 
         ) ; 
       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
       FM3Pass1 . PutBwd_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $2 . Scan . SaAtom
         , $2 . Scan . Position . Line
         , $2 . Scan . Position . Column
         , $4 . Scan . SaAtom
         , $4 . Scan . Position . Line
         , $4 . Scan . Position . Column
         ) ;
     } . 
   FromImportPlusList : FromImportPlusList StkComma IdentRef
     { $$ . PaInt := 1 ;
       $$ . PaLong := $1 . PaLong + 1L ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3Pass1 . FromImport
         ( $1 . Scan . SaAtom
         , $1 . Scan . Position 
         , $3 . Scan . SaAtom
         , $3 . Scan . Position 
         ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
       FM3Pass1 . PutBwd_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

(* IMPORT Id AS Id; *)
(*
   ImportItem : StkRwFROM IdentRef StkRwIMPORT IdPlusList StkSemicolon 
     { $$ . PaInt := 1 ;
       $$ . PaLong := VAL ( $4 . PaInt (* IdPlusList Ct. *) , LONGINT ) ;
       FM3Pass1 . PutBwd_LCIeCri
         ( Itk . ItkImportAsLt
         , $1 . PaPass1Coord
         , $4 . PaInt
         , $3 . PaPass1Coord
         );
     } .
*)
(* ------------------------------- Exports ------------------------- . *)

(* Exports are handled directly, without writing internal tokens. *)

   Exports : 
     {

       (* FM3Extern . GetExternInterface
            ( 1 . Scan . SaAtom , IsImport := FALSE ) ;
       *) 
     } .

   Exports : StkRwEXPORTS ExportPlus .

   ExportPlus : StkIdent
     { EVAL FM3Extern . GetExternInterface
              ( $1 . Scan . SaAtom , IsImport := FALSE ) ;
     } .

   ExportPlus : ExportPlus StkComma StkIdent
     { EVAL FM3Extern . GetExternInterface
              ( $3 . Scan . SaAtom , IsImport := FALSE ) ;
     } .

(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { (* Handle this in pass 1.
          MakeListPos
            ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
       *) 
     } .

(* ------------------------- Constant Declarations -------------------- . *) 

   OptConstType : StkColon Type
     { $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ; } . 

   (* ConstDeclGroup is a list of type declarations all following
      a single occurrence of "CONST".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   ConstDeclGroupLt : StkRwCONST 
     { $$ . Scan . Position := $1 . Scan . Position; } .

   ConstDeclGroup : ConstDeclGroupLt ConstDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   ConstDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   ConstDeclList : ConstDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   ConstDeclPlus : ConstDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   ConstDeclPlus : ConstDeclPlus ConstDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkBlockDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .

(* TODO:Maybe combine this with TypeDeclId and others, which differ
         only in Dkt. *) 
   ConstDeclId : StkIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R
                    ( Itk . ItkDeclId , Dkt . DkConst , $1 )
                ) 
     } .

   ConstDecl : ConstDeclId OptDeclType StkEqual Expr   
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN 
         FM3Pass1 . PutBwd_LCP_eCPB_zCP_rP
           ( Itk . ItkConstDeclLt 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           
           , $2 . PaPass1Coord
           , $2 . Scan . Position
           , $2 . PaBool (* Is present. *) 
           
           , $4 . PaPass1Coord
           , $3 . Scan . Position
           
           , $1 . Scan . Position 
           ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* -------------------------- Type Declarations. --------------------- . *)

   TypeRelation : StkEqual { $$ . PaTok1 := Itk . ItkTypeDeclLt ; } .

   TypeRelation : StkSubtype { $$ . PaTok1 := Itk . ItkSubtypeDeclLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. type decls. *) 

   (* TypeDeclGroup is a list of type declarations all following
      a single occurrence of "TYPE".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   TypeDeclGroupLt : StkRwTYPE
     { $$ . Scan . Position := $1 . Scan . Position; } .

   TypeDeclGroup : TypeDeclGroupLt TypeDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   TypeDeclList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists *)
         := FM3Scanner . Attribute . Position ; 
     } .

   TypeDeclList : TypeDeclPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
     } . 
   
   TypeDeclPlus : TypeDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon.*) := $2 . Scan . Position ; 
     } .

   TypeDeclPlus : TypeDeclPlus TypeDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN  
         $$ . PaPos (* Rt semicolon.*) := $3 . Scan . Position ;
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkBlockDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos (* Rt semicolon of $1 *) 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon.*) := $1 . PaPos ; 
       END (*IF*) ;  
     } .
 
   TypeDeclId : StkIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R
                    ( Itk . ItkDeclId , Dkt . DkType , $1 )
                ) 
     } .

   TypeDecl : TypeDeclId TypeRelation Type  
     { $$ . PaInt := $1 . PaInt (* Contribution to BlockDecl count. *) ;
       IF $$ . PaInt > 0 
       THEN 
         FM3Pass1 . PutBwd_LCP_eCP_rP
           ( $2 . PaTok1 
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           , $2 . PaPass1Coord
           , $2 . Scan . Position
           , $1 . Scan . Position 
           ) ;
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ;
       END (*IF*) ;
     } . 

(* ----------------------------- Revelations ---------------------------- *) 

   RevelationRelation : StkEqual { $$ . PaTok1 := Itk . ItkFullRevealLt ; } .

   RevelationRelation : StkSubtype { $$ . PaTok1 := Itk . ItkPartialRevealLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. revelations. *) 

   (* RevelationGroup is a list of revelations all following
      a single occurrence of "REVEAL".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "REVEAL".  
   *)
   
   RevelationGroupLt : StkRwREVEAL
     {  $$. Scan . Position := $1 . Scan . Position  } .

   RevelationGroup : RevelationGroupLt RevelationList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
      } . 

   RevelationList : /*Empty*/
     { $$ . PaInt := 0 ;
       $$ . PaPos (* No trailing semicolon exists. *)
         := FM3Scanner . Attribute . Position ; 
     } .

   RevelationList : RevelationPlus
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   
   RevelationPlus : Revelation StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $2 . Scan . Position ; 
     } .

   RevelationPlus : RevelationPlus Revelation StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt semicolon. *) := $3 . Scan . Position ; 
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkBlockDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
       END (*IF*) ; 
     } .

   Revelation : TypeId RevelationRelation Type  
     { $$ . PaInt := 1 (* BlockDecl count. *) ;
(* CHECK^ Do we really want to count this as a block decl?  It occupies a 
          space in the Blockdecl list, but does not introduce a new identifier,
          but adds decl info about the identifier.
*) 
       FM3Pass1 . PutBwd_LCP_eCP_rP
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         , $1 . Scan . Position 
         ) ;
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDeclList, VarDecl . PaInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   
   VarDeclGroupLt : StkRwVAR
     { $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVarDeclLt
                  , DiIdListTok := Itk . ItkVarDeclIdListLt
                  , DiIdTok := Itk . ItkDeclId
                  , DiIdSepTok := Itk . ItkVarDeclIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDeclList 
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        $$ . PaPos (* Rt Semicolon. *) := $2 . PaPos ;  
        <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
      } . 

   VarDeclList : /*Empty*/ 
      { $$ . PaInt := 0 (* Decl count. *) ;
        $$ . PaPos (* No trailing semicolon exists. *)
          := FM3Scanner.Attribute . Position ; 
      } .

   VarDeclList : VarDeclPlus  
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ;
       $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ;  

       (*FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkVarDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
       *) 
     } . 
   
   VarDeclPlus : VarDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ;
       $$ . PaPos (* Rt Semicolon. *) := $2 . Scan . Position ;  
     } .

   VarDeclPlus : VarDeclPlus VarDecl StkSemicolon 
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       IF $2 . PaInt > 0
       THEN 
         $$ . PaPos (* Rt Semicolon. *) := $3 . Scan . Position ;  
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *) 
           ( Itk . ItkBlockDeclListLt
           , $2 . PaPass1Coord 
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE
         $$ . PaPos (* Rt Semicolon. *) := $1 . PaPos ;  
       END (*IF*) ; 
     } . 

(* Used for variable and field declarations. *)

   VarDecl : VarDeclIds OptDeclType OptDeclValue 
     { IF FM3Pass1 . RequireTypeAndOrValue
             ( $1 . Scan . Position , $2 . PaBool , $3 . PaBool ) 
       (* ^Check this even if there are no valid ids. *)
          AND $1 . PaInt > 0 
       THEN 
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
         DO 
           FM3Pass1 . PutBwd_LCP_eCP_zCP_rP (* The declaration itself. *) 
             ( WDeclInfo . DiDeclTok 
             , $1 . PaPass1Coord
             , $1 . Scan . Position
             , $2 . PaPass1Coord
             , $2 . Scan . Position
             , $3 . PaPass1Coord
             , $3 . Scan . Position 
             , $1 . Scan . Position 
            ) ;
         END (*WITH*)
       ELSE (* Skip the decl. *) 
         FM3Pass1 . PutBwd_LCI_ri
           ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
         INC ( FM3Globals . NextSkipNo ) ; 
         $$ . PaInt := 0 (* Contribution to BlockDeclCt. *) ; 
       END (*IF*)
     } . 

   VarDeclIds : DeclIdListElems 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
       MakeListPos (* The identifier list. *) 
         ( $$
         , FM3Decls . TopDeclInfo ( ) . DiIdListTok
(* CHECK: Do we still want different decl id tokens? *) 
         , $1 . Scan . Position
         , ElemsAttr := $1
         ) ; 
     } .

   OptDeclType : StkColon Type 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       FM3Pass1 . PutBwd_L ( Itk . ItkDeclTypeAbsent ) ; 
     } . 
   OptDeclValue : StkBecomes Expr 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclValue : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
       FM3Pass1 . PutBwd_L ( Itk . ItkDeclValAbsent ) ; 
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type :  TypeId . 

   Type : StkRwREF Type 
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkREFDefLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position 
         ) ;
     } .

   Type : StkRidADDRESS . 
   Type : StkRidBOOLEAN . 
   Type : StkRidCARDINAL . 
   Type : StkRidCHAR . 
   Type : StkRidEXTENDED . 
   Type : StkRidINTEGER . 
   Type : StkRidLONGCARD . 
   Type : StkRidLONGINT . 
   Type : StkRiDLONGREAL . 
   Type : StkRidMUTEX . 
   Type : StkRidNULL . 
   Type : StkRidREAL . 
   Type : StkRidREFANY . 
   Type : StkRidTEXT . 
   Type : StkRidTYPECODE . 
   Type : StkRidWIDECHAR .

(* --------------------------- Enumeration types ---------------------------- *)

   EnumTypeLt : StkOpenBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkEnum
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the enum type. *) 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
       END; 
     } .

   EnumType : EnumTypeLt EnumLitList StkCloseBrace
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . MakeListPos
           ( LHSAttr := $$ 
           , TokLt := Itk . ItkEnumLitListLt
           , Position := $1 . Scan . Position
           , ElemsAttr := $2 
           ) ; 
       END; 
     } .

   EnumLitList : /*Empty*/
     { $$ . PaInt (* Decl count. *) := 0 ; } .

   EnumLitList : EnumLitPlus
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } . 

   EnumLitPlus : EnumLit  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   EnumLitPlus : EnumLitPlus StkComma EnumLit
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ; } .
     
   EnumLit : StkIdent
     { $$ . PaInt (* Ident count, 0 or 1. *) 
         := ORD ( FM3Pass1 . DeclIdL2R
                    ( Itk . ItkDeclId
                    , Dkt . DkEnumLit
                    , $1
                    , SepTok := Itk . ItkEnumLitListSep
                    , SepPosition := $0 . Scan . Position
                    , PriorIdCt := $-1 . PaInt 
                    )
                ) ;
       IF $$ . PaInt > 0
       THEN
       END (*IF*) 
     } . 

   Type : EnumType . 

(* -----------------------------Field decl lists ---------------------------- *)


(* Used in both record types and object types. *) 

   FieldDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty
          ( $$
          , Itk . ItkFieldDeclListLt
          ,  FM3Scanner . Attribute . Position
          ) ;
      } .

   FieldDeclList : FieldDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkFieldDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   FieldDeclPlus : VarDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   FieldDeclPlus : FieldDeclPlus StkSemicolon VarDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFieldDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ;
         $$ . PaInt (* DeclInfoDepth *) 
           := FM3Decls . PushDeclInfo
                ( FM3Decls . DeclInfoTyp
                    { DiDeclTok := Itk . ItkFieldDeclLt
                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                    , DiIdTok := Itk . ItkDeclId
                    , DiIdSepTok
                        := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                    , DiKind := Dkt . DkRecField 
                    }
                ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkRec
                , $1 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the record type. *) 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
       END; 
     } . 
 
   Type : RecTypeLt FieldDeclList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>  
         FM3Pass1 . PutBwd_LCIP_rip
           ( Itk . ItkRecDefLt
           , $1 . PaPass1Coord
           , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
           , $1 . Scan . Position
           ) ;
         <* ASSERT FM3Decls . PopDeclInfo ( )
                   = $1 . PaInt (* DeclInfoDepth. *)
         *> 
       END; 
     } .

(* ------------------------------- Method Lists ----------------------------- *)

   MethodDeclList : /*Empty*/
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkMethodDeclListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   MethodDeclList : StkRwMETHODS 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkMethodDeclListLt , 0 , $1 . Scan . Position ) ; 
      } .

   MethodDeclList : StkRwMETHODS MethodDeclPlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkMethodDeclListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   MethodDeclPlus : MethodDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   MethodDeclPlus : MethodDeclPlus StkSemicolon MethodDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkMethodDeclListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Method Signatures -------------------------- *)

   MethodDeclLt : StkIdent 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
         $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R
                      ( Itk . ItkDeclId , Dkt . DkMethod , $1 )
                  ) ;
         IF $$ . PaInt > 0
         THEN 
           LScopeRef
             := FM3Scopes . NewScopeRef
                  ( FM3Units . UnitStackTopRef
                  , Skt . SkFormals  
                  , FM3Scanner . Attribute . Position
                  ) ;
           FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
         END (*IF*) 
       END (*Block*) 
     } . 

   MethodDecl : MethodDeclLt Signature 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . PaInt (* Valid method count. *) := $1 . PaInt ; 
         IF $$ . PaInt > 0
         THEN
(* Reduction to Formals, within Signature, will have  already popped
   the formals' scope. 
           LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
           FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
           <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
*) 
           FM3Pass1 . PutBwd_LCIP_rip
             ( Itk . ItkMethodDeclLt
             , $1 . PaPass1Coord
             , $1 . Scan . SaAtom
             , $1 . Scan . Position 
             ) ;
         ELSE (* Method Id was invalid. *) 
           FM3Pass1 . PutBwd_LCI_ri
             ( Itk . ItkSkipLt , $1 . PaPass1Coord , FM3Globals . NextSkipNo ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         END (*IF*) 
       END (*Block*) 
     } . 

(* ------------------------------ Override Lists ---------------------------- *)

   OverrideList : /*Empty*/
      { FM3Pass1 . MakeListEmpty 
          ( $$
          , Itk . ItkOverrideListLt
          , FM3Scanner . Attribute . Position
          ) ; 
      } .

   OverrideList : StkRwOVERRIDES 
      { FM3Pass1 . PutBwd_LIP_rip
          ( Itk . ItkOverrideListLt , 0 , $1 . Scan . Position ) ; 
      } .

   OverrideList : StkRwOVERRIDES OverridePlus OptSemicolon 
     { FM3Pass1 . MakeListPos
         ( $$
         , Itk . ItkOverrideListLt
         , $1 . Scan . Position
         , $2 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   OverridePlus : Override  
     { $$ . PaInt (* Override count. *) := $1 . PaInt ; } .

   OverridePlus : OverridePlus StkSemicolon VarDecl
     { $$ . PaInt (* Override count. *):= $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkOverrideListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* -------------------------------- Overrides ------------------------------- *)

   OverrideLt : StkIdent 
     { $$ . PaInt (* override count, 0 or 1. *) 
         := ORD ( FM3Pass1 . OverrideIdentRefL2R ( $1 ) ) ;
       (* ^Full legality requires looking through supertypes -- do it later. *) 
     } . 

   Override : OverrideLt StkEqual Expr 
     { $$ . PaInt (* Override count. *) := $1 . PaInt ;
       FM3Pass1 . PutBwd_LCP_eCp_rp
         ( Itk . ItkOverrideLt
         , $1 . PaPass1Coord
         , $1 . Scan . Position
         , $2 . PaPass1Coord
         ) ;
     } . 

(* --------------------------------- Brands --------------------------------- *)

   Brand : /*Empty*/
     { FM3Pass1 . PutBwd_LP
         ( Itk . ItkAbsentBrand , FM3Scanner . Attribute . Position ) ;
     } . 

   Brand : StkRwBRANDED
     { FM3Pass1 . PutBwd_LP 
         ( Itk . ItkBrandAnon , $1 . Scan . Position ) ;
     } . 

   Brand : StkRwBRANDED Expr
     { FM3Pass1 . PutBwd_LP_rp 
         ( Itk . ItkBrandLt , $1 . Scan . Position ) ;
     } . 

(* ------------------------------ Object Types ------------------------------ *)

   Supertype : /*Empty*/ 
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkAbsentSupertype , FM3Scanner . Attribute . Position ) ;
     } . 

   Supertype : TypeId 
     { $$ . Scan . Position := $1 . Scan . Position ;
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkSupertypeLt
         , $1 . PaPass1Coord 
         , $1 . Scan . Position
         ) ;
     } .

   Supertype : ObjType 
     { $$ . Scan . Position := $1 . Scan . Position ;
       (* ^The supertype will be nested within this object tyhpe. *) 
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkSupertypeLt
         , $1 . PaPass1Coord 
         , $1 . Scan . Position
         ) ;
     } .


   ObjTypeLt : Supertype Brand StkRwOBJECT
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN 
         $$ . Scan . Position := $1 . Scan . Position ;
         $$ . PaInt (* DeclInfoDepth *) 
           := FM3Decls . PushDeclInfo
                ( FM3Decls . DeclInfoTyp
                    { DiDeclTok := Itk . ItkFieldDeclLt
                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                    , DiIdTok := Itk . ItkDeclId
                    , DiIdSepTok
                        := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                    , DiKind := Dkt . DkObjField 
                    }
                ) ;
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkObj
                , $3 . Scan . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
(* TODO: Store LScopeRef or its ScopeNo in the object type. *) 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
       END; 
     } .

   ObjType : ObjTypeLt FieldDeclList MethodDeclList OverrideList StkRwEND
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ; 
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>  
         FM3Pass1 . PutBwd_LCP_rp
           ( Itk . ItkObjDefLt
           , $1 . PaPass1Coord
           , $1 . Scan . Position
           ) ;
         <* ASSERT FM3Decls . PopDeclInfo ( )
                   = $1 . PaInt (* DeclInfoDepth. *)
         *> 
       END; 
     } .

   Type : ObjType . 

(* ------------------ Procedure Types and Signatures ------------------- *)

   ProcTypeLt : StkRwPROCEDURE 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         LScopeRef 
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , Skt . SkFormals 
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;  
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ;
       END (*Block*)
     } . 
   
   Type : ProcTypeLt Signature  
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkProcTypeLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
     } . 

(* Procedure signature (Without PROCEDURE or Ident).
   Works for procedure decl, procedure definition, type decl, method decl. *)  

   Signature : Formals ResultType Raises
     { VAR LToken : Itk . TokTyp ;
       BEGIN
         IF $2 . PaBool (* Is present. *) 
         THEN LToken := Itk . ItkSignatureFuncLt
         ELSE LToken := Itk . ItkSignatureProperLt 
         END (*IF*) ; 
         FM3Pass1 . PutBwd_LCP_rp
           ( LToken 
           , $1 . PaPass1Coord 
           , $1 . Scan . Position
           ) ;
       END (*Block*) 
     } . 

(* List of formal decls. *)

(* Formals, FormalPlus, Formal . PaInt
   is formals count. *)

   Formals : StkOpenParen FormalsList StkCloseParen
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         $$ . PaInt := $2 . PaInt ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         IF LScopeRef ^ . ScpKind = Skt . SkFormals
         THEN (* Proc type, method, or in an interface, formals-only. *) 
           FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
           FM3Pass1 . PutBwd_LI
             ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
           <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         END (*IF*) ;
         MakeListPos
           ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $2 ) ;
(* FIXME^ different tokens for different formal modes? *)
       END ;
     } .

   FormalsList : /* Empty formals list. */
     { $$ . PaInt := 0 ; } .

   FormalsList : FormalPlus OptSemicolon . 
     
   FormalPlus : FormalPlus StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkFormalsListLt 
         , $2 . PaPass1Coord 
         , $1 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   FormalPlus : Formal 
     { $$ . PaInt := $1 . PaInt ; } .

(* Formal parameter modes. *) 
   FormalLt : /*Empty*/
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;  
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdTok := Itk . ItkDeclId
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .
   FormalLt : StkRwVALUE 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdTok := Itk . ItkDeclId
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkVARFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVARFormalLt
                  , DiIdListTok := Itk . ItkVARFormalIdListLt 
                  , DiIdTok := Itk . ItkDeclId
                  , DiIdSepTok := Itk . ItkVARFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVARFormal
                  }
              ) ;
     } .
   FormalLt : StkRwREADONLY
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkROFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkROFormalLt
                  , DiIdListTok := Itk . ItkROFormalIdListLt 
                  , DiIdTok := Itk . ItkDeclId
                  , DiIdSepTok := Itk . ItkROFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkROFormal
                  }
              ) ;
     } .

(* Formal is a formal declaration with PaInt valid ids. *)

   Formal : FormalLt FormalIds FormalType FormalExpr
     { $$ . Scan . Position := $1 . Scan . Position ; 
       VAR LOk := TRUE ; 
       BEGIN (* Do these checks even if no valid ids. *) 
         IF VAL ( $1 . PaByte , Dkt ) = Dkt . DkVARFormal   
         THEN
           IF NOT $3 . PaBool (* Formal type is present (absent?). *)
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal must have a type (2.2.8)." } 
               , $2 . Scan . Position
               ) ;
             LOk := FALSE ; 
           END (*IF*) ; 
           IF $4 . PaBool (* Formal expression is present? *) 
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                   { " VAR formal cannot have a default expression (2.2.8)." }
               , $4 . Scan . Position
               ) ;
             LOk := FALSE ; 
           END (*IF*) ;
         ELSE (* VALUE or READONLY *)  
           LOk := FM3Pass1 . RequireTypeAndOrValue
                    ( $2 . Scan . Position , $3 . PaBool , $4 . PaBool )
         END (*IF*) ;

         LOk := LOk AND $2 . PaInt > 0 ;
         
         IF NOT LOk 
         THEN (* Skip the whole decl, including possibly multiple idents. *)
           $$ . PaInt := 0 ;
           FM3Pass1 . PutBwd_LCI_ri
             ( Itk . ItkSkipLt
             , $1 . PaPass1Coord
             , FM3Globals . NextSkipNo
             ) ;
           INC ( FM3Globals . NextSkipNo ) ;
         ELSE 
           $$ .PaInt := $2 . PaInt (* Valid Id count. *) ;  
           FM3Pass1 . PutBwd_LCP_eCP_zCP_rP 
             ( FM3Decls . TopDeclInfo ( ) . DiDeclTok 
             , $1 . PaPass1Coord
             , $2 . Scan . Position
             , $3 . PaPass1Coord
             , $3 . Scan . Position
             , $4 . PaPass1Coord
             , $4 . Scan . Position 
             , $1 . Scan . Position 
             ) ;
         END (*IF*) ;
         <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
       END (*Block*) 
     } .

   (* FormalIds.PaInt > 0 is ident count. *) 
   FormalIds : DeclIdListElems 
     { $$ . Scan . Position  := $1 . Scan . Position ; 
       $$ .PaInt := $1 . PaInt (* Valid Id Ct. *) ; 
       MakeListPos
         ( $$
         , FM3Decls . TopDeclInfo ( ) . DiIdListTok
         , $1 . Scan . Position
         , ElemsAttr := $1
         ) ; 
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . PaBool (* Type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
(* This looks redundant to Itk<mode>FormalType & Itk<mode>FormalVal,
   which already bracket the type of a formal. 
       FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkFormalTypeLt,  $1 . PaPass1Coord , $1 . Scan . Position );
*) 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
(* This looks redundant to Itk<mode>FormalVal & Itk<mode>FormalRt,
   which already bracket the type of a formal. 
       FM3Pass1 . PutBwd_LCP_rp
         (  Itk . ItkFormalExprLt, $1 . PaPass1Coord , $1 . Scan . Position );
*) 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Result type of signature. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
       $$ . PaTok1 := Itk . ItkSignatureFuncLt ; 
       FM3Pass1 . PutBwd_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaPass1Coord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       $$ . PaTok1 := Itk . ItkSignatureProperLt ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
       $$ . PaPass1Coord := FM3Pass1 . Coord ( ) ; 
     } .

(* RAISES of signature. *) 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *) ;
       FM3Pass1 . MakeListEmpty
         ( $$ , Itk . ItkRaisesSetLt , FM3Scanner . Attribute . Position ) ; 
     } .

   Raises : StkRwRAISES StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3Pass1 . PutBwd_LP_rp
         ( Itk . ItkRaisesANY , $1 . Scan . Position ) ; 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdentStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $3 ) ;
     } . 
(* ------------------------------ Procedures ------------------------------ *)

   ProcDeclLt : StkRwPROCEDURE StkIdent 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       VAR LScopeKind : Skt ;
       BEGIN
         $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
         $$ . PaInt (* Ident count, 0 or 1. *) 
           := ORD ( FM3Pass1 . DeclIdL2R
                      ( Itk . ItkDeclId , Dkt . DkProc , $2 )
                  ) ;
         IF FM3Units . CurrentlyInModule ( )
         THEN LScopeKind  := Skt . SkFormalsAndBody ; 
         ELSE LScopeKind  := Skt . SkFormals ;
         END (*IF*) ; 
         LScopeRef
           := FM3Scopes . NewScopeRef
                ( FM3Units . UnitStackTopRef
                , LScopeKind 
                , FM3Scanner . Attribute . Position
                ) ;
         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
       END (*Block*) 
     } . 

   ProcDecl : ProcDeclLt Signature OptProcBody
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
       VAR LProcTok : Itk . TokTyp ; 
       BEGIN
         $$ . PaInt (* Valid decl count. *) := $1 . PaInt ; 
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         IF FM3Units . CurrentlyInModule ( )
         THEN (* => will have a body, regardless of source code. *) 
           IF NOT $3 . PaBool (* This procedure has no body in source code. *)
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY
                   { " A procedure in a module must have a body (2.5)." } 
               , $3 . Scan . Position
               ) ;
           END (*IF*) ;
           LProcTok := Itk . ItkProcWBodyLt ; 
         ELSE (* In an interface => will have no body, regardless of source. *) 
           IF $3 . PaBool (* This procedure has a body in source code. *) 
           THEN
             FM3Messages . ErrorArr
               ( ARRAY OF REFANY 
                 { " A procedure in an interface must not have a body (2.5.2)."
                 }
               , $3 . Scan . Position
               ) ;
             FM3Pass1 . PutBwd_LCI_ri (* Skip the body. *) 
               ( Itk . ItkSkipLt
               , $3 . PaPass1Coord
               , FM3Globals . NextSkipNo  
               ) ;
             INC ( FM3Globals . NextSkipNo ) ; 
           END (*IF*);
           LProcTok := Itk . ItkProcNoBodyLt ; 
         END (*IF*) ;
         FM3Pass1 . DeclScopeRtL2R ( LScopeRef ) ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
         <* ASSERT FM3Scopes . PopDeclScopeRef ( ) = LScopeRef *>
         FM3Pass1 . PutBwd_LCI_ri
           ( LProcTok , $1 . PaPass1Coord , $1 . Scan . SaAtom ) ; 
       END (*Block*) 
     } . 

   OptProcBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       FM3Pass1 . PutBwd_LP
         ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } .



(* CHECK: What happens for a forced empty body in a module? *) 
   ProcBodyLt : StkEqual 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . Scan . Position := $1 . Scan . Position ;
         FM3Pass1 . PutBwd_LP
           ( Itk . ItkProcBodyLt , $1 . Scan . Position ) ;
         LScopeRef := FM3Scopes . DeclScopeStackTopRef ;
         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ; 
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
       END (*Block*) ; 
     } .

   OptProcBody : ProcBodyLt Block StkIdent StkSemicolon 
     { VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
       BEGIN
         $$ . PaBool (* Procedure has a body. *) := TRUE ; 
         $$ . Scan . Position := $1 . Scan . Position ;
         LScopeRef := FM3Scopes . LookupScopeStackTopRef ;
         FM3Pass1 . PutBwd_LI
           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
         <* ASSERT FM3Scopes . PopLookupScopeRef ( ) = LScopeRef *>
         FM3Pass1 . PutBwd_LP
           ( Itk . ItkProcBodyRt , $1 . Scan . Position ) ;
       END;
     } .
     
(* ---------------------------- Expressions ---------------------------- *)

   (* QualIdent and Expr each derive Ident dot Ident, with copies of the
      same semantic action.  Hopefully, difference in the left context
      will disabiguate this. 
   *)
   
   Expr : E0 .

   E0 : E1 . 
   E0 : E0 StkRwOR E1
     { FM3Pass1 . PutBwd_LCP_eCp_rp
         ( Itk . ItkORLt
         , $1 . PaPass1Coord
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E1 : E2 . 
   E1 : E1 StkRwAND E2
     { FM3Pass1 . PutBwd_LCP_eCp_rp
         ( Itk . ItkANDLt
         , $1 . PaPass1Coord
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E2 : E3 . 
   E2 : StkRwNOT E3
     { FM3Pass1 . PutBwd_LCP_rp
         ( Itk . ItkNOTLt , $1 . PaPass1Coord , $1 . Scan . Position ) ; 
     } . 
   
   E3 : E4 . 
   E3 : E3 ExprRelOp E4
     { FM3Pass1 . PutBwd_LCP_eCp_rp
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E4 : E5 . 
   E4 : E4 ExprAddOp E5
     { FM3Pass1 . PutBwd_LCP_eCp_rp
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E5 : E6 . 
   E5 : E5 ExprMulOp E6
     { FM3Pass1 . PutBwd_LCP_eCp_rp
         ( $2 . PaTok1 
         , $1 . PaPass1Coord
         , $2  . Scan . Position
         , $2 . PaPass1Coord 
         ) ; 
     } . 
   
   E6 : E7 . 
   E6 : ExprUnaryAddOp E7
     { (* Let's leave the unary + in there, just in case there is a need
          to note its position, for some reason.
       *) 
       FM3Pass1 . PutBwd_LCP_rp
         ( $1 . PaTok1 , $1 . PaPass1Coord , $1 . Scan . Position ) ; 
     } .

   (* A cartesian product:
          { E8 without Id, Id }
        X { Selector without dot, dot, noselector }
   *) 

   E7 : E8WOId SelectorWODot 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( $2 . PaTok1
         , $1 . PaPass1Coord
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   E7 : E8WOId StkDot StkIdent 
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkExprDotLt 
         , $1 . PaPass1Coord
         , $3 . Scan . SaAtom 
         , $2 . Scan . Position
         ) ; 
     } .

   E7 : E8WOId /* No selector. */ . 

   E7 : IdentRef SelectorWODot
     { FM3Pass1 . PutBwd_LCIP_rip
         ( $2 . PaTok1
         , $1 . PaPass1Coord 
         , $2 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .
     
   E7 : IdentRef /* No selector/ */ . 

  (* Qualified ident. *) 
   E8WOId /* A qualIdent is not a simple ident, and can have additional
             selectors. */ 
     : StkIdent StkDot StkIdent
     { FM3Pass1 . QualIdentL2R ( $1 , $3 ) ; } .

  (* Dereference. *) 
   SelectorWODot : StkDeref
     { $$ . PaTok1 := Itk . ItkDerefLt ;
       $$ . PaInt := 0 (* Meaningless. *) ;
     } .

  (* Array subscript list. *) 
   SelectorWODot : StkOpenBracket SsPlusList StkCloseBracket 
     { $$ . PaTok1 := Itk . ItkSubscriptLt ;
       $$ . PaInt := $2 . PaInt (* Subscript count. *) ;
       FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkSubscriptsPlusListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ; 
     } .
   
   SsPlusList : Expr 
     { $$ . PaInt (* Expression count *) :=  1 ; } . 
   
   SsPlusList : SsPlusList StkComma Expr 
     { $$ . PaInt (* Expression count *) := $1 . PaInt + 1 ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkSubscriptsPlusListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

  (* Actual parameter list of call. *) 
   SelectorWODot : StkOpenParen ActualList StkCloseParen
     { $$ . PaTok1 := Itk . ItkCallLt ;
       $$ . PaInt := $2 . PaInt (* Actuals count. *) ;
       FM3Pass1 . MakeListPos
         ( LHSAttr := $$
         , TokLt := Itk . ItkActualsListLt
         , Position := $1 . Scan . Position
         , ElemsAttr := $2
         ) ; 
     } .

   ActualList : /*Empty*/
     { $$ . PaInt (* Actual count *) :=  0 ; } . 

   ActualList : Actual 
     { $$ . PaInt (* Actual count *) :=  1 ; } . 
   
   ActualList : ActualList StkComma Actual  
     { $$ . PaInt (* Actual count *) := $1 . PaInt + 1 ;
       FM3Pass1 . PutBwd_ECIP
         ( Itk . ItkActualsListLt
         , $2 . PaPass1Coord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

   Actual : Expr
     { FM3Pass1 . PutBwd_LCP_rp
        ( Itk . ItkAnonActualLt , $1 . PaPass1Coord , $1 . Scan . Position ) ;
     } .

   Actual : StkIdent StkBecomes Expr
     { FM3Pass1 . PutBwd_LCIP_rip
         ( Itk . ItkNamedExprLt
         , $1 . PaPass1Coord
         , $1 . Scan . SaAtom  
         , $1 . Scan . Position
         ) ;
     } .

  (* Literals.  *) 

   E8WOId : StkIntLit
     { FM3Pass1 . PutBwd_LNP
         ( Itk . ItkIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkLongIntLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongIntLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkBasedLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkBasedLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .   
   E8WOId : StkLongBasedLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongBasedLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkLongRealLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkLongRealLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } . 
   E8WOId : StkExtendedLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkExtendedLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .
     
   E8WOId : StkCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .  
   E8WOId : StkWideCharLit
     { FM3Pass1 . PutBwd_LNP 
         ( Itk . ItkWideCharLit
         , $1 . Scan . SaArgValue 
         , $1 . Scan . Position
         ) ;
     } .

   E8WOId : StkTextLit { FM3Pass1 . PutBwd_TextLit ( $1 ) ; } .
   
   E8WOId : StkWideTextLit { FM3Pass1 . PutBwd_WideTextLit ( $1 ) ; } .  

   E8WOId : StkOpenParen E0 StkCloseParen . 

   ExprRelOp : StkEqual        { $$ . PaTok1 := Itk . ItkEqualLt ; } . 
   ExprRelOp : StkUnequal      { $$ . PaTok1 := Itk . ItkUnequalLt ; } . 
   ExprRelOp : StkLess         { $$ . PaTok1 := Itk . ItkLessLt ; } . 
   ExprRelOp : StkGreater      { $$ . PaTok1 := Itk . ItkGreaterLt ; } . 
   ExprRelOp : StkLessEqual    { $$ . PaTok1 := Itk . ItkLessEqualLt ; } . 
   ExprRelOp : StkGreaterEqual { $$ . PaTok1 := Itk . ItkGreaterEqualLt ; } .
   ExprRelOp : StkRwIN         { $$ . PaTok1 := Itk . ItkINLt ; } .


   ExprAddOp : StkPlus         { $$ . PaTok1 := Itk . ItkBinaryPlusLt ; } . 
   ExprAddOp : StkMinus        { $$ . PaTok1 := Itk . ItkBinaryMinusLt ; } . 
   ExprAddOp : StkAmpersand    { $$ . PaTok1 := Itk . ItkAmpersandLt ; } .
 
   ExprMulOp : StkStar         { $$ . PaTok1 := Itk . ItkStarLt ; } . 
   ExprMulOp : StkSlash        { $$ . PaTok1 := Itk . ItkSlashLt ; } . 
   ExprMulOp : StkRwDIV        { $$ . PaTok1 := Itk . ItkDIVLt ; } .
   ExprMulOp : StkRwMOD        { $$ . PaTok1 := Itk . ItkMODLt ; } . 
   
   ExprUnaryAddOp : StkPlus    { $$ . PaTok1 := Itk . ItkUnaryPlusLt ; } . 
   ExprUnaryAddOp : StkMinus   { $$ . PaTok1 := Itk . ItkUnaryMinusLt ; } . 
 
(* ------------------------------ Blocks ------------------------------- *)

   BlockLt : /*EMPTY*/
     {
     } .

   Block : BlockLt BlockDeclList StkRwBEGIN StmtList StkRwEND
     {
     } .

(* ------------------------ Block declarations ------------------------- *)

   BlockDecl : ConstDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : TypeDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ExceptDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : VarDeclGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
   BlockDecl : ProcDecl
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .
   BlockDecl : RevelationGroup
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } . 
 
   (* A block declaration always includes a terminating semicolon in the
      source syntax, but we emit only Itk *separators*. *)

   BlockDeclList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkBlockDeclListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .
     
   BlockDeclList : BlockDeclPlus 
     { MakeListPos
         ( $$
         , Itk . ItkBlockDeclListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .
     
   BlockDeclPlus : BlockDecl 
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ;
       $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
     } .

   BlockDeclPlus : BlockDeclPlus BlockDecl  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt (* Decl count. *) ;

       IF $2 . PaInt > 0
       THEN
         $$ . PaPos (* Rt semicolon. *) := $2 . PaPos ; 
         FM3Pass1 . PutBwd_ECIP (* Insert a separator. *)
           ( Itk . ItkBlockDeclListLt
           , $2 . PaPass1Coord
           , $1 . PaInt
           , $1 . PaPos 
           ) ;
       ELSE 
         $$ . PaPos (* Rt semicolon. *) := $1 . PaPos ; 
       END (*IF*) ; 
     } .

(* ---------------------------- Statements ----------------------------- *)

   StmtList : /*Empty*/
     { FM3Pass1 . MakeListEmpty 
         ( $$
         , Itk . ItkStmtListLt
         , FM3Scanner . Attribute . Position
         ) ; 
     } .

   StmtList : StmtPlus OptSemicolon 
     { MakeListPos
         ( $$
         , Itk . ItkStmtListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .

   StmtPlus : Stmt { $$ . PaInt := $1 . PaInt (* Stmt count. *) ; } .
     
   StmtPlus : StmtPlus StkSemicolon Stmt  
     { $$ . PaInt := $1 . PaInt + 1 (* Stmt count. *) ;
       FM3Pass1 . PutBwd_ECIP (* Internal separator. *)
         ( Itk . ItkStmtListLt
         , $2 . PaPass1Coord
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { FM3Pass1 . PutBwd_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaPass1Coord
         , $2 . PaPass1Coord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


