
(* This file was generated by metaprogram lalr,
   with command line:
   ../lib/lalr -M -g -k -i -t -d -D FM3Parser.lalr
*)




  UNSAFE MODULE FM3Parser;

  IMPORT FM3Scanner;

IMPORT Fmt, OSError, Rd, Thread, Text, TextWr, Word, Wr;

IMPORT Positions, Strings, IntSets, System;

IMPORT FM3SharedUtils;


(* Global insertions from the .lalr file: *)
(* line 28 "FM3Parser.lalr" *)
 IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3ParsePass;
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_L , Push_LP , Push_LCr , Push_LCP_rp , Push_LCPeCrP , Push_LCPeCprp ,
      Push_ECPrP , Push_LCBr , Push_LCIri , Push_LI3 , Push_LI6 , Push_LCeCr ,
      Push_LCIeCri , Push_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeList , MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  
(* End of global insertions from the .lalr file: *) 

CONST
   yyInitStackSize      = 100;
   yyStackExpansionFactor = 2.0;
   yyNoState            = 0;

(* Lalr-generated constants: *) 
   yyFirstTerminal          = 0;
   yyLastTerminal           = 108;
   yyFirstSymbol            = 0;
   yyLastSymbol             = 182;
   yyTableMax               = 335;
   yyNTableMax              = 273;
   yyFirstReadState         = 1;
   yyLastReadState          = 129;
   yyFirstReadTermState             = 130;
   yyLastReadTermState              = 167;
   yyLastReadNontermState           = 205;
   yyFirstReduceState               = 206;
   yyLastReduceState                = 322;
   yyStartState             = 1;
   yyStopState              = 206;
(* End of lalr-generated constants: *) 

TYPE
   M2SHORTCARD = [ 0 .. 16_FFFF ];
   yyTableElmt = M2SHORTCARD;
   
CONST yyTableElmtBits = BITSIZE ( yyTableElmt );

   (* The conversion to Modula-3 is very fragile, in part due to the
      use of unsafe address arithmetic.
      On the one hand, some types, in some contexts, need to be
      subranges (particularly, as fixed array subscript types),
      and other times, need to have the same size as in Modula-2, to avoid
      undermining various unsafe address arithmetic.  Modula-3 infers
      its own sizes from subranges, except for fields and elements when
      BITS FOR is used.  But assignments involving scalars with BIT FOR
      types present problems and even CM3 code generator failures.

      So if it is a BITS FOR type, its name ends in "Packed", otherwise
      not, the relevant ones ending in "Range".

      Additionally, CM3 has code generator failures assigning between two
      BIT FOR types, at times.  Actual cases where this has happened are
      replaced by two-step copies with an intermediate, unpacked temporary.
  
      These BITS FOR types must occupy exactly a Modula2-SHORTCARD, when used
      as elements or fields, but must their have subrange bounds when
      used as array subscript types. There a few places where a scalar
      of one of these also must occupy exactly a Modula2-SHORTCARD. 
   *)
CONST
   yyFirstFinalState    = yyFirstReadTermState;
   (* ^Any action that does a reduce, i.e., readTermReduce, readNTReduce,
       or simple Reduce.  These are are actions, not true item-set states.
   *) 
   yyLastState          = yyLastReduceState;

TYPE
   yyTCombRangePacked      = BITS yyTableElmtBits FOR [0 .. yyTableMax];
   yyNCombRangePacked      = BITS yyTableElmtBits
                             FOR [yyLastTerminal + 1 .. yyNTableMax];
   yyStateRange            = [0 .. yyLastState];
   yyStateRangePacked      = BITS yyTableElmtBits FOR yyStateRange;
   yyReadRange             = [yyFirstReadState .. yyLastReadState];
   yyReadRangePacked       = BITS yyTableElmtBits FOR yyReadRange;
   yyReadReduceRangePacked = BITS yyTableElmtBits
                             FOR [yyFirstReadTermState .. yyLastReadNontermState];
   yyReduceRangePacked     = BITS yyTableElmtBits
                             FOR [yyFirstReduceState .. yyLastReduceState];
   yySymbolRange           = [yyFirstSymbol .. yyLastSymbol];
   yySymbolRangePacked     = BITS yyTableElmtBits FOR yySymbolRange;
   yyTCombType          = RECORD Check, Next: yyStateRangePacked; END;
   yyNCombType          = yyStateRangePacked;
   yyTCombTypePtr       = UNTRACED BRANDED REF  yyTCombType;
   yyNCombTypePtr       = UNTRACED BRANDED REF  yyNCombType;
   yyStackPtrType       = BITS yyTableElmtBits FOR yyTableElmt;
   yyStackType          = REF  ARRAY OF yyStateRangePacked;
   yyAttributeStackType = REF  ARRAY OF tParsAttribute;

VAR
   yyTBasePtr
     (* Subscripted by a state-number action, uses in combination
        with a terminal to find the new action after shifting
        the terminal in this state.
     *) 
     := ARRAY [0 .. yyLastReadState] OF yyTCombTypePtr
         {
           (*   0*) ADR (yyTComb [   0]) , (*   1*) ADR (yyTComb [   0])
         , (*   2*) ADR (yyTComb [   1]) , (*   3*) ADR (yyTComb [   0])
         , (*   4*) ADR (yyTComb [   0]) , (*   5*) ADR (yyTComb [   0])
         , (*   6*) ADR (yyTComb [   0]) , (*   7*) ADR (yyTComb [   0])
         , (*   8*) ADR (yyTComb [   1]) , (*   9*) ADR (yyTComb [   0])
         , (*  10*) ADR (yyTComb [   0]) , (*  11*) ADR (yyTComb [   0])
         , (*  12*) ADR (yyTComb [   0]) , (*  13*) ADR (yyTComb [   2])
         , (*  14*) ADR (yyTComb [   0]) , (*  15*) ADR (yyTComb [   1])
         , (*  16*) ADR (yyTComb [   3]) , (*  17*) ADR (yyTComb [   0])
         , (*  18*) ADR (yyTComb [   0]) , (*  19*) ADR (yyTComb [   0])
         , (*  20*) ADR (yyTComb [  11]) , (*  21*) ADR (yyTComb [  10])
         , (*  22*) ADR (yyTComb [   0]) , (*  23*) ADR (yyTComb [   0])
         , (*  24*) ADR (yyTComb [  17]) , (*  25*) ADR (yyTComb [   4])
         , (*  26*) ADR (yyTComb [   5]) , (*  27*) ADR (yyTComb [   5])
         , (*  28*) ADR (yyTComb [   2]) , (*  29*) ADR (yyTComb [   0])
         , (*  30*) ADR (yyTComb [  20]) , (*  31*) ADR (yyTComb [   0])
         , (*  32*) ADR (yyTComb [  11]) , (*  33*) ADR (yyTComb [   0])
         , (*  34*) ADR (yyTComb [  42]) , (*  35*) ADR (yyTComb [   0])
         , (*  36*) ADR (yyTComb [  31]) , (*  37*) ADR (yyTComb [  33])
         , (*  38*) ADR (yyTComb [   6]) , (*  39*) ADR (yyTComb [  44])
         , (*  40*) ADR (yyTComb [   8]) , (*  41*) ADR (yyTComb [  59])
         , (*  42*) ADR (yyTComb [  47]) , (*  43*) ADR (yyTComb [   9])
         , (*  44*) ADR (yyTComb [   0]) , (*  45*) ADR (yyTComb [  53])
         , (*  46*) ADR (yyTComb [  60]) , (*  47*) ADR (yyTComb [   0])
         , (*  48*) ADR (yyTComb [  63]) , (*  49*) ADR (yyTComb [   0])
         , (*  50*) ADR (yyTComb [  20]) , (*  51*) ADR (yyTComb [  25])
         , (*  52*) ADR (yyTComb [   0]) , (*  53*) ADR (yyTComb [  48])
         , (*  54*) ADR (yyTComb [ 122]) , (*  55*) ADR (yyTComb [  23])
         , (*  56*) ADR (yyTComb [  59]) , (*  57*) ADR (yyTComb [  72])
         , (*  58*) ADR (yyTComb [ 130]) , (*  59*) ADR (yyTComb [   0])
         , (*  60*) ADR (yyTComb [  40]) , (*  61*) ADR (yyTComb [  76])
         , (*  62*) ADR (yyTComb [ 134]) , (*  63*) ADR (yyTComb [   0])
         , (*  64*) ADR (yyTComb [   3]) , (*  65*) ADR (yyTComb [  71])
         , (*  66*) ADR (yyTComb [  51]) , (*  67*) ADR (yyTComb [   4])
         , (*  68*) ADR (yyTComb [ 130]) , (*  69*) ADR (yyTComb [   6])
         , (*  70*) ADR (yyTComb [  55]) , (*  71*) ADR (yyTComb [  83])
         , (*  72*) ADR (yyTComb [ 109]) , (*  73*) ADR (yyTComb [  87])
         , (*  74*) ADR (yyTComb [ 149]) , (*  75*) ADR (yyTComb [   0])
         , (*  76*) ADR (yyTComb [  89]) , (*  77*) ADR (yyTComb [ 152])
         , (*  78*) ADR (yyTComb [ 175]) , (*  79*) ADR (yyTComb [ 194])
         , (*  80*) ADR (yyTComb [  62]) , (*  81*) ADR (yyTComb [   1])
         , (*  82*) ADR (yyTComb [  64]) , (*  83*) ADR (yyTComb [  65])
         , (*  84*) ADR (yyTComb [  96]) , (*  85*) ADR (yyTComb [  69])
         , (*  86*) ADR (yyTComb [ 103]) , (*  87*) ADR (yyTComb [  75])
         , (*  88*) ADR (yyTComb [  77]) , (*  89*) ADR (yyTComb [ 106])
         , (*  90*) ADR (yyTComb [ 107]) , (*  91*) ADR (yyTComb [ 112])
         , (*  92*) ADR (yyTComb [   0]) , (*  93*) ADR (yyTComb [   0])
         , (*  94*) ADR (yyTComb [  85]) , (*  95*) ADR (yyTComb [ 114])
         , (*  96*) ADR (yyTComb [   0]) , (*  97*) ADR (yyTComb [   3])
         , (*  98*) ADR (yyTComb [  87]) , (*  99*) ADR (yyTComb [ 120])
         , (* 100*) ADR (yyTComb [ 117]) , (* 101*) ADR (yyTComb [ 203])
         , (* 102*) ADR (yyTComb [ 206]) , (* 103*) ADR (yyTComb [   7])
         , (* 104*) ADR (yyTComb [  95]) , (* 105*) ADR (yyTComb [ 131])
         , (* 106*) ADR (yyTComb [ 131]) , (* 107*) ADR (yyTComb [ 105])
         , (* 108*) ADR (yyTComb [   0]) , (* 109*) ADR (yyTComb [ 140])
         , (* 110*) ADR (yyTComb [ 156]) , (* 111*) ADR (yyTComb [   8])
         , (* 112*) ADR (yyTComb [ 106]) , (* 113*) ADR (yyTComb [ 140])
         , (* 114*) ADR (yyTComb [ 119]) , (* 115*) ADR (yyTComb [ 199])
         , (* 116*) ADR (yyTComb [ 163]) , (* 117*) ADR (yyTComb [ 150])
         , (* 118*) ADR (yyTComb [ 225]) , (* 119*) ADR (yyTComb [ 227])
         , (* 120*) ADR (yyTComb [ 124]) , (* 121*) ADR (yyTComb [ 161])
         , (* 122*) ADR (yyTComb [ 167]) , (* 123*) ADR (yyTComb [ 145])
         , (* 124*) ADR (yyTComb [ 173]) , (* 125*) ADR (yyTComb [  15])
         , (* 126*) ADR (yyTComb [ 148]) , (* 127*) ADR (yyTComb [ 177])
         , (* 128*) ADR (yyTComb [ 150]) , (* 129*) ADR (yyTComb [ 182])
         };
         
   yyNBasePtr
     (* Subscripted by a state-number action, used in combination
        with a nonterminal to find the new action after shifting
        the nonterminal in this state.
     *) 
     := ARRAY [0 .. yyLastReadState] OF yyNCombTypePtr
         {
           (*   0*) ADR (yyNComb [ 109]) , (*   1*) ADR (yyNComb [ 109])
         , (*   2*) ADR (yyNComb [ 109]) , (*   3*) ADR (yyNComb [ 109])
         , (*   4*) ADR (yyNComb [ 109]) , (*   5*) ADR (yyNComb [ 109])
         , (*   6*) ADR (yyNComb [ 109]) , (*   7*) ADR (yyNComb [ 109])
         , (*   8*) ADR (yyNComb [ 109]) , (*   9*) ADR (yyNComb [ 109])
         , (*  10*) ADR (yyNComb [ 109]) , (*  11*) ADR (yyNComb [ 109])
         , (*  12*) ADR (yyNComb [ 109]) , (*  13*) ADR (yyNComb [ 109])
         , (*  14*) ADR (yyNComb [ 109]) , (*  15*) ADR (yyNComb [ 109])
         , (*  16*) ADR (yyNComb [ 109]) , (*  17*) ADR (yyNComb [ 109])
         , (*  18*) ADR (yyNComb [ 109]) , (*  19*) ADR (yyNComb [ 109])
         , (*  20*) ADR (yyNComb [ 109]) , (*  21*) ADR (yyNComb [ 109])
         , (*  22*) ADR (yyNComb [ 116]) , (*  23*) ADR (yyNComb [ 120])
         , (*  24*) ADR (yyNComb [ 109]) , (*  25*) ADR (yyNComb [ 109])
         , (*  26*) ADR (yyNComb [ 109]) , (*  27*) ADR (yyNComb [ 109])
         , (*  28*) ADR (yyNComb [ 109]) , (*  29*) ADR (yyNComb [ 109])
         , (*  30*) ADR (yyNComb [ 109]) , (*  31*) ADR (yyNComb [ 122])
         , (*  32*) ADR (yyNComb [ 119]) , (*  33*) ADR (yyNComb [ 109])
         , (*  34*) ADR (yyNComb [ 115]) , (*  35*) ADR (yyNComb [ 109])
         , (*  36*) ADR (yyNComb [ 109]) , (*  37*) ADR (yyNComb [ 109])
         , (*  38*) ADR (yyNComb [ 109]) , (*  39*) ADR (yyNComb [ 109])
         , (*  40*) ADR (yyNComb [ 109]) , (*  41*) ADR (yyNComb [ 121])
         , (*  42*) ADR (yyNComb [ 110]) , (*  43*) ADR (yyNComb [ 116])
         , (*  44*) ADR (yyNComb [ 110]) , (*  45*) ADR (yyNComb [ 114])
         , (*  46*) ADR (yyNComb [ 111]) , (*  47*) ADR (yyNComb [ 144])
         , (*  48*) ADR (yyNComb [ 121]) , (*  49*) ADR (yyNComb [ 141])
         , (*  50*) ADR (yyNComb [ 109]) , (*  51*) ADR (yyNComb [ 109])
         , (*  52*) ADR (yyNComb [ 142]) , (*  53*) ADR (yyNComb [ 109])
         , (*  54*) ADR (yyNComb [ 145]) , (*  55*) ADR (yyNComb [ 109])
         , (*  56*) ADR (yyNComb [ 134]) , (*  57*) ADR (yyNComb [ 126])
         , (*  58*) ADR (yyNComb [ 125]) , (*  59*) ADR (yyNComb [ 127])
         , (*  60*) ADR (yyNComb [ 109]) , (*  61*) ADR (yyNComb [ 109])
         , (*  62*) ADR (yyNComb [ 124]) , (*  63*) ADR (yyNComb [ 109])
         , (*  64*) ADR (yyNComb [ 151]) , (*  65*) ADR (yyNComb [ 109])
         , (*  66*) ADR (yyNComb [ 152]) , (*  67*) ADR (yyNComb [ 109])
         , (*  68*) ADR (yyNComb [ 119]) , (*  69*) ADR (yyNComb [ 154])
         , (*  70*) ADR (yyNComb [ 163]) , (*  71*) ADR (yyNComb [ 109])
         , (*  72*) ADR (yyNComb [ 161]) , (*  73*) ADR (yyNComb [ 109])
         , (*  74*) ADR (yyNComb [ 109]) , (*  75*) ADR (yyNComb [ 182])
         , (*  76*) ADR (yyNComb [ 109]) , (*  77*) ADR (yyNComb [ 109])
         , (*  78*) ADR (yyNComb [ 112]) , (*  79*) ADR (yyNComb [ 171])
         , (*  80*) ADR (yyNComb [ 109]) , (*  81*) ADR (yyNComb [ 109])
         , (*  82*) ADR (yyNComb [ 109]) , (*  83*) ADR (yyNComb [ 110])
         , (*  84*) ADR (yyNComb [ 109]) , (*  85*) ADR (yyNComb [ 109])
         , (*  86*) ADR (yyNComb [ 109]) , (*  87*) ADR (yyNComb [ 109])
         , (*  88*) ADR (yyNComb [ 109]) , (*  89*) ADR (yyNComb [ 109])
         , (*  90*) ADR (yyNComb [ 110]) , (*  91*) ADR (yyNComb [ 109])
         , (*  92*) ADR (yyNComb [ 189]) , (*  93*) ADR (yyNComb [ 189])
         , (*  94*) ADR (yyNComb [ 109]) , (*  95*) ADR (yyNComb [ 109])
         , (*  96*) ADR (yyNComb [ 109]) , (*  97*) ADR (yyNComb [ 109])
         , (*  98*) ADR (yyNComb [ 109]) , (*  99*) ADR (yyNComb [ 109])
         , (* 100*) ADR (yyNComb [ 109]) , (* 101*) ADR (yyNComb [ 196])
         , (* 102*) ADR (yyNComb [ 192]) , (* 103*) ADR (yyNComb [ 109])
         , (* 104*) ADR (yyNComb [ 109]) , (* 105*) ADR (yyNComb [ 109])
         , (* 106*) ADR (yyNComb [ 109]) , (* 107*) ADR (yyNComb [ 109])
         , (* 108*) ADR (yyNComb [ 110]) , (* 109*) ADR (yyNComb [ 183])
         , (* 110*) ADR (yyNComb [ 109]) , (* 111*) ADR (yyNComb [ 109])
         , (* 112*) ADR (yyNComb [ 109]) , (* 113*) ADR (yyNComb [ 109])
         , (* 114*) ADR (yyNComb [ 109]) , (* 115*) ADR (yyNComb [ 196])
         , (* 116*) ADR (yyNComb [ 109]) , (* 117*) ADR (yyNComb [ 109])
         , (* 118*) ADR (yyNComb [ 200]) , (* 119*) ADR (yyNComb [ 192])
         , (* 120*) ADR (yyNComb [ 109]) , (* 121*) ADR (yyNComb [ 109])
         , (* 122*) ADR (yyNComb [ 109]) , (* 123*) ADR (yyNComb [ 109])
         , (* 124*) ADR (yyNComb [ 192]) , (* 125*) ADR (yyNComb [ 109])
         , (* 126*) ADR (yyNComb [ 109]) , (* 127*) ADR (yyNComb [ 109])
         , (* 128*) ADR (yyNComb [ 192]) , (* 129*) ADR (yyNComb [ 109])
         };
         
   yyDefault
     := ARRAY [0 .. yyLastReadState] OF [ 0 .. yyLastReadState ]
         {
           (*   0*)    0 , (*   1*)    0 , (*   2*)    0 , (*   3*)    0
         , (*   4*)    0 , (*   5*)   90 , (*   6*)  109 , (*   7*)  110
         , (*   8*)    0 , (*   9*)    0 , (*  10*)  101 , (*  11*)  102
         , (*  12*)    0 , (*  13*)    0 , (*  14*)    0 , (*  15*)    0
         , (*  16*)    0 , (*  17*)    0 , (*  18*)   72 , (*  19*)   56
         , (*  20*)    0 , (*  21*)    0 , (*  22*)   72 , (*  23*)  128
         , (*  24*)    0 , (*  25*)    0 , (*  26*)   68 , (*  27*)    0
         , (*  28*)    0 , (*  29*)  128 , (*  30*)    0 , (*  31*)   72
         , (*  32*)    0 , (*  33*)   66 , (*  34*)    0 , (*  35*)    0
         , (*  36*)    0 , (*  37*)    0 , (*  38*)    0 , (*  39*)    0
         , (*  40*)    0 , (*  41*)    0 , (*  42*)    0 , (*  43*)   41
         , (*  44*)  128 , (*  45*)    0 , (*  46*)    0 , (*  47*)   72
         , (*  48*)    0 , (*  49*)   66 , (*  50*)    0 , (*  51*)    0
         , (*  52*)   66 , (*  53*)    0 , (*  54*)   16 , (*  55*)    0
         , (*  56*)    0 , (*  57*)    0 , (*  58*)    0 , (*  59*)  119
         , (*  60*)    0 , (*  61*)    0 , (*  62*)    0 , (*  63*)    0
         , (*  64*)   66 , (*  65*)    0 , (*  66*)    0 , (*  67*)    0
         , (*  68*)    0 , (*  69*)   66 , (*  70*)    0 , (*  71*)    0
         , (*  72*)    0 , (*  73*)    0 , (*  74*)   70 , (*  75*)  128
         , (*  76*)    0 , (*  77*)   27 , (*  78*)    0 , (*  79*)    0
         , (*  80*)    0 , (*  81*)    0 , (*  82*)    0 , (*  83*)    0
         , (*  84*)    0 , (*  85*)    0 , (*  86*)    0 , (*  87*)    0
         , (*  88*)    0 , (*  89*)    0 , (*  90*)    0 , (*  91*)    0
         , (*  92*)  118 , (*  93*)  119 , (*  94*)    0 , (*  95*)    0
         , (*  96*)    0 , (*  97*)    0 , (*  98*)    0 , (*  99*)    0
         , (* 100*)    0 , (* 101*)    0 , (* 102*)    0 , (* 103*)    0
         , (* 104*)    0 , (* 105*)    0 , (* 106*)    0 , (* 107*)    0
         , (* 108*)  124 , (* 109*)    0 , (* 110*)    0 , (* 111*)    0
         , (* 112*)    0 , (* 113*)    0 , (* 114*)    0 , (* 115*)    0
         , (* 116*)    0 , (* 117*)    0 , (* 118*)    0 , (* 119*)    0
         , (* 120*)    0 , (* 121*)    0 , (* 122*)    0 , (* 123*)    0
         , (* 124*)    0 , (* 125*)    0 , (* 126*)    0 , (* 127*)    0
         , (* 128*)    0 , (* 129*)    0
         };
         
   yyTComb
     := ARRAY yyTCombRangePacked OF yyTCombType
         {
           (*   0*) yyTCombType {  96,  206} , (*   1*) yyTCombType {   0,    0}
         , (*   2*) yyTCombType {   0,    0} , (*   3*) yyTCombType {   0,    0}
         , (*   4*) yyTCombType {   0,    0} , (*   5*) yyTCombType {   0,    0}
         , (*   6*) yyTCombType {  35,  141} , (*   7*) yyTCombType {   0,    0}
         , (*   8*) yyTCombType {   0,    0} , (*   9*) yyTCombType {  63,   64}
         , (*  10*) yyTCombType {  15,  310} , (*  11*) yyTCombType {   0,    0}
         , (*  12*) yyTCombType {   0,    0} , (*  13*) yyTCombType {   0,    0}
         , (*  14*) yyTCombType {   0,    0} , (*  15*) yyTCombType {  15,   16}
         , (*  16*) yyTCombType {   0,    0} , (*  17*) yyTCombType {   0,    0}
         , (*  18*) yyTCombType {   0,    0} , (*  19*) yyTCombType {  12,   13}
         , (*  20*) yyTCombType {  15,  310} , (*  21*) yyTCombType {  28,  138}
         , (*  22*) yyTCombType {  64,  320} , (*  23*) yyTCombType {  67,  151}
         , (*  24*) yyTCombType {  27,  228} , (*  25*) yyTCombType {  69,  228}
         , (*  26*) yyTCombType { 103,  104} , (*  27*) yyTCombType { 111,  112}
         , (*  28*) yyTCombType {   1,    2} , (*  29*) yyTCombType {  21,  298}
         , (*  30*) yyTCombType {  32,  277} , (*  31*) yyTCombType {  81,   82}
         , (*  32*) yyTCombType {   1,  226} , (*  33*) yyTCombType {   2,    3}
         , (*  34*) yyTCombType { 125,  126} , (*  35*) yyTCombType {  97,   98}
         , (*  36*) yyTCombType {  24,  273} , (*  37*) yyTCombType {   1,  226}
         , (*  38*) yyTCombType {   2,   88} , (*  39*) yyTCombType {  30,  275}
         , (*  40*) yyTCombType {  97,  114} , (*  41*) yyTCombType {   0,    0}
         , (*  42*) yyTCombType {   0,    0} , (*  43*) yyTCombType {   0,    0}
         , (*  44*) yyTCombType {  15,   55} , (*  45*) yyTCombType {   0,    0}
         , (*  46*) yyTCombType {   0,    0} , (*  47*) yyTCombType {   0,    0}
         , (*  48*) yyTCombType {   0,    0} , (*  49*) yyTCombType {   0,    0}
         , (*  50*) yyTCombType {   0,    0} , (*  51*) yyTCombType {   0,    0}
         , (*  52*) yyTCombType {   0,    0} , (*  53*) yyTCombType {   0,    0}
         , (*  54*) yyTCombType {   0,    0} , (*  55*) yyTCombType {  21,  298}
         , (*  56*) yyTCombType {   0,    0} , (*  57*) yyTCombType {  20,  285}
         , (*  58*) yyTCombType {  15,   70} , (*  59*) yyTCombType {   1,  161}
         , (*  60*) yyTCombType {   0,    0} , (*  61*) yyTCombType {  34,  301}
         , (*  62*) yyTCombType {   0,    0} , (*  63*) yyTCombType {   0,    0}
         , (*  64*) yyTCombType {  15,  153} , (*  65*) yyTCombType {   0,    0}
         , (*  66*) yyTCombType {   9,   10} , (*  67*) yyTCombType {  14,  132}
         , (*  68*) yyTCombType {  17,  266} , (*  69*) yyTCombType {   4,  215}
         , (*  70*) yyTCombType {   7,  130} , (*  71*) yyTCombType {  26,   27}
         , (*  72*) yyTCombType {  17,   18} , (*  73*) yyTCombType {  20,  285}
         , (*  74*) yyTCombType {  20,  285} , (*  75*) yyTCombType {  35,   36}
         , (*  76*) yyTCombType {  21,  298} , (*  77*) yyTCombType {  32,  277}
         , (*  78*) yyTCombType {  21,  298} , (*  79*) yyTCombType {  43,  228}
         , (*  80*) yyTCombType {  21,  298} , (*  81*) yyTCombType {  20,  133}
         , (*  82*) yyTCombType {  21,   22} , (*  83*) yyTCombType {  24,  273}
         , (*  84*) yyTCombType {  21,  298} , (*  85*) yyTCombType {  32,   33}
         , (*  86*) yyTCombType {  30,  275} , (*  87*) yyTCombType {  34,   35}
         , (*  88*) yyTCombType {  24,   25} , (*  89*) yyTCombType {  24,  273}
         , (*  90*) yyTCombType {  50,  147} , (*  91*) yyTCombType {  24,  273}
         , (*  92*) yyTCombType {  30,   31} , (*  93*) yyTCombType {  51,   52}
         , (*  94*) yyTCombType {  30,  275} , (*  95*) yyTCombType {   3,    4}
         , (*  96*) yyTCombType {   8,  131} , (*  97*) yyTCombType {  13,   14}
         , (*  98*) yyTCombType {  16,   17} , (*  99*) yyTCombType {  25,  137}
         , (* 100*) yyTCombType {  27,  270} , (* 101*) yyTCombType {  38,   39}
         , (* 102*) yyTCombType {  36,  238} , (* 103*) yyTCombType {  40,  142}
         , (* 104*) yyTCombType {  37,   38} , (* 105*) yyTCombType {  41,  144}
         , (* 106*) yyTCombType {  20,  285} , (* 107*) yyTCombType {  36,  238}
         , (* 108*) yyTCombType {  34,  301} , (* 109*) yyTCombType {  37,  143}
         , (* 110*) yyTCombType {  34,  301} , (* 111*) yyTCombType {  39,   40}
         , (* 112*) yyTCombType {  34,  301} , (* 113*) yyTCombType {  42,   43}
         , (* 114*) yyTCombType {  53,  148} , (* 115*) yyTCombType {  39,  239}
         , (* 116*) yyTCombType {  34,  301} , (* 117*) yyTCombType {  42,  229}
         , (* 118*) yyTCombType {  55,   56} , (* 119*) yyTCombType {  45,  234}
         , (* 120*) yyTCombType {  39,  239} , (* 121*) yyTCombType {  41,  145}
         , (* 122*) yyTCombType {  41,  146} , (* 123*) yyTCombType {  45,  234}
         , (* 124*) yyTCombType {  45,   25} , (* 125*) yyTCombType {  45,  234}
         , (* 126*) yyTCombType {  46,  294} , (* 127*) yyTCombType {  45,  234}
         , (* 128*) yyTCombType {  56,   20} , (* 129*) yyTCombType {  48,  296}
         , (* 130*) yyTCombType {  46,  294} , (* 131*) yyTCombType {  54,  261}
         , (* 132*) yyTCombType {  46,   47} , (* 133*) yyTCombType {  48,  296}
         , (* 134*) yyTCombType {  46,  294} , (* 135*) yyTCombType {  60,   61}
         , (* 136*) yyTCombType {  54,  261} , (* 137*) yyTCombType {  48,   49}
         , (* 138*) yyTCombType {  57,  149} , (* 139*) yyTCombType {  58,  305}
         , (* 140*) yyTCombType {  57,   58} , (* 141*) yyTCombType {  54,  261}
         , (* 142*) yyTCombType {  61,  150} , (* 143*) yyTCombType {  62,  312}
         , (* 144*) yyTCombType {  58,  305} , (* 145*) yyTCombType {  65,   66}
         , (* 146*) yyTCombType {  66,  139} , (* 147*) yyTCombType {  66,  140}
         , (* 148*) yyTCombType {  62,  312} , (* 149*) yyTCombType {  68,  229}
         , (* 150*) yyTCombType {  70,   71} , (* 151*) yyTCombType {  71,   72}
         , (* 152*) yyTCombType {  72,   19} , (* 153*) yyTCombType {  73,  152}
         , (* 154*) yyTCombType {  41,  288} , (* 155*) yyTCombType {  76,   77}
         , (* 156*) yyTCombType {  72,  134} , (* 157*) yyTCombType {  80,   81}
         , (* 158*) yyTCombType {  74,  257} , (* 159*) yyTCombType {  82,  154}
         , (* 160*) yyTCombType {  83,  155} , (* 161*) yyTCombType {  77,  268}
         , (* 162*) yyTCombType {  84,  156} , (* 163*) yyTCombType {  74,  257}
         , (* 164*) yyTCombType {  85,  157} , (* 165*) yyTCombType {  54,  261}
         , (* 166*) yyTCombType {  77,  268} , (* 167*) yyTCombType {  84,   85}
         , (* 168*) yyTCombType {  74,  257} , (* 169*) yyTCombType {  86,  158}
         , (* 170*) yyTCombType {  87,  159} , (* 171*) yyTCombType {  77,  268}
         , (* 172*) yyTCombType {  88,   89} , (* 173*) yyTCombType {  58,  305}
         , (* 174*) yyTCombType {  86,   87} , (* 175*) yyTCombType {  89,  216}
         , (* 176*) yyTCombType {  90,    6} , (* 177*) yyTCombType {  62,  312}
         , (* 178*) yyTCombType {  91,   92} , (* 179*) yyTCombType {  54,  261}
         , (* 180*) yyTCombType {  94,   95} , (* 181*) yyTCombType {  95,  160}
         , (* 182*) yyTCombType {  98,   99} , (* 183*) yyTCombType { 100,  101}
         , (* 184*) yyTCombType {  78,  245} , (* 185*) yyTCombType {  54,  261}
         , (* 186*) yyTCombType {  99,  213} , (* 187*) yyTCombType {  58,  305}
         , (* 188*) yyTCombType {  99,  217} , (* 189*) yyTCombType {  78,  245}
         , (* 190*) yyTCombType { 104,  105} , (* 191*) yyTCombType {  62,  312}
         , (* 192*) yyTCombType {  74,  257} , (* 193*) yyTCombType {  58,  305}
         , (* 194*) yyTCombType {  78,  245} , (* 195*) yyTCombType {  77,  268}
         , (* 196*) yyTCombType {  68,   69} , (* 197*) yyTCombType {  62,  312}
         , (* 198*) yyTCombType { 105,  162} , (* 199*) yyTCombType { 106,  107}
         , (* 200*) yyTCombType { 107,  108} , (* 201*) yyTCombType { 112,  113}
         , (* 202*) yyTCombType {  78,  245} , (* 203*) yyTCombType {  79,  243}
         , (* 204*) yyTCombType {  72,  135} , (* 205*) yyTCombType {  78,  245}
         , (* 206*) yyTCombType {  74,  257} , (* 207*) yyTCombType { 113,  164}
         , (* 208*) yyTCombType {  79,  243} , (* 209*) yyTCombType {  77,  268}
         , (* 210*) yyTCombType { 109,  236} , (* 211*) yyTCombType { 109,  236}
         , (* 212*) yyTCombType {  74,  257} , (* 213*) yyTCombType {  79,  243}
         , (* 214*) yyTCombType { 114,  115} , (* 215*) yyTCombType {  77,  268}
         , (* 216*) yyTCombType { 117,  118} , (* 217*) yyTCombType { 101,  242}
         , (* 218*) yyTCombType {  78,  245} , (* 219*) yyTCombType { 120,  121}
         , (* 220*) yyTCombType { 102,  312} , (* 221*) yyTCombType {  79,   80}
         , (* 222*) yyTCombType { 101,  242} , (* 223*) yyTCombType { 115,  165}
         , (* 224*) yyTCombType {  79,   83} , (* 225*) yyTCombType { 102,  312}
         , (* 226*) yyTCombType { 110,  163} , (* 227*) yyTCombType { 110,    8}
         , (* 228*) yyTCombType { 121,  166} , (* 229*) yyTCombType { 116,  214}
         , (* 230*) yyTCombType { 101,  242} , (* 231*) yyTCombType { 116,  218}
         , (* 232*) yyTCombType {  78,  245} , (* 233*) yyTCombType { 101,  242}
         , (* 234*) yyTCombType { 118,  242} , (* 235*) yyTCombType { 122,  123}
         , (* 236*) yyTCombType { 119,  309} , (* 237*) yyTCombType {  79,  243}
         , (* 238*) yyTCombType {  78,  245} , (* 239*) yyTCombType { 118,  242}
         , (* 240*) yyTCombType { 123,  124} , (* 241*) yyTCombType { 119,  309}
         , (* 242*) yyTCombType { 124,  109} , (* 243*) yyTCombType { 126,  127}
         , (* 244*) yyTCombType { 127,  167} , (* 245*) yyTCombType { 128,  136}
         , (* 246*) yyTCombType { 101,  242} , (* 247*) yyTCombType {   0,    0}
         , (* 248*) yyTCombType { 129,  253} , (* 249*) yyTCombType { 102,  312}
         , (* 250*) yyTCombType { 129,  253} , (* 251*) yyTCombType {  79,  243}
         , (* 252*) yyTCombType { 118,  242} , (* 253*) yyTCombType { 129,   25}
         , (* 254*) yyTCombType {   0,    0} , (* 255*) yyTCombType { 118,  242}
         , (* 256*) yyTCombType {   0,    0} , (* 257*) yyTCombType {  79,  243}
         , (* 258*) yyTCombType {   0,    0} , (* 259*) yyTCombType {   0,    0}
         , (* 260*) yyTCombType { 101,  242} , (* 261*) yyTCombType {   0,    0}
         , (* 262*) yyTCombType {   0,    0} , (* 263*) yyTCombType { 102,  312}
         , (* 264*) yyTCombType {   0,    0} , (* 265*) yyTCombType { 115,  254}
         , (* 266*) yyTCombType { 101,  242} , (* 267*) yyTCombType { 115,  254}
         , (* 268*) yyTCombType { 118,  242} , (* 269*) yyTCombType { 102,  312}
         , (* 270*) yyTCombType { 119,  309} , (* 271*) yyTCombType {   0,    0}
         , (* 272*) yyTCombType {   0,    0} , (* 273*) yyTCombType {   0,    0}
         , (* 274*) yyTCombType {   0,    0} , (* 275*) yyTCombType {   0,    0}
         , (* 276*) yyTCombType {   0,    0} , (* 277*) yyTCombType {   0,    0}
         , (* 278*) yyTCombType {   0,    0} , (* 279*) yyTCombType {   0,    0}
         , (* 280*) yyTCombType {   0,    0} , (* 281*) yyTCombType {   0,    0}
         , (* 282*) yyTCombType { 118,  242} , (* 283*) yyTCombType {   0,    0}
         , (* 284*) yyTCombType { 119,  309} , (* 285*) yyTCombType {   0,    0}
         , (* 286*) yyTCombType {   0,    0} , (* 287*) yyTCombType {   0,    0}
         , (* 288*) yyTCombType { 118,  242} , (* 289*) yyTCombType {   0,    0}
         , (* 290*) yyTCombType { 119,  309} , (* 291*) yyTCombType {   0,    0}
         , (* 292*) yyTCombType {   0,    0} , (* 293*) yyTCombType {   0,    0}
         , (* 294*) yyTCombType {   0,    0} , (* 295*) yyTCombType {   0,    0}
         , (* 296*) yyTCombType {   0,    0} , (* 297*) yyTCombType {   0,    0}
         , (* 298*) yyTCombType {   0,    0} , (* 299*) yyTCombType {   0,    0}
         , (* 300*) yyTCombType {   0,    0} , (* 301*) yyTCombType {   0,    0}
         , (* 302*) yyTCombType {   0,    0} , (* 303*) yyTCombType {   0,    0}
         , (* 304*) yyTCombType {   0,    0} , (* 305*) yyTCombType {   0,    0}
         , (* 306*) yyTCombType {   0,    0} , (* 307*) yyTCombType {   0,    0}
         , (* 308*) yyTCombType {   0,    0} , (* 309*) yyTCombType {   0,    0}
         , (* 310*) yyTCombType {   0,    0} , (* 311*) yyTCombType {   0,    0}
         , (* 312*) yyTCombType {   0,    0} , (* 313*) yyTCombType {   0,    0}
         , (* 314*) yyTCombType {   0,    0} , (* 315*) yyTCombType {   0,    0}
         , (* 316*) yyTCombType {   0,    0} , (* 317*) yyTCombType {   0,    0}
         , (* 318*) yyTCombType {   0,    0} , (* 319*) yyTCombType {   0,    0}
         , (* 320*) yyTCombType {   0,    0} , (* 321*) yyTCombType {   0,    0}
         , (* 322*) yyTCombType {   0,    0} , (* 323*) yyTCombType {   0,    0}
         , (* 324*) yyTCombType {   0,    0} , (* 325*) yyTCombType {   0,    0}
         , (* 326*) yyTCombType {   0,    0} , (* 327*) yyTCombType {   0,    0}
         , (* 328*) yyTCombType {   0,    0} , (* 329*) yyTCombType {   0,    0}
         , (* 330*) yyTCombType {   0,    0} , (* 331*) yyTCombType {   0,    0}
         , (* 332*) yyTCombType {   0,    0} , (* 333*) yyTCombType {   0,    0}
         , (* 334*) yyTCombType {   0,    0} , (* 335*) yyTCombType {   0,    0}
         };
         
   yyNComb 
     (* This bounds range is arbitrary, unjustified, and confusing.
        It has nothing to do with states, actions, symbols, or anything
        else.  It is just a space for interspersed actions.  Moreover,
        during use, its elements are accessed only by unsafe pointers to
        to them, from elements of yyNBasePtr, not by subscripts, for a bit
        of speed.  It would make the most sense to start it at zero, like
        yyTComb.  But that would require care to make consistent changes.
     *) 
     := ARRAY yyNCombRangePacked OF yyNCombType
         {
           (* 109*)  200 , (* 110*)   96 , (* 111*)  201 , (* 112*)  202
         , (* 113*)  203 , (* 114*)  204 , (* 115*)  205 , (* 116*)  100
         , (* 117*)  117 , (* 118*)    5 , (* 119*)   90 , (* 120*)  106
         , (* 121*)  122 , (* 122*)   97 , (* 123*)   11 , (* 124*)   12
         , (* 125*)    0 , (* 126*)    0 , (* 127*)    9 , (* 128*)   91
         , (* 129*)  111 , (* 130*)   28 , (* 131*)   50 , (* 132*)   24
         , (* 133*)   45 , (* 134*)    7 , (* 135*)   37 , (* 136*)  175
         , (* 137*)   78 , (* 138*)   46 , (* 139*)   63 , (* 140*)  188
         , (* 141*)   79 , (* 142*)   84 , (* 143*)   24 , (* 144*)   60
         , (* 145*)  193 , (* 146*)  191 , (* 147*)  182 , (* 148*)   54
         , (* 149*)  194 , (* 150*)  184 , (* 151*)   51 , (* 152*)  172
         , (* 153*)   75 , (* 154*)  169 , (* 155*)  195 , (* 156*)  170
         , (* 157*)   29 , (* 158*)   30 , (* 159*)   32 , (* 160*)  171
         , (* 161*)   23 , (* 162*)  168 , (* 163*)   21 , (* 164*)   34
         , (* 165*)   26 , (* 166*)   41 , (* 167*)  174 , (* 168*)   23
         , (* 169*)   30 , (* 170*)  173 , (* 171*)  176 , (* 172*)   48
         , (* 173*)  196 , (* 174*)   23 , (* 175*)  177 , (* 176*)   44
         , (* 177*)   15 , (* 178*)  197 , (* 179*)   42 , (* 180*)  181
         , (* 181*)   44 , (* 182*)  178 , (* 183*)  180 , (* 184*)  179
         , (* 185*)   53 , (* 186*)  183 , (* 187*)   57 , (* 188*)   21
         , (* 189*)  190 , (* 190*)   59 , (* 191*)   41 , (* 192*)   15
         , (* 193*)   62 , (* 194*)   65 , (* 195*)  185 , (* 196*)   23
         , (* 197*)   65 , (* 198*)   74 , (* 199*)   73 , (* 200*)  192
         , (* 201*)  198 , (* 202*)  199 , (* 203*)   93 , (* 204*)   86
         , (* 205*)   24 , (* 206*)   94 , (* 207*)  103 , (* 208*)  110
         , (* 209*)  120 , (* 210*)  102 , (* 211*)  125 , (* 212*)  116
         , (* 213*)   23 , (* 214*)  119 , (* 215*)  129 , (* 216*)    0
         , (* 217*)   78 , (* 218*)   67 , (* 219*)    0 , (* 220*)    0
         , (* 221*)   68 , (* 222*)  189 , (* 223*)  187 , (* 224*)   78
         , (* 225*)  186 , (* 226*)  187 , (* 227*)   76 , (* 228*)   78
         , (* 229*)  174 , (* 230*)  128 , (* 231*)   30 , (* 232*)    0
         , (* 233*)    0 , (* 234*)    0 , (* 235*)    0 , (* 236*)    0
         , (* 237*)    0 , (* 238*)    0 , (* 239*)    0 , (* 240*)    0
         , (* 241*)    0 , (* 242*)    0 , (* 243*)    0 , (* 244*)    0
         , (* 245*)    0 , (* 246*)    0 , (* 247*)    0 , (* 248*)    0
         , (* 249*)    0 , (* 250*)    0 , (* 251*)    0 , (* 252*)    0
         , (* 253*)    0 , (* 254*)    0 , (* 255*)   62 , (* 256*)    0
         , (* 257*)    0 , (* 258*)   62 , (* 259*)    0 , (* 260*)   15
         , (* 261*)    0 , (* 262*)    0 , (* 263*)    0 , (* 264*)    0
         , (* 265*)    0 , (* 266*)    0 , (* 267*)    0 , (* 268*)    0
         , (* 269*)    0 , (* 270*)    0 , (* 271*)    0 , (* 272*)    0
         , (* 273*)    0
         };
         
   yyLength
     (* Subscripted by a reduce action, maps to LHS length of the
        production to reduce by. A<a> is a reduce action number.
        P<p> is the correponding production number.
     *)
     := ARRAY yyReduceRangePacked OF yyTableElmt
         {
           (*A 206(P   1)*)    2 , (*A 207(P   2)*)    1 , (*A 208(P   3)*)    1
         , (*A 209(P   4)*)    1 , (*A 210(P   5)*)    1 , (*A 211(P   6)*)    1
         , (*A 212(P   7)*)    1 , (*A 213(P   8)*)    0 , (*A 214(P   9)*)    0
         , (*A 215(P  10)*)    0 , (*A 216(P  11)*)    0 , (*A 217(P  12)*)    0
         , (*A 218(P  13)*)    0 , (*A 219(P  14)*)   10 , (*A 220(P  15)*)   10
         , (*A 221(P  16)*)   11 , (*A 222(P  17)*)   10 , (*A 223(P  18)*)   10
         , (*A 224(P  19)*)   11 , (*A 225(P  20)*)    1 , (*A 226(P  21)*)    0
         , (*A 227(P  22)*)    0 , (*A 228(P  23)*)    1 , (*A 229(P  24)*)    0
         , (*A 230(P  25)*)    1 , (*A 231(P  26)*)    3 , (*A 232(P  27)*)    1
         , (*A 233(P  28)*)    3 , (*A 234(P  29)*)    0 , (*A 235(P  30)*)    3
         , (*A 236(P  31)*)    0 , (*A 237(P  32)*)    3 , (*A 238(P  33)*)    0
         , (*A 239(P  34)*)    1 , (*A 240(P  35)*)    3 , (*A 241(P  36)*)    3
         , (*A 242(P  37)*)    0 , (*A 243(P  38)*)    0 , (*A 244(P  39)*)    2
         , (*A 245(P  40)*)    0 , (*A 246(P  41)*)    3 , (*A 247(P  42)*)    1
         , (*A 248(P  43)*)    3 , (*A 249(P  44)*)    2 , (*A 250(P  45)*)    4
         , (*A 251(P  46)*)    3 , (*A 252(P  47)*)    1 , (*A 253(P  48)*)    2
         , (*A 254(P  49)*)    0 , (*A 255(P  50)*)    3 , (*A 256(P  51)*)    3
         , (*A 257(P  52)*)    2 , (*A 258(P  53)*)    1 , (*A 259(P  54)*)    2
         , (*A 260(P  55)*)    4 , (*A 261(P  56)*)    2 , (*A 262(P  57)*)    1
         , (*A 263(P  58)*)    2 , (*A 264(P  59)*)    5 , (*A 265(P  60)*)    2
         , (*A 266(P  61)*)    0 , (*A 267(P  62)*)    1 , (*A 268(P  63)*)    3
         , (*A 269(P  64)*)    1 , (*A 270(P  65)*)    1 , (*A 271(P  66)*)    3
         , (*A 272(P  67)*)    3 , (*A 273(P  68)*)    1 , (*A 274(P  69)*)    2
         , (*A 275(P  70)*)    0 , (*A 276(P  71)*)    2 , (*A 277(P  72)*)    0
         , (*A 278(P  73)*)    1 , (*A 279(P  74)*)    1 , (*A 280(P  75)*)    4
         , (*A 281(P  76)*)    2 , (*A 282(P  77)*)    3 , (*A 283(P  78)*)    2
         , (*A 284(P  79)*)    4 , (*A 285(P  80)*)    1 , (*A 286(P  81)*)    3
         , (*A 287(P  82)*)    1 , (*A 288(P  83)*)    0 , (*A 289(P  84)*)    1
         , (*A 290(P  85)*)    1 , (*A 291(P  86)*)    1 , (*A 292(P  87)*)    5
         , (*A 293(P  88)*)    2 , (*A 294(P  89)*)    0 , (*A 295(P  90)*)    2
         , (*A 296(P  91)*)    0 , (*A 297(P  92)*)    2 , (*A 298(P  93)*)    0
         , (*A 299(P  94)*)    2 , (*A 300(P  95)*)    4 , (*A 301(P  96)*)    0
         , (*A 302(P  97)*)    4 , (*A 303(P  98)*)    1 , (*A 304(P  99)*)    5
         , (*A 305(P 100)*)    0 , (*A 306(P 101)*)    1 , (*A 307(P 102)*)    1
         , (*A 308(P 103)*)    5 , (*A 309(P 104)*)    0 , (*A 310(P 105)*)    1
         , (*A 311(P 106)*)    2 , (*A 312(P 107)*)    0 , (*A 313(P 108)*)    1
         , (*A 314(P 109)*)    1 , (*A 315(P 110)*)    1 , (*A 316(P 111)*)    1
         , (*A 317(P 112)*)    2 , (*A 318(P 113)*)    1 , (*A 319(P 114)*)    3
         , (*A 320(P 115)*)    0 , (*A 321(P 116)*)    1 , (*A 322(P 117)*)    3
         };
         
   yyLeftHandSide
     (* Subscripted by a reduce action, maps to LHS NT of the
        of production to reduce by.  A<a> is a reduce action number.
        P<p> is the correponding production number.
     *)
     := ARRAY yyReduceRangePacked OF yySymbolRangePacked
         {
           (*A 206(P   1)*)  182 , (*A 207(P   2)*)  110 , (*A 208(P   3)*)  110
         , (*A 209(P   4)*)  110 , (*A 210(P   5)*)  110 , (*A 211(P   6)*)  110
         , (*A 212(P   7)*)  110 , (*A 213(P   8)*)  116 , (*A 214(P   9)*)  117
         , (*A 215(P  10)*)  118 , (*A 216(P  11)*)  119 , (*A 217(P  12)*)  120
         , (*A 218(P  13)*)  121 , (*A 219(P  14)*)  109 , (*A 220(P  15)*)  111
         , (*A 221(P  16)*)  112 , (*A 222(P  17)*)  113 , (*A 223(P  18)*)  114
         , (*A 224(P  19)*)  115 , (*A 225(P  20)*)  122 , (*A 226(P  21)*)  122
         , (*A 227(P  22)*)  129 , (*A 228(P  23)*)  130 , (*A 229(P  24)*)  130
         , (*A 230(P  25)*)  131 , (*A 231(P  26)*)  131 , (*A 232(P  27)*)  132
         , (*A 233(P  28)*)  132 , (*A 234(P  29)*)  133 , (*A 235(P  30)*)  134
         , (*A 236(P  31)*)  134 , (*A 237(P  32)*)  135 , (*A 238(P  33)*)  135
         , (*A 239(P  34)*)  136 , (*A 240(P  35)*)  136 , (*A 241(P  36)*)  123
         , (*A 242(P  37)*)  137 , (*A 243(P  38)*)  139 , (*A 244(P  39)*)  138
         , (*A 245(P  40)*)  138 , (*A 246(P  41)*)  140 , (*A 247(P  42)*)  141
         , (*A 248(P  43)*)  141 , (*A 249(P  44)*)  140 , (*A 250(P  45)*)  142
         , (*A 251(P  46)*)  142 , (*A 252(P  47)*)  143 , (*A 253(P  48)*)  125
         , (*A 254(P  49)*)  125 , (*A 255(P  50)*)  127 , (*A 256(P  51)*)  128
         , (*A 257(P  52)*)  145 , (*A 258(P  53)*)  144 , (*A 259(P  54)*)  144
         , (*A 260(P  55)*)  146 , (*A 261(P  56)*)  149 , (*A 262(P  57)*)  148
         , (*A 263(P  58)*)  148 , (*A 264(P  59)*)  150 , (*A 265(P  60)*)  151
         , (*A 266(P  61)*)  151 , (*A 267(P  62)*)  153 , (*A 268(P  63)*)  155
         , (*A 269(P  64)*)  154 , (*A 270(P  65)*)  157 , (*A 271(P  66)*)  154
         , (*A 272(P  67)*)  156 , (*A 273(P  68)*)  158 , (*A 274(P  69)*)  159
         , (*A 275(P  70)*)  159 , (*A 276(P  71)*)  160 , (*A 277(P  72)*)  160
         , (*A 278(P  73)*)  147 , (*A 279(P  74)*)  161 , (*A 280(P  75)*)  147
         , (*A 281(P  76)*)  147 , (*A 282(P  77)*)  162 , (*A 283(P  78)*)  163
         , (*A 284(P  79)*)  163 , (*A 285(P  80)*)  166 , (*A 286(P  81)*)  167
         , (*A 287(P  82)*)  167 , (*A 288(P  83)*)  169 , (*A 289(P  84)*)  169
         , (*A 290(P  85)*)  169 , (*A 291(P  86)*)  169 , (*A 292(P  87)*)  168
         , (*A 293(P  88)*)  170 , (*A 294(P  89)*)  170 , (*A 295(P  90)*)  171
         , (*A 296(P  91)*)  171 , (*A 297(P  92)*)  164 , (*A 298(P  93)*)  164
         , (*A 299(P  94)*)  165 , (*A 300(P  95)*)  165 , (*A 301(P  96)*)  165
         , (*A 302(P  97)*)  173 , (*A 303(P  98)*)  172 , (*A 304(P  99)*)  172
         , (*A 305(P 100)*)  174 , (*A 306(P 101)*)  152 , (*A 307(P 102)*)  152
         , (*A 308(P 103)*)  126 , (*A 309(P 104)*)  175 , (*A 310(P 105)*)  124
         , (*A 311(P 106)*)  177 , (*A 312(P 107)*)  177 , (*A 313(P 108)*)  178
         , (*A 314(P 109)*)  178 , (*A 315(P 110)*)  178 , (*A 316(P 111)*)  178
         , (*A 317(P 112)*)  176 , (*A 318(P 113)*)  179 , (*A 319(P 114)*)  179
         , (*A 320(P 115)*)  176 , (*A 321(P 116)*)  180 , (*A 322(P 117)*)  181
         };
         
   yyContinuation
     := ARRAY [0 .. yyLastReadState] OF yySymbolRangePacked
         {
           (*:   0*)    0 , (*:   1*)   32 , (*:   2*)   32
         , (*:   3*)   95 , (*:   4*)   69 , (*:   5*)   69
         , (*:   6*)   70 , (*:   7*)   70 , (*:   8*)   95
         , (*:   9*)   66 , (*:  10*)   14 , (*:  11*)   14
         , (*:  12*)   19 , (*:  13*)   95 , (*:  14*)   67
         , (*:  15*)    9 , (*:  16*)   95 , (*:  17*)   68
         , (*:  18*)   95 , (*:  19*)   69 , (*:  20*)   70
         , (*:  21*)   19 , (*:  22*)   95 , (*:  23*)   95
         , (*:  24*)   19 , (*:  25*)   95 , (*:  26*)   19
         , (*:  27*)   19 , (*:  28*)   19 , (*:  29*)   95
         , (*:  30*)   19 , (*:  31*)   95 , (*:  32*)   19
         , (*:  33*)   95 , (*:  34*)   19 , (*:  35*)    6
         , (*:  36*)   71 , (*:  37*)   76 , (*:  38*)   95
         , (*:  39*)   71 , (*:  40*)   95 , (*:  41*)   95
         , (*:  42*)   70 , (*:  43*)   70 , (*:  44*)   95
         , (*:  45*)   66 , (*:  46*)   66 , (*:  47*)   95
         , (*:  48*)   66 , (*:  49*)   95 , (*:  50*)   70
         , (*:  51*)   68 , (*:  52*)   95 , (*:  53*)   66
         , (*:  54*)    9 , (*:  55*)   95 , (*:  56*)   69
         , (*:  57*)   66 , (*:  58*)    9 , (*:  59*)    9
         , (*:  60*)   95 , (*:  61*)   66 , (*:  62*)    9
         , (*:  63*)    9 , (*:  64*)   19 , (*:  65*)   74
         , (*:  66*)   95 , (*:  67*)   19 , (*:  68*)   19
         , (*:  69*)   19 , (*:  70*)   95 , (*:  71*)   68
         , (*:  72*)   95 , (*:  73*)   66 , (*:  74*)    9
         , (*:  75*)   95 , (*:  76*)   66 , (*:  77*)    9
         , (*:  78*)    9 , (*:  79*)    9 , (*:  80*)   95
         , (*:  81*)   30 , (*:  82*)   95 , (*:  83*)   95
         , (*:  84*)   66 , (*:  85*)   95 , (*:  86*)   66
         , (*:  87*)   95 , (*:  88*)   95 , (*:  89*)   69
         , (*:  90*)   69 , (*:  91*)   66 , (*:  92*)    9
         , (*:  93*)    9 , (*:  94*)   95 , (*:  95*)   67
         , (*:  96*)    0 , (*:  97*)   32 , (*:  98*)   95
         , (*:  99*)   66 , (*: 100*)   66 , (*: 101*)   14
         , (*: 102*)   14 , (*: 103*)   19 , (*: 104*)   95
         , (*: 105*)   67 , (*: 106*)   68 , (*: 107*)   95
         , (*: 108*)   69 , (*: 109*)   70 , (*: 110*)   70
         , (*: 111*)   19 , (*: 112*)   95 , (*: 113*)   67
         , (*: 114*)   95 , (*: 115*)   66 , (*: 116*)   66
         , (*: 117*)   66 , (*: 118*)    9 , (*: 119*)    9
         , (*: 120*)   95 , (*: 121*)   67 , (*: 122*)   68
         , (*: 123*)   95 , (*: 124*)   69 , (*: 125*)   19
         , (*: 126*)   95 , (*: 127*)   67 , (*: 128*)   95
         , (*: 129*)   66
         };
         
   yyFinalToProd
     (* Subscripted by a read-reduce action, maps to the reduce
        action to take after the read.
     *) 
     := ARRAY yyReadReduceRangePacked OF yyReduceRangePacked
         {
           (*RR: 130)*)  255 (*P49*) , (*RR: 131)*)  235 (*P29*)
         , (*RR: 132)*)  221 (*P15*) , (*RR: 133)*)  283 (*P77*)
         , (*RR: 134)*)  279 (*P73*) , (*RR: 135)*)  278 (*P72*)
         , (*RR: 136)*)  232 (*P26*) , (*RR: 137)*)  233 (*P27*)
         , (*RR: 138)*)  280 (*P74*) , (*RR: 139)*)  306 (*P100*)
         , (*RR: 140)*)  307 (*P101*) , (*RR: 141)*)  299 (*P93*)
         , (*RR: 142)*)  240 (*P34*) , (*RR: 143)*)  300 (*P94*)
         , (*RR: 144)*)  291 (*P85*) , (*RR: 145)*)  289 (*P83*)
         , (*RR: 146)*)  290 (*P84*) , (*RR: 147)*)  284 (*P78*)
         , (*RR: 148)*)  264 (*P58*) , (*RR: 149)*)  303 (*P97*)
         , (*RR: 150)*)  304 (*P98*) , (*RR: 151)*)  308 (*P102*)
         , (*RR: 152)*)  260 (*P54*) , (*RR: 153)*)  267 (*P61*)
         , (*RR: 154)*)  250 (*P44*) , (*RR: 155)*)  247 (*P41*)
         , (*RR: 156)*)  246 (*P40*) , (*RR: 157)*)  248 (*P42*)
         , (*RR: 158)*)  249 (*P43*) , (*RR: 159)*)  251 (*P45*)
         , (*RR: 160)*)  222 (*P16*) , (*RR: 161)*)  225 (*P19*)
         , (*RR: 162)*)  219 (*P13*) , (*RR: 163)*)  256 (*P50*)
         , (*RR: 164)*)  223 (*P17*) , (*RR: 165)*)  252 (*P46*)
         , (*RR: 166)*)  220 (*P14*) , (*RR: 167)*)  224 (*P18*)
         , (*RR: 168)*)  281 (*P75*) , (*RR: 169)*)  297 (*P91*)
         , (*RR: 170)*)  271 (*P65*) , (*RR: 171)*)  274 (*P68*)
         , (*RR: 172)*)  276 (*P70*) , (*RR: 173)*)  272 (*P66*)
         , (*RR: 174)*)  269 (*P63*) , (*RR: 175)*)  237 (*P31*)
         , (*RR: 176)*)  282 (*P76*) , (*RR: 177)*)  286 (*P80*)
         , (*RR: 178)*)  293 (*P87*) , (*RR: 179)*)  295 (*P89*)
         , (*RR: 180)*)  292 (*P86*) , (*RR: 181)*)  287 (*P81*)
         , (*RR: 182)*)  265 (*P59*) , (*RR: 183)*)  263 (*P57*)
         , (*RR: 184)*)  262 (*P56*) , (*RR: 185)*)  322 (*P116*)
         , (*RR: 186)*)  319 (*P113*) , (*RR: 187)*)  321 (*P115*)
         , (*RR: 188)*)  317 (*P111*) , (*RR: 189)*)  318 (*P112*)
         , (*RR: 190)*)  302 (*P96*) , (*RR: 191)*)  259 (*P53*)
         , (*RR: 192)*)  258 (*P52*) , (*RR: 193)*)  315 (*P109*)
         , (*RR: 194)*)  313 (*P107*) , (*RR: 195)*)  314 (*P108*)
         , (*RR: 196)*)  316 (*P110*) , (*RR: 197)*)  311 (*P105*)
         , (*RR: 198)*)  241 (*P35*) , (*RR: 199)*)  244 (*P38*)
         , (*RR: 200)*)  207 (*P1*) , (*RR: 201)*)  208 (*P2*)
         , (*RR: 202)*)  209 (*P3*) , (*RR: 203)*)  210 (*P4*)
         , (*RR: 204)*)  211 (*P5*) , (*RR: 205)*)  212 (*P6*)
         }; 

VAR
   yyIsInitialized      : BOOLEAN;
   yyTableFile          : System.tFile;
   yyErrMsgWrT          : TextWr . T;
  yyErrorPos           : FM3Scanner.tPosition;
   yyMsgLineLen         : INTEGER;
   
(* Copied in from Parser.m30.orig: *) 
    PROCEDURE ExpandStateStack ( VAR Stack : yyStackType ; ToSize : INTEGER ) =

      VAR LOldStack : yyStackType;
      VAR LStackNumber : INTEGER; 
      BEGIN
        LStackNumber := NUMBER ( Stack ^ );
        IF LStackNumber < ToSize
        THEN
          LOldStack := Stack; 
          Stack := NEW ( yyStackType , ToSize );
          SUBARRAY ( Stack ^ , 0 , LStackNumber ) := LOldStack ^;
          LOldStack := NIL; 
        END;
      END ExpandStateStack; 

    PROCEDURE ExpandAttributeStack
      ( VAR Stack : yyAttributeStackType ; ToSize : INTEGER ) =

      VAR LOldStack : yyAttributeStackType;
      VAR LStackNumber : INTEGER; 
      BEGIN
        LStackNumber := NUMBER ( Stack ^ );
        IF LStackNumber < ToSize
        THEN
          LOldStack := Stack; 
          Stack := NEW ( yyAttributeStackType , ToSize );
          SUBARRAY ( Stack ^ , 0 , LStackNumber ) := LOldStack ^;
          LOldStack := NIL; 
        END; 
      END ExpandAttributeStack; 
(* END From Parser.m30.orig: *) 

(*EXPORTED*)
PROCEDURE TokenName (Token: INTEGER; VAR Name: TEXT) =
   BEGIN
(*TODO: Implement a version of this that returns, e.g. BEGIN
        instead of StkReBegin.  Use it messages giving error token,
        expected token(s), and inserted token(s).
*)
      CASE Token OF
      | 0 => Name := "_EndOfFile";
      | 5 => Name := "StkRwAND";
      | 6 => Name := "StkRwANY";
      | 7 => Name := "StkRwARRAY";
      | 8 => Name := "StkRwAS";
      | 9 => Name := "StkRwBEGIN";
      | 10 => Name := "StkRwBITS";
      | 11 => Name := "StkRwBRANDED";
      | 12 => Name := "StkRwBY";
      | 13 => Name := "StkRwCASE";
      | 14 => Name := "StkRwCONST";
      | 15 => Name := "StkRwDIV";
      | 16 => Name := "StkRwDO";
      | 17 => Name := "StkRwELSE";
      | 18 => Name := "StkRwELSIF";
      | 19 => Name := "StkRwEND";
      | 20 => Name := "StkRwEVAL";
      | 21 => Name := "StkRwEXCEPT";
      | 22 => Name := "StkRwEXCEPTION";
      | 23 => Name := "StkRwEXIT";
      | 24 => Name := "StkRwEXPORTS";
      | 25 => Name := "StkRwFINALLY";
      | 26 => Name := "StkRwFOR";
      | 27 => Name := "StkRwFROM";
      | 28 => Name := "StkRwGENERIC";
      | 29 => Name := "StkRwIF";
      | 30 => Name := "StkRwIMPORT";
      | 31 => Name := "StkRwIN";
      | 32 => Name := "StkRwINTERFACE";
      | 33 => Name := "StkRwLOCK";
      | 34 => Name := "StkRwLOOP";
      | 35 => Name := "StkRwMETHODS";
      | 36 => Name := "StkRwMOD";
      | 37 => Name := "StkRwMODULE";
      | 38 => Name := "StkRwNOT";
      | 39 => Name := "StkRwOBJECT";
      | 40 => Name := "StkRwOF";
      | 41 => Name := "StkRwOR";
      | 42 => Name := "StkRwOVERRIDES";
      | 43 => Name := "StkRwPROCEDURE";
      | 44 => Name := "StkRwRAISE";
      | 45 => Name := "StkRwRAISES";
      | 46 => Name := "StkRwREADONLY";
      | 47 => Name := "StkRwRECORD";
      | 48 => Name := "StkRwREF";
      | 49 => Name := "StkRwREPEAT";
      | 50 => Name := "StkRwRETURN";
      | 51 => Name := "StkRwREVEAL";
      | 52 => Name := "StkRwROOT";
      | 53 => Name := "StkRwSET";
      | 54 => Name := "StkRwTHEN";
      | 55 => Name := "StkRwTO";
      | 56 => Name := "StkRwTRY";
      | 57 => Name := "StkRwTYPE";
      | 58 => Name := "StkRwTYPECASE";
      | 59 => Name := "StkRwUNSAFE";
      | 60 => Name := "StkRwUNTIL";
      | 61 => Name := "StkRwUNTRACED";
      | 62 => Name := "StkRwVALUE";
      | 63 => Name := "StkRwVAR";
      | 64 => Name := "StkRwWHILE";
      | 65 => Name := "StkRwWITH";
      | 66 => Name := "StkSemicolon";
      | 67 => Name := "StkDot";
      | 68 => Name := "StkEqual";
      | 69 => Name := "StkOpenParen";
      | 70 => Name := "StkCloseParen";
      | 71 => Name := "StkComma";
      | 72 => Name := "StkColon";
      | 73 => Name := "StkSubtype";
      | 74 => Name := "StkBecomes";
      | 75 => Name := "StkOpenBrace";
      | 76 => Name := "StkCloseBrace";
      | 77 => Name := "StkStroke";
      | 78 => Name := "StkArrow";
      | 79 => Name := "StkEllipsis";
      | 80 => Name := "StkOpenBracket";
      | 81 => Name := "StkCloseBracket";
      | 82 => Name := "StkUnequal";
      | 83 => Name := "StkLess";
      | 84 => Name := "StkGreater";
      | 85 => Name := "StkLessEqual";
      | 86 => Name := "StkGreaterEqual";
      | 87 => Name := "StkPlus";
      | 88 => Name := "StkMinus";
      | 89 => Name := "StkAmpersand";
      | 90 => Name := "StkStar";
      | 91 => Name := "StkSlash";
      | 92 => Name := "StkDeref";
      | 93 => Name := "StkOpenPragma";
      | 94 => Name := "StkClosePragma";
      | 95 => Name := "StkIdent";
      | 96 => Name := "StkIntLit";
      | 97 => Name := "StkLongIntLit";
      | 98 => Name := "StkBasedLit";
      | 99 => Name := "StkLongBasedLit";
      | 100 => Name := "StkRealLit";
      | 101 => Name := "StkLongRealLit";
      | 102 => Name := "StkExtendedLit";
      | 103 => Name := "StkTextLit";
      | 104 => Name := "StkWideTextLit";
      | 105 => Name := "StkCharLit";
      | 106 => Name := "StkWideCharLit";
      | 107 => Name := "StkLexErrChars";
      | 108 => Name := "StkReservedId";
      ELSE Name := "" 
      END;
   END TokenName;

(* NOTE regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the leftmost RHS's attribute.
   How confusing, but it preserves a bit of lalr's original parsing speed.
*) 

(*EXPORTED*)
  PROCEDURE FM3Parser (): CARDINAL =

   (* Declarations from the LOCAL section of the .lalr file: *) 
(* line 50 "FM3Parser.lalr" *)
 TYPE Sk = FM3Scopes . ScopeKindTyp ;
    TYPE Dk = FM3Decls . DeclKindTyp ; 
    TYPE Uk = FM3Units . UnitKindTyp ;

PROCEDURE Test ( READONLY Attr : tParsAttribute )
= VAR Debug : INTEGER := 0
; BEGIN
    IF Attr . PaInt = FIRST ( INTEGER)
    THEN
      Debug := 19
    END 
  END Test ;

  
   (* End of declarations from the LOCAL section of the .lalr file: *)
   
   VAR
      yyOldUnnestCoord  : LONGINT; 
      yyState           : yyStateRange;
      (* NOTE: "yyState" and other occurrences of "State" are misleading.
               They are, in general, parsing *actions*, only the low range
               up to yyLastReadState (a constant inserted by the generator)
               being truly states.  These correspond to item sets, and as
               actions, they mean read (it will be a terminal) and enter
               new state yyState.  Higher ranges are read-terminal-reduce,
               read-nonterminal-reduce, and just reduce actions.
               Deconfusing this terminology would require extensive and
               error-prone work.
      *) 
      yyTerminal        : yySymbolRange;
      yyNonterminal     : yySymbolRange;
        (* ^LHS NT to be pushed as result of a reduction.*)
     yyNTPos           : FM3Scanner.tPosition (* Position for yyNonterminal. *) ;  

      yyStackPtr        : yyStackPtrType;
      yyPrereduceStackPtr : yyStackPtrType;
      yyStackLAST       : INTEGER;
      yyStateStackSize  : INTEGER;
      yyAttrStackSize   := yyStateStackSize; 
      (* yyStackPtr, yyStackLAST, and yyStateStackSize always apply equally
         to yyStateStack and yyAttributeStack. *)
      yyStateStack      : yyStackType;
      yyAttributeStack  : yyAttributeStackType;
      yySynAttribute    : tParsAttribute;
        (* ^Synthesized attribute, by .lalr-provided semantic actions. *)
     yyRepairAttribute : FM3Scanner.tScanAttribute;
      yyRepairToken     : yySymbolRange;
      yyTCombPtr        : yyTCombTypePtr;
      yyNCombPtr        : yyNCombTypePtr;
      yyErrorCount      : CARDINAL;
      yyText            : TEXT; 
      yyTokenStringxxx  : TEXT (*ARRAY [0..127] OF CHAR*);
      (* ^For use in a debugger. *) 
      yyRepairsInserted : INTEGER;
      (* ^<0 => not repairing. Otherwise, number of tokens inserted so far. *)

   BEGIN (* FM3Parser *) 
     BeginFM3Parser ();
      yyState           := yyStartState;
     yyTerminal        := FM3Scanner.GetToken ();
      yyStateStackSize  := yyInitStackSize;
      yyAttrStackSize   := yyInitStackSize;
      yyStateStack      := NEW ( yyStackType , yyStateStackSize );
      yyAttributeStack  := NEW ( yyAttributeStackType , yyStateStackSize ); 
      yyStackLAST       := LAST ( yyStateStack ^ ) (* Of yyAttributeStack too. *);
      yyStackPtr        := 0;
      yyErrorCount      := 0;
      yyRepairsInserted := - 1;

      LOOP (* Through parsing actions. One iteration does:
              1) Any token deletions called for by an error.
              2) Any continuation token insertions called for 
                 after an error.
              3) Either: 
                 a) Possibly one read-reduce followed by 
                    a sequence of reduces
              or b) One read
           *)  
         (* Make room and push true state onto state stack. *) 
         IF yyStackPtr >= yyStackLAST 
         THEN
            yyStateStackSize
              := MAX ( NUMBER ( yyStateStack ^ ) * 2 , yyStackPtr + 2 ); 
            ExpandStateStack ( yyStateStack , yyStateStackSize ); 
            ExpandAttributeStack ( yyAttributeStack , yyStateStackSize );
            yyStackLAST
              := LAST ( yyStateStack ^ ) (* Of yyAttributeStack too. *);
         END (* IF *) ;
         yyStateStack^ [yyStackPtr] := (*State*)yyState;

         LOOP (* Through all continuation shifts, plus compute the state
                 after that.  This loop also goes through the default state
                 computations. *) 
            (* SPEC State := Next (State, Terminal); terminal transition *)
            
            yyTCombPtr := LOOPHOLE 
                            ( LOOPHOLE ( yyTBasePtr [yyState (*State*)] ,INTEGER) 
                              + yyTerminal * BYTESIZE (yyTCombType)
                            , yyTCombTypePtr
                            );
            IF yyTCombPtr^.Check = (*State*)yyState 
            THEN
               yyState := yyTCombPtr^.Next;
               EXIT;
            END (* IF *) ;
            (*State*)yyState := yyDefault [(*State*)yyState];

            IF yyState = yyNoState 
            THEN (* syntax error *)
               (*State*)yyState := yyStateStack^ [yyStackPtr];
               IF yyRepairsInserted >= 0 
               THEN (* Repairing. *)
                  (*ASSERT yyErrMsgWrT # NIL *)
                  yyRepairToken := yyContinuation [yyState];
                  yyState (*Any action*) := Next (yyState, yyRepairToken);
                  IF yyState <= yyLastReadTermState 
                  THEN (* read or read terminal reduce ? *)
                    FM3Scanner.ErrorAttribute 
                         (yyRepairToken, (*OUT*)yyRepairAttribute);
                     TokenName (yyRepairToken, (*OUT*) yyText);
                     IF yyRepairsInserted = 0 THEN 
                       Wr.PutText (yyErrMsgWrT, FM3Messages.NLIndent);
                       yyMsgLineLen := FM3Messages.IndentLen;
                       AppendToLine ("Repair token(s) inserted: ");
                     END (*IF*);
                     QuoteAndFillOnLine ( yyText );
                     INC (yyRepairsInserted );
                     IF yyState >= yyFirstFinalState 
                     THEN (* avoid second push *)
                        yyState (*Reduce*) := yyFinalToProd [(*Action*)yyState];
                     END (* IF *) ;
                     INC (yyStackPtr);
                     yyStateStack^ [yyStackPtr] := yyState;
                     WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
                     DO 
                       WParsAttr.Scan := yyRepairAttribute;
                       WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*                     PushUnnestStk (WParsAttr); *)
                     END (*WITH*)
                  END (* IF *) ;
                  IF yyState >= yyFirstFinalState 
                  THEN (* final state ? *)
                    EXIT;
                  END (* IF *) ;
               ELSE (* Report and start recovery. *)
                  INC (yyErrorCount);
                  ErrorRecovery 
                    (yyTerminal, yyStateStack,
                     NUMBER ( yyStateStack ^ ), yyStackPtr);
                  yyRepairsInserted := 0;
               END (* IF *) ;
            END (* IF *) ;
         END (* LOOP *) ;

         IF yyState >= yyFirstFinalState 
         THEN (* Action, ending with a reduce. *)
            IF yyState <= yyLastReadTermState (* read terminal reduce ? *) 
            THEN (* First do the read terminal. *)
              INC (yyStackPtr);
              (* Is there such a thing as a read-reduce action where the
                 reduce is by an empty production?  And so are all the
                 subsequent reduces?  If so, it is important to store into
                 the two stacks, which will not be overlaid by reduces.
              *)
              yyStateStack^ [yyStackPtr]
                := yyState (*Read terminal reduce action*) (*ParserDebug*);
              (* ^Not a true state.  Should be overlaid very soon.  But if
                  not, due to empty reduces, this will be the wrong value
                  in the state stack. *)
              WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
              DO
                WParsAttr := ParsAttrNull; 
                WParsAttr.Scan := FM3Scanner.Attribute;
                WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*              PushUnnestStk (WParsAttr); *) 
              END (*WITH*);
             yyTerminal := FM3Scanner.GetToken ();
              IF yyRepairsInserted >= 0
              (* ^0 => repair's been happening, tho' with no insertions. *) 
              THEN (* Finished with a repair. *) 
                 EmitSyntErrMsg ( );
                 yyRepairsInserted := - 1;
              END (*IF*);

               yyStateStack^ [yyStackPtr] := (*Reduce*)yyState (*ParserDebug*);
            END (* IF *) ;

            LOOP (* Through successive reductions *)
               yyPrereduceStackPtr := yyStackPtr;
               yySynAttribute := ParsAttrNull; 

             (* Inserted semantic action code from the .lalr file: **)
              CASE yyState OF
              | 206 => (* P1 _0000_ (182): Compilation _EndOfFile .*)
                yyStateStack := NIL;
                yyAttributeStack := NIL;
                RETURN yyErrorCount;

              | 207,200 => (* P2 Compilation (110): Interface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 208,201 => (* P3 Compilation (110): Module .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 209,202 => (* P4 Compilation (110): GenInterface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 210,203 => (* P5 Compilation (110): GenModule .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 211,204 => (* P6 Compilation (110): InstInterface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 212,205 => (* P7 Compilation (110): InstModule .*)
                DEC (yyStackPtr, 1); yyNonterminal := 110;

              | 213 => (* P8 InterfaceKind (116): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 116;
                (* line 229 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInterface ; 
              | 214 => (* P9 ModuleKind (117): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 117;
                (* line 232 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkModule ; 
              | 215 => (* P10 GenInterfaceKind (118): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 118;
                (* line 235 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenInterface ; 
              | 216 => (* P11 GenModuleKind (119): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 119;
                (* line 238 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenModule ; 
              | 217 => (* P12 InstInterfaceKind (120): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 120;
                (* line 241 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstInterface ; 
              | 218 => (* P13 InstModuleKind (121): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 121;
                (* line 244 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstModule ; 
              | 219,162 => (* P14 Interface (109): OptUnsafe StkRwINTERFACE StkIdent InterfaceKind StkSemicolon Imports DeclList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 10); yyNonterminal := 109;

              | 220,166 => (* P15 Module (111): OptUnsafe StkRwMODULE StkIdent Exports ModuleKind StkSemicolon Imports Block StkIdent StkDot .*)
                DEC (yyStackPtr, 10); yyNonterminal := 111;

              | 221,132 => (* P16 GenInterface (112): StkRwGENERIC StkRwINTERFACE StkIdent GenInterfaceKind GenFormalList StkSemicolon Imports DeclList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 11); yyNonterminal := 112;

              | 222,160 => (* P17 GenModule (113): StkRwGENERIC StkRwMODULE StkIdent GenModuleKind GenFormalList StkSemicolon Imports Block StkIdent StkDot .*)
                DEC (yyStackPtr, 10); yyNonterminal := 113;

              | 223,164 => (* P18 InstInterface (114): OptUnsafe StkRwINTERFACE StkIdent InstInterfaceKind StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 10); yyNonterminal := 114;

              | 224,167 => (* P19 InstModule (115): OptUnsafe StkRwMODULE StkIdent Exports InstModuleKind StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 11); yyNonterminal := 115;

              | 225,161 => (* P20 OptUnsafe (122): StkRwUNSAFE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 122;
                (* line 270 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Unsafe.*) := TRUE ; 
              | 226 => (* P21 OptUnsafe (122): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 122;
                (* line 271 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; 
              | 227 => (* P22 CaptureCoord (129): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 129;
                (* line 274 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ; 
              | 228 => (* P23 OptSemicolon (130): StkSemicolon .*)
                DEC (yyStackPtr, 1); yyNonterminal := 130;

              | 229 => (* P24 OptSemicolon (130): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 130;

              | 230 => (* P25 IdPlusList (131): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 131;
                (* line 282 of "FM3Parser.lalr" *)
                 (* PaUnnestCoord copied from yyAttributeStack^[yyStackPtr+1] by parser. *) 
                       yySynAttribute . PaInt := 1 ;
                     
              | 231 => (* P26 IdPlusList (131): IdPlusList StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 131;
                (* line 286 of "FM3Parser.lalr" *)
                 (* PaUnnestCoord copied from yyAttributeStack^[yyStackPtr+1] by parser. *) 
                       yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;
                     
              | 232,136 => (* P27 DeclIdListElems (132): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 132;
                (* line 294 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := yyAttributeStack^[yyStackPtr] . PaUnnestCoord ; 
                       yySynAttribute . PaInt (* Valid Id count. *)
                         := ORD
                              ( FM3ParsePass . DeclIdL2R
                                  ( FM3Base . PositionNull
                                  , yyAttributeStack^[yyStackPtr+1]
                                  , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                                  , PriorIdCt := 0 
                                  )
                              ) ;
                EVAL yySynAttribute . PaInt ; 
                Test ( yySynAttribute ) ; 
                     
              | 233,137 => (* P28 DeclIdListElems (132): DeclIdListElems StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 132;
                (* line 310 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord (* Needed? *) ;
                       IF FM3ParsePass . DeclIdL2R
                            ( yyAttributeStack^[yyStackPtr+2] . Scan . Position
                            , yyAttributeStack^[yyStackPtr+3]
                            , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                            , PriorIdCt := yyAttributeStack^[yyStackPtr+1] . PaInt
                            ) 
                       THEN (* Use this ident. *) yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;  
                       ELSE yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid Id count, no increase. *) ; 
                       END (*IF*) ; 
                EVAL yySynAttribute . PaInt ; 
                Test ( yySynAttribute ) ; 
                     
              | 234 => (* P29 DeclIdListRt (133): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 133;
                (* line 327 of "FM3Parser.lalr" *)
                 IF yyAttributeStack^[yyStackPtr] . PaInt = 0 (* No usable idents. *)
                       THEN (* Skip entire decl, along with any Ids. *) 
                         yySynAttribute . PaInt := FM3ParsePass . StartSkipping ( ) ;
                       ELSE
                         yySynAttribute . PaInt := FM3ParsePass . SkipDepth ; 
                         MakeListPos (* The identifier list. *) 
                           ( yySynAttribute
                           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                           , yyAttributeStack^[yyStackPtr] . Scan . Position
                           , ElemsAttr := yyAttributeStack^[yyStackPtr]
                           ) ; 
                       END (*IF*)
                     
              | 235,131 => (* P30 IdStarList (134): IdStarList StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 134;
                (* line 343 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ; 
              | 236 => (* P31 IdStarList (134): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 134;
                (* line 345 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ; 
              | 237,175 => (* P32 QualIdStarList (135): QualIdStarList StkComma QualId .*)
                DEC (yyStackPtr, 3); yyNonterminal := 135;
                (* line 349 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ; 
              | 238 => (* P33 QualIdStarList (135): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 135;
                (* line 351 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ; 
              | 239 => (* P34 QualId (136): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 136;

              | 240,142 => (* P35 QualId (136): StkIdent StkDot StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 136;
                (* line 356 of "FM3Parser.lalr" *)
                 Push_LCeCr
                         ( Itk . ItkQualIdLt ,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord );
                     
              | 241,198 => (* P36 Imports (123): ImportsLt ImportsRecurse ImportsRt .*)
                DEC (yyStackPtr, 3); yyNonterminal := 123;
                (* line 363 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt (* Imported interface Count. *) ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+2] . PaLong (* Imported unqualified Ident Count. *) ;
                     
              | 242 => (* P37 ImportsLt (137): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 137;
                (* line 366 of "FM3Parser.lalr" *)
                 FM3ParsePass . ImportsLt ( ) ; 
              | 243 => (* P38 ImportsRt (139): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 139;
                (* line 367 of "FM3Parser.lalr" *)
                 FM3ParsePass . ImportsRt ( ) ; 
              | 244,199 => (* P39 ImportsRecurse (138): ImportsRecurse ImportItem .*)
                DEC (yyStackPtr, 2); yyNonterminal := 138;
                (* line 369 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong + yyAttributeStack^[yyStackPtr+2] . PaLong ;
                     
              | 245 => (* P40 ImportsRecurse (138): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 138;
                (* line 373 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0; 
                       yySynAttribute . PaLong := 0L; 
                     
              | 246,156 => (* P41 ImportItem (140): StkRwIMPORT ImportIntfPlusList StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 140;
                (* line 379 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       yySynAttribute . PaLong := 0L ; 
                     
              | 247,155 => (* P42 ImportIntfPlusList (141): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 141;
                (* line 383 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 ;
                       FM3ParsePass . Import
                         ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ; 
                       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
                       Push_LI3
                         ( Itk . ItkImport
                         , yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Column
                         ) ;
                     
              | 248,157 => (* P43 ImportIntfPlusList (141): ImportIntfPlusList StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 141;
                (* line 395 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;
                       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
                       FM3ParsePass . Import
                         ( yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+3] . Scan . Position ) ; 
                       Push_LI3
                         ( Itk . ItkImport
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Column
                         ) ;
                     
              | 249,158 => (* P44 ImportItem (140): FromImportPlusList StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 140;
                (* line 409 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong ; 
                     
              | 250,154 => (* P45 FromImportPlusList (142): StkRwFROM StkIdent StkRwIMPORT StkIdent .*)
                DEC (yyStackPtr, 4); yyNonterminal := 142;
                (* line 413 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 (* InterfaceCt. *) ;
                       yySynAttribute . PaLong := 1L ;
                       yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+2] . Scan . Position ; 
                       FM3ParsePass . FromImport
                         ( yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position 
                         , yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position 
                         ) ; 
                       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
                       Push_LI6
                         ( Itk . ItkFromImport
                           (* Interface operands on left, then Decl ID items on Right. *) 
                         , yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position . Column
                         , yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position . Column
                         ) ;
                     
              | 251,159 => (* P46 FromImportPlusList (142): FromImportPlusList StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 142;
                (* line 436 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong + 1L ;
                       yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       FM3ParsePass . FromImport
                         ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position 
                         ) ; 
                       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
                       Push_LI6
                         ( Itk . ItkFromImport
                           (* Interface operands on left, then Decl ID items on Right. *) 
                         , yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Column
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Column
                         ) ;
                     
              | 252,165 => (* P47 ExportsLt (143): StkRwEXPORTS .*)
                DEC (yyStackPtr, 1); yyNonterminal := 143;
                (* line 475 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaTok1 := Itk . ItkExportIdListLt ; 
                (* TODO: check push/pop of scope numbers, similarly to DeclInfoDepth. *)
                       yySynAttribute . PaConstructNo 
                         := FM3ParsePass . ScopeLtL2R
                              ( FM3Scopes . ScopeKindTyp . SkExports , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                       (* Although an export list is not exactly a scope, we Use the scope
                          and DeclInfo mechanisms to check reserved and duplicated idents.
                          ScopeRtL2R will handle the legal ones specially.
                       *)
                       yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ; 
                       yySynAttribute . PaInt (* DeclInfoDepth *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkExportIdListLt
                                  , DiDeclTok := Itk . ItkNull
                                  , DiKind := Dk . DkExports 
                                  }
                              ) ;
                     
                     
              | 253 => (* P48 Exports (125): ExportsLt DeclIdListElems .*)
                DEC (yyStackPtr, 2); yyNonterminal := 125;
                (* line 498 of "FM3Parser.lalr" *)
                 IF yyAttributeStack^[yyStackPtr+2] . PaInt <= 0 (* No usable idents. *)
                       THEN (* Skip entire decl, along with any Ids. *) 
                         yySynAttribute . PaInt := FM3ParsePass . StartSkipping ( ) ;
                       ELSE 
                         MakeListPos (* The identifier list. *) 
                           ( yySynAttribute
                           , Itk . ItkExportIdListLt
                           , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                (* CHECK: MakeListPos could take the position from ElemsAttr.
                          Do ther calls have the same property? *) 
                           , ElemsAttr := yyAttributeStack^[yyStackPtr+2]
                           ) ; 
                       END (*IF*) ;
                       <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt (* Scope No. *) *>
                       FM3ParsePass . ScopeRtL2R ( yyAttributeStack^[yyStackPtr+1] . PaConstructNo ) ; 
                     
              | 254 => (* P49 Exports (125): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 125;
                (* line 516 of "FM3Parser.lalr" *)
                 FM3ParsePass . PushEXPORTSMain ( yyAttributeStack^[yyStackPtr] . Scan . Position ) ; 
              | 255,130 => (* P50 GenFormalList (127): StkOpenParen IdStarList StkCloseParen .*)
                DEC (yyStackPtr, 3); yyNonterminal := 127;
                (* line 522 of "FM3Parser.lalr" *)
                 MakeListPos 
                         ( yySynAttribute , Itk. ItkGenFormalIdListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                     
              | 256,163 => (* P51 GenActualList (128): StkOpenParen IdStarList StkCloseParen .*)
                DEC (yyStackPtr, 3); yyNonterminal := 128;
                (* line 528 of "FM3Parser.lalr" *)
                 MakeListPos
                         ( yySynAttribute , Itk. ItkGenActualIdListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                     
              | 257 => (* P52 TypeDeclGroup (145): StkRwTYPE TypeDecls .*)
                DEC (yyStackPtr, 2); yyNonterminal := 145;

              | 258,192 => (* P53 TypeDecls (144): TypeDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 144;

              | 259,191 => (* P54 TypeDecls (144): TypeDecls TypeDecl .*)
                DEC (yyStackPtr, 2); yyNonterminal := 144;

              | 260,152 => (* P55 TypeDecl (146): StkIdent StkEqual Type StkSemicolon .*)
                DEC (yyStackPtr, 4); yyNonterminal := 146;
                (* line 538 of "FM3Parser.lalr" *)
                 Push_LCPeCrP
                         ( Itk . ItkTypeDeclLt
                         , yyAttributeStack^[yyStackPtr] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                         ) ; 
                     
              | 261 => (* P56 ConstDeclGroup (149): StkRwCONST ConstDecls .*)
                DEC (yyStackPtr, 2); yyNonterminal := 149;

              | 262,184 => (* P57 ConstDecls (148): ConstDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 148;

              | 263,183 => (* P58 ConstDecls (148): ConstDecls ConstDecl .*)
                DEC (yyStackPtr, 2); yyNonterminal := 148;

              | 264,148 => (* P59 ConstDecl (150): StkIdent OptConstType StkEqual Expr StkSemicolon .*)
                DEC (yyStackPtr, 5); yyNonterminal := 150;

              | 265,182 => (* P60 OptConstType (151): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 151;
                (* line 554 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord ;
                       yySynAttribute . PaBool (* Present. *) := TRUE ; 
              | 266 => (* P61 OptConstType (151): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 151;
                (* line 557 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ;
                       yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ;
                     
              | 267,153 => (* P62 VarDeclGroupLt (153): StkRwVAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 153;
                (* line 573 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := Itk . ItkVarDeclIdListLt ; 
                       yySynAttribute . PaTok2 := Itk . ItkVarDeclLt ; 
                       yySynAttribute . PaInt (* DeclInfoDepth *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkVarDeclIdListLt
                                  , DiDeclTok := Itk . ItkVarDeclLt
                                  , DiKind := Dk . DkVar
                                  }
                              ) ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position;
                     
              | 268 => (* P63 VarDeclGroup (155): VarDeclGroupLt VarDecls StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 155;
                (* line 587 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                        <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt *>
                      
              | 269,174 => (* P64 VarDecls (154): VarDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;
                (* line 596 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count, could be zero. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaTok1 := yyAttributeStack^[yyStackPtr] . PaTok1 ; 
                       yySynAttribute . PaTok2 := yyAttributeStack^[yyStackPtr] . PaTok2 ; 
                     
              | 270 => (* P65 VarDeclsSemicolon (157): StkSemicolon .*)
                DEC (yyStackPtr, 1); yyNonterminal := 157;
                (* line 603 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := yyAttributeStack^[yyStackPtr] . PaTok1 ;  
                       yySynAttribute . PaTok2 := yyAttributeStack^[yyStackPtr] . PaTok2 ;
                     
              | 271,170 => (* P66 VarDecls (154): VarDecls VarDeclsSemicolon VarDecl .*)
                DEC (yyStackPtr, 3); yyNonterminal := 154;
                (* line 609 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+3] . PaInt ;
                       yySynAttribute . PaTok1 := yyAttributeStack^[yyStackPtr] . PaTok1 ; 
                       yySynAttribute . PaTok2 := yyAttributeStack^[yyStackPtr] . PaTok2 ; 
                     
              | 272,173 => (* P67 VarDecl (156): VarDeclIds OptVarType OptVarValue .*)
                DEC (yyStackPtr, 3); yyNonterminal := 156;
                (* line 615 of "FM3Parser.lalr" *)
                 FM3ParsePass . RequireTypeAndOrValue
                         ( yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] . PaBool , yyAttributeStack^[yyStackPtr+3] . PaBool ) ;
                       (* ^Check this even if there are no valid ids. *)
                Test ( yyAttributeStack^[yyStackPtr+1] ) ; 
                       IF yyAttributeStack^[yyStackPtr+1] . PaInt < 0 (* Skipping depth. *) 
                       THEN (* Have been omitting the declaration. *)
                         <* ASSERT FM3ParsePass . StopSkipping ( ) = - yyAttributeStack^[yyStackPtr+1] . PaInt *> 
                       ELSE
                         yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid id count. *) ;
                         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
                         DO 
                           Push_LCP_eCP_zCP_rP (* The declaration itself. *) 
                             ( WDeclInfo . DiDeclTok 
                             , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+3] . Scan . Position 
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                            ) ;
                         END (*WITH*) 
                       END (*IF*) 
                     
              | 273 => (* P68 VarDeclIds (158): DeclIdListElems .*)
                DEC (yyStackPtr, 1); yyNonterminal := 158;
                (* line 643 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid id count. *) ;
                       IF yyAttributeStack^[yyStackPtr+1] . PaInt <= 0 (* No usable idents. *)
                       THEN (* No ouput and skip remainder of decl. *) 
                         yySynAttribute . PaInt (* Minus Skipping depth. *) 
                           := - FM3ParsePass . StartSkipping ( ) ;
                       ELSE
                         yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid id count. *) ;
                         MakeListPos (* The identifier list. *) 
                           ( yySynAttribute
                           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           , ElemsAttr := yyAttributeStack^[yyStackPtr+1]
                           ) ; 
                       END (*IF*) ;
                Test ( yySynAttribute ) ; 
                     
              | 274,171 => (* P69 OptVarType (159): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 159;
                (* line 661 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord ;
                       yySynAttribute . PaBool (* Present. *) := TRUE ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                     
              | 275 => (* P70 OptVarType (159): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 159;
                (* line 666 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ); 
                       yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ; 
                     
              | 276,172 => (* P71 OptVarValue (160): StkBecomes Expr .*)
                DEC (yyStackPtr, 2); yyNonterminal := 160;
                (* line 671 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord ;
                       yySynAttribute . PaBool (* Present. *) := TRUE ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                     
              | 277 => (* P72 OptVarValue (160): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 160;
                (* line 676 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ); 
                       yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ; 
                     
              | 278,135 => (* P73 Type (147): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 147;

              | 279,134 => (* P74 RecTypeLt (161): StkRwRECORD .*)
                DEC (yyStackPtr, 1); yyNonterminal := 161;
                (* line 688 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position :=  yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaTok1 := Itk . ItkRecFieldIdListLt ;
                       yySynAttribute . PaTok2 := Itk . ItkRecFieldIdListElem ;
                       yySynAttribute . PaConstructNo  
                         := FM3ParsePass . ScopeLtL2R
                              ( Sk . SkRec , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                       yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkRecFieldIdListLt
                                  , DiDeclTok := Itk . ItkRecFieldLt
                                  , DiKind := Dk . DkRecField 
                                  }
                              ) ;
                     
              | 280,138 => (* P75 Type (147): RecTypeLt VarDecls OptSemicolon StkRwEND .*)
                DEC (yyStackPtr, 4); yyNonterminal := 147;
                (* line 706 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LCPI_rpi
                         ( Itk . ItkRecDefLt
                         , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+2] . PaInt (* Count of decls, fields, formals, etc. *) 
                         ) ;
                       <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt *> 
                       FM3ParsePass . ScopeRtL2R ( yyAttributeStack^[yyStackPtr+1] . PaConstructNo ) ; 
                     
              | 281,168 => (* P76 Type (147): StkRwPROCEDURE Signature .*)
                DEC (yyStackPtr, 2); yyNonterminal := 147;
                (* line 719 of "FM3Parser.lalr" *)
                 Push_LCP_rp
                         ( Itk . ItkProcTypeLt , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                     
              | 282,176 => (* P77 Signature (162): Formals ResultType Raises .*)
                DEC (yyStackPtr, 3); yyNonterminal := 162;
                (* line 725 of "FM3Parser.lalr" *)
                 VAR LTok : Itk . TokTyp;
                       BEGIN
                         IF yyAttributeStack^[yyStackPtr+2] . PaBool (* Has result type *) 
                         THEN LTok := Itk . ItkFuncSignatureLt ;
                         ELSE LTok := Itk . ItkProcSignatureLt ;
                         END (*IF*);
                         Push_LCP_rp ( LTok,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                       END (*Block*) 
                     
              | 283,133 => (* P78 Formals (163): StkOpenParen StkCloseParen .*)
                DEC (yyStackPtr, 2); yyNonterminal := 163;
                (* line 741 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaInt := 0 ; 
                       FM3ParsePass . ScopeEmpty ( Sk . SkFormals ) ; 
                       PushUnnest ( Itk . ItkFormalsListEmpty )
                     
              | 284,147 => (* P79 Formals (163): FormalsLt FormalsPlusList OptSemicolon StkCloseParen .*)
                DEC (yyStackPtr, 4); yyNonterminal := 163;
                (* line 747 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt ; 
                       FM3ParsePass . ScopeRtL2R ( yyAttributeStack^[yyStackPtr+1] . PaConstructNo ) ;
                       MakeListPos
                         ( yySynAttribute , Itk . ItkVALUEFormalIdListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                (* FIXME^ different tokens for different formal modes. *) 
                     
              | 285 => (* P80 FormalsLt (166): StkOpenParen .*)
                DEC (yyStackPtr, 1); yyNonterminal := 166;
                (* line 755 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaConstructNo 
                         := FM3ParsePass . ScopeLtL2R
                              ( Sk . SkFormals , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                       yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ;
                     
              | 286,177 => (* P81 FormalsPlusList (167): FormalsPlusList StkSemicolon Formal .*)
                DEC (yyStackPtr, 3); yyNonterminal := 167;
                (* line 762 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+3] . PaInt ; 
              | 287,181 => (* P82 FormalsPlusList (167): Formal .*)
                DEC (yyStackPtr, 1); yyNonterminal := 167;
                (* line 764 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ; 
              | 288 => (* P83 FormalLt (169): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 169;
                (* line 768 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ;
                       yySynAttribute . PaTok1 := Itk . ItkVALUEFormalLt ;
                       yySynAttribute . PaTok2 := Itk . ItkVALUEFormalIdListLt ;
                       yySynAttribute . PaByte := ORD ( Dk . DkValueFormal ) ;  
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                                  , DiDeclTok := Itk . ItkVALUEFormalLt
                                  , DiKind := Dk . DkValueFormal
                                  }
                              ) ;
                     
              | 289,145 => (* P84 FormalLt (169): StkRwVALUE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 169;
                (* line 782 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaTok1 := Itk . ItkVALUEFormalIdListLt ;
                       yySynAttribute . PaTok2 := Itk . ItkVALUEFormalLt ;
                       yySynAttribute . PaByte := ORD ( Dk . DkValueFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                                  , DiDeclTok := Itk . ItkVALUEFormalLt
                                  , DiKind := Dk . DkValueFormal
                                  }
                              ) ;
                     
              | 290,146 => (* P85 FormalLt (169): StkRwVAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 169;
                (* line 797 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       yySynAttribute . PaTok1 := Itk . ItkVARFormalIdListLt ;
                       yySynAttribute . PaTok2 := Itk . ItkVARFormalLt ;
                       yySynAttribute . PaByte := ORD ( Dk . DkVarFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkVARFormalIdListLt 
                                  , DiDeclTok := Itk . ItkVARFormalLt
                                  , DiKind := Dk . DkValueFormal
                                  }
                              ) ;
                     
              | 291,144 => (* P86 FormalLt (169): StkRwREADONLY .*)
                DEC (yyStackPtr, 1); yyNonterminal := 169;
                (* line 811 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       yySynAttribute . PaTok1 := Itk . ItkROFormalIdListLt ;
                       yySynAttribute . PaTok2 := Itk . ItkROFormalLt ;
                       yySynAttribute . PaByte := ORD ( Dk . DkROFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiIdListTok := Itk . ItkROFormalIdListLt 
                                  , DiDeclTok := Itk . ItkROFormalLt
                                  , DiKind := Dk . DkROFormal
                                  }
                              ) ;
                     
              | 292,180 => (* P87 Formal (168): FormalLt DeclIdListElems DeclIdListRt FormalType FormalExpr .*)
                DEC (yyStackPtr, 5); yyNonterminal := 168;
                (* line 829 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt (* Decl count. *) ;
                       yySynAttribute . Scan . Position  := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
                         DO 
                           IF VAL ( yyAttributeStack^[yyStackPtr+1] . PaByte , Dk ) = Dk . DkVarFormal   
                           THEN
                             IF NOT yyAttributeStack^[yyStackPtr+4] . PaBool (* Formal type is present (absent). *)
                             THEN
                               FM3Messages . ErrorArr
                                 ( ARRAY OF REFANY 
                                     { " VAR formal must have a type (2.2.8)." } 
                                 , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                                 );
                             END (*IF*) ; 
                             IF yyAttributeStack^[yyStackPtr+5] . PaBool (* Formal expression is present. *) 
                             THEN
                               FM3Messages . ErrorArr
                                 ( ARRAY OF REFANY 
                                     { " VAR formal cannot have a default expression (2.2.8)." }
                                 , yyAttributeStack^[yyStackPtr+5] . Scan . Position
                                 );
                             END (*IF*) ;
                           ELSE (* VALUE or READONLY *)  
                             FM3ParsePass . RequireTypeAndOrValue
                               ( yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                               , yyAttributeStack^[yyStackPtr+4] . PaBool
                               , yyAttributeStack^[yyStackPtr+5] . PaBool
                               )
                           END (*IF*) ;
                
                         IF yyAttributeStack^[yyStackPtr+3] . PaInt > 0 (* Have been skipping this decl. *) 
                         THEN 
                           <* ASSERT FM3ParsePass . StopSkipping ( ) = yyAttributeStack^[yyStackPtr+3] . PaInt *> 
                         ELSE
                           Push_LCP_eCP_zCP_rP 
                             ( WDeclInfo . DiDeclTok 
                             , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+4] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+5] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+5] . Scan . Position 
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                             ) ;
                         END (*WITH*) 
                       END (*IF*) ;
                       <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt *>
                     
              | 293,178 => (* P88 FormalType (170): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 170;
                (* line 880 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LCP_rp
                         ( Itk . ItkFormalTypeLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position ); 
                     
              | 294 => (* P89 FormalType (170): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 170;
                (* line 885 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       Push_LP
                         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
                     
              | 295,179 => (* P90 FormalExpr (171): StkBecomes Expr .*)
                DEC (yyStackPtr, 2); yyNonterminal := 171;
                (* line 893 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Expr is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LCP_rp
                         (  Itk . ItkFormalExprLt, yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position ); 
                     
              | 296 => (* P91 FormalExpr (171): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 171;
                (* line 899 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       Push_LP
                         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
                     
              | 297,169 => (* P92 ResultType (164): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 164;
                (* line 907 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Result type is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LCP_rp
                         (Itk . ItkResultTypeLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position); 
                     
              | 298 => (* P93 ResultType (164): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 164;
                (* line 913 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       Push_LP
                         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
                     
              | 299,141 => (* P94 Raises (165): StkRwRAISES StkRwANY .*)
                DEC (yyStackPtr, 2); yyNonterminal := 165;
                (* line 921 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LCP_rp
                         ( Itk . ItkRaisesANY ,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position); 
                     
              | 300,143 => (* P95 Raises (165): StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace .*)
                DEC (yyStackPtr, 4); yyNonterminal := 165;
                (* line 928 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       MakeListPos ( yySynAttribute , Itk . ItkRaisesSetLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                     
              | 301 => (* P96 Raises (165): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 165;
                (* line 933 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       Push_LP
                         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
                     
              | 302,190 => (* P97 ProcDecl (173): StkRwPROCEDURE StkIdent Signature OptBody .*)
                DEC (yyStackPtr, 4); yyNonterminal := 173;
                (* line 942 of "FM3Parser.lalr" *)
                 VAR LTokLt : Itk . TokTyp; 
                       BEGIN 
                         CASE FM3Units . UnitStackTopRef ^ . UntKind OF 
                         | Uk . UkInterface 
                         , Uk . UkGenInterface  
                         , Uk . UkInstInterface  
                         => IF yyAttributeStack^[yyStackPtr+4] . PaBool 
                            THEN
                              FM3Messages . ErrorArr
                                ( ARRAY OF REFANY 
                                  { " A procedure in an interface must not have a body (2.5.2)." }
                                , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                                );  
                
                            END (*IF*); 
                            LTokLt := Itk . ItkProcNoBodyLt ; 
                         | Uk . UkModule  
                         , Uk . UkGenModule  
                         , Uk . UkInstModule  
                         => IF NOT yyAttributeStack^[yyStackPtr+4] . PaBool 
                            THEN 
                              FM3Messages . ErrorArr
                                ( ARRAY OF REFANY
                                    { " A procedure in a module must have a body (2.5)." } 
                                , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                                ); 
                            END (*IF*); 
                            LTokLt := Itk . ItkProcWBodyLt ; 
                (* TODO: Error recovery.  Insert or remove body. *) 
                         END (*CASE*);
                         Push_LCIri
                           ( LTokLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord, yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom ); 
                       END (*Block*) 
                     
              | 303,149 => (* P98 OptBody (172): StkSemicolon .*)
                DEC (yyStackPtr, 1); yyNonterminal := 172;
                (* line 982 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
                       yySynAttribute . PaConstructNo := FM3Base . AtomNull ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LP ( Itk . ItkProcBodyAbsent , yyAttributeStack^[yyStackPtr+1] . Scan . Position ); 
                     
              | 304,150 => (* P99 OptBody (172): StkEqual ProcBodyScopeLt Block StkIdent StkSemicolon .*)
                DEC (yyStackPtr, 5); yyNonterminal := 172;
                (* line 988 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Procedure has a body. *) := TRUE ; 
                       yySynAttribute . PaConstructNo := yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       Push_LCP_rp
                         ( Itk . ItkProcBodyLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                       FM3ParsePass . ScopeRtL2R ( yyAttributeStack^[yyStackPtr+2] . PaConstructNo ) ; 
                     
              | 305 => (* P100 ProcBodyScopeLt (174): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 174;
                (* line 996 of "FM3Parser.lalr" *)
                 yySynAttribute . PaConstructNo
                         := FM3ParsePass . ScopeLtL2R
                              ( Sk . SkProcBody , yyAttributeStack^[yyStackPtr] . Scan . Position ) ;
                       yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ;
                     
              | 306,139 => (* P101 Expr (152): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 152;

              | 307,140 => (* P102 Expr (152): StkIntLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 152;

              | 308,151 => (* P103 Block (126): BlockLt DeclList StkRwBEGIN Stmts StkRwEND .*)
                DEC (yyStackPtr, 5); yyNonterminal := 126;
                (* line 1010 of "FM3Parser.lalr" *)
                 Push_ECPrP
                         ( Itk . ItkBlockLt , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+5] . Scan . Position
                         ) ;
                     
              | 309 => (* P104 BlockLt (175): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 175;
                (* line 1017 of "FM3Parser.lalr" *)
                 FM3ParsePass . BeginBlock ( ) ;
                       Push_LP ( Itk . ItkBlockLt , FM3Scanner . Attribute . Position ); 
                     
              | 310 => (* P105 DeclList (124): DeclListRecurse .*)
                DEC (yyStackPtr, 1); yyNonterminal := 124;
                (* line 1024 of "FM3Parser.lalr" *)
                 MakeListPos
                         ( yySynAttribute , Itk . ItkDeclListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+1] ) ;
                     
              | 311,197 => (* P106 DeclListRecurse (177): DeclListRecurse Decl .*)
                DEC (yyStackPtr, 2); yyNonterminal := 177;
                (* line 1028 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ; 
              | 312 => (* P107 DeclListRecurse (177): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 177;
                (* line 1030 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ;
                     
              | 313,194 => (* P108 Decl (178): ConstDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 178;

              | 314,195 => (* P109 Decl (178): VarDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 178;

              | 315,193 => (* P110 Decl (178): TypeDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 178;

              | 316,196 => (* P111 Decl (178): ProcDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 178;

              | 317,188 => (* P112 Stmts (176): StmtPlusList OptSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 176;

              | 318,189 => (* P113 StmtPlusList (179): Stmt .*)
                DEC (yyStackPtr, 1); yyNonterminal := 179;

              | 319,186 => (* P114 StmtPlusList (179): StmtPlusList StkSemicolon Stmt .*)
                DEC (yyStackPtr, 3); yyNonterminal := 179;

              | 320 => (* P115 Stmts (176): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 176;
                (* line 1045 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ; 
              | 321,187 => (* P116 Stmt (180): AssignStmt .*)
                DEC (yyStackPtr, 1); yyNonterminal := 180;

              | 322,185 => (* P117 AssignStmt (181): Expr StkBecomes Expr .*)
                DEC (yyStackPtr, 3); yyNonterminal := 181;
                (* line 1052 of "FM3Parser.lalr" *)
                 Push_LCPeCprp
                         ( Itk . ItkBecomesLt
                         , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         ) ;
                     
              END (*CASE*);
             (* End of inserted emantic action code from the .lalr file: **)

               (* Here, a reduction has been partially done.  yyStackPtr has been
                  decremented by the RHS length, yyNonterminal has been set to
                  the LHS NT of the reduced-by production (but has not been
                  pushed), and any Semantic actions have been performed,
                  which will have set yySynAttribute.  Now do a nonterminal
                  read transition on yyStateStack^ [yyStackPtr] (* A state*)
                  and yyNonterminal.
               *) 

               (* SPEC yyState 
                    := Next (Top (), yyNonterminal); nonterminal transition *)
               yyNCombPtr 
                 := LOOPHOLE 
                      ( LOOPHOLE
                          ( yyNBasePtr [yyStateStack^ [yyStackPtr]], INTEGER )
                          + (yyNonterminal-(yyLastTerminal+1))
                            * BYTESIZE (yyNCombType) 
                      , yyNCombTypePtr
                      );
               (*Any action*)yyState := yyNCombPtr^;
               INC (yyStackPtr) (* To push new LHS. *);
               WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
                    (* Tho' already popped by lalr-generated reduce action, this
                       is still present and may have a meaningful Position. *)
               DO
                 yyNTPos := WParsAttr . Scan . Position (* Parser debug.*) ;
                 (* ^Either from LM symbol of RHS, or, if empty RHS, was set to
                    the scanner's position by lalr-generated code. *) 
                 yyOldUnnestCoord := WParsAttr . PaUnnestCoord; 
                 WParsAttr := yySynAttribute;
                 IF yySynAttribute . PaUnnestCoord = ParsAttrNull . PaUnnestCoord 
                 THEN (* Semantic actions didn't set it. *) 
                   IF yyStackPtr = yyPrereduceStackPtr + 1 (* Empty reduction *)
                   THEN WParsAttr . PaUnnestCoord := UnnestCoord ( );
                   ELSE WParsAttr . PaUnnestCoord := yyOldUnnestCoord;
                   END (*IF*);
                 END (*IF*);
                 WParsAttr.Scan.SaTok := yyNonterminal;
              (* ^This requires that tScanAttribute have field 'SaTok'. *)
                 WParsAttr . Scan . Position := yyNTPos (* Parser debug.*) ;
               END (*WITH*);
               yyStateStack^ [yyStackPtr]
                 := yyState (* Not necessarily a state*) (*ParserDebug*);
               IF yyState < yyFirstFinalState (* read nonterminal? *) 
               THEN (* A true state. *)
                 EXIT 
               END (* IF *) ; 
            END (* LOOP *) ;

         ELSE (* Read Terminal. *)
            INC (yyStackPtr);
            yyStateStack^ [yyStackPtr] := yyState (*A state*) (*ParserDebug*);
            WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
            DO
              WParsAttr.Scan := FM3Scanner.Attribute;
              WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*            PushUnnestStk (WParsAttr); *)
            END (*WITH*);
            yyTerminal := FM3Scanner.GetToken ();
             IF yyRepairsInserted >= 0
                (* ^0 => repair's been happening, tho' with no insertions. *)
             THEN (* Finished with a repair. *)
               EmitSyntErrMsg ( );
               yyRepairsInserted := - 1;
             END (*IF*);
         END (* IF *);
      END (* LOOP *) ;
   END FM3Parser;

PROCEDURE AppendToLine ( FragText : TEXT ) =
   BEGIN
      Wr.PutText (yyErrMsgWrT , FragText);
      INC (yyMsgLineLen, Text.Length (FragText))
   END AppendToLine;

PROCEDURE QuoteAndFillOnLine ( FragText : TEXT ) =
   VAR FragLen : INTEGER;
   BEGIN
      FragLen := Text.Length (FragText);
      IF yyMsgLineLen > FM3Messages.IndentLen
         (* There's already a fragment on this line. *) 
         AND yyMsgLineLen + FragLen + 2 (*For quotes.*)
             > FM3Messages.MsgLineLen (* Frag won't fit. *) 
      THEN
        Wr.PutText ( yyErrMsgWrT, FM3Messages.NLIndent);
        yyMsgLineLen := FM3Messages.IndentLen;
      ELSIF yyMsgLineLen > FM3Messages.IndentLen
      THEN 
        Wr.PutChar (yyErrMsgWrT , ' ');
        INC ( yyMsgLineLen );
      END (*IF*);
      Wr.PutChar (yyErrMsgWrT , '\"');
      Wr.PutText (yyErrMsgWrT , FragText);
      Wr.PutText (yyErrMsgWrT , "\" ");
      INC (yyMsgLineLen, FragLen + 2);
   END QuoteAndFillOnLine; 

PROCEDURE ErrorRecovery (
      VAR Terminal      : yySymbolRange ;
          StateStack    : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType
    ) =
   VAR
      ContinueSet       : IntSets . T;
      RestartSet        : IntSets . T;
      Token             : yySymbolRange;
      TokenText         : TEXT;
      TokenArray        : ARRAY [0..127] OF CHAR;
      InfoText          : TEXT;
      TokensSkipped     : BOOLEAN;

      PROCEDURE VisitTok (Elem: IntSets.ElemT) = 
      VAR TokenText : TEXT;
      BEGIN (*VisitTok*)
         TokenName (Elem, (*OUT*) TokenText);
         QuoteAndFillOnLine (TokenText);
      END VisitTok;

   BEGIN (* ErrorRecovery *)
   (* Start the error message. *) 
     yyErrorPos := FM3Scanner.Attribute.Position;
      yyErrMsgWrT := TextWr . New ( );
      TokenName ( Terminal , (*OUT*) TokenText );
      Wr.PutText (yyErrMsgWrT , "Illegal token: \"");
      Wr.PutText (yyErrMsgWrT , TokenText );
      Wr.PutText (yyErrMsgWrT , "\"" );

   (* Append list of the set of expected terminal symbols. *)
      ComputeContinuation
        (StateStack, StackSize, StackPtr, (*OUT*) ContinueSet);
      IF IntSets.Card(ContinueSet) = 0
      THEN (* Shouldn't happen. *) 
      ELSIF IntSets.Card(ContinueSet) = 1
      THEN
         Wr.PutText ( yyErrMsgWrT, ", expecting \"");
         Token := IntSets . ArbitraryMember (ContinueSet);
         TokenName (Token, (*OUT*) TokenText);
         Wr.PutText ( yyErrMsgWrT, TokenText);  
         Wr.PutText ( yyErrMsgWrT, "\"");  
      ELSE (* Expected set is plural. *)   
         Wr.PutText ( yyErrMsgWrT, ", expecting one of:");
         Wr.PutText ( yyErrMsgWrT, FM3Messages.NLIndent );
         yyMsgLineLen := FM3Messages.IndentLen;
         IntSets . ForAllDo (ContinueSet, VisitTok);
      END (*IF*);

      (* Skip terminal symbols until a restart point is reached *)
      ComputeRestartPoints
        (StateStack, StackSize, StackPtr, (*OUT*) RestartSet);
      TokensSkipped := FALSE;
      WHILE NOT IntSets.IsElement (Terminal, RestartSet) DO
       Terminal := FM3Scanner.GetToken ();
        TokensSkipped := TRUE;
      END (*WHILE*);
      (* Append restart point, if any tokens were skipped. *) 
      IF TokensSkipped
      THEN
         Wr.PutText (yyErrMsgWrT, FM3Messages.NLIndent);
         Wr.PutText (yyErrMsgWrT , "Restarting parse at ");
        FM3SharedUtils.PutPosImage ( yyErrMsgWrT , FM3Scanner.Attribute.Position );
      END (*IF*);

      ContinueSet := NIL;
      RestartSet := NIL;
   END ErrorRecovery;

PROCEDURE EmitSyntErrMsg ( ) =
   VAR ErrorMsgText : TEXT;
   BEGIN 
      ErrorMsgText := TextWr.ToText (yyErrMsgWrT);
      FM3Messages.ErrorArr
        ( ARRAY OF REFANY { ErrorMsgText } , yyErrorPos );
      yyErrMsgWrT := NIL; 
   END EmitSyntErrMsg;

(*
   compute the set of terminal symbols that can be accepted (read)
   in a given stack configuration (eventually after reduce actions)
*)

PROCEDURE ComputeContinuation (
          Stack         : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType;
      VAR ContinueSet   : IntSets . T     ) =
   VAR Terminal         : yySymbolRange;
   BEGIN
      ContinueSet:= IntSets . Empty ( );
      FOR Terminal := yyFirstTerminal TO yyLastTerminal DO
         IF IsContinuation (Terminal, Stack, StackSize, StackPtr) THEN
            ContinueSet := IntSets . Include ( ContinueSet , Terminal )
         END;
      END;
   END ComputeContinuation;

(*
   check whether a given terminal symbol can be accepted (read)
   in a certain stack configuration (eventually after reduce actions)
*)

PROCEDURE IsContinuation (
      Terminal          : yySymbolRange ;
      ParseStack        : yyStackType   ;
      StackSize         : INTEGER       ;
      StackPtr          : yyStackPtrType): BOOLEAN =
   VAR
      State             : yyStateRange;
      Nonterminal       : yySymbolRange;
      Stack             : yyStackType;
   BEGIN
      Stack := NEW (yyStackType, StackSize);
      SUBARRAY (Stack^, 0, StackPtr+1 )
        := SUBARRAY (ParseStack^, 0, StackPtr+1 );
      State := Stack^ [StackPtr];
      LOOP
         Stack^ [StackPtr] := State;
         State := Next (State, Terminal);
         IF State = yyNoState THEN
            Stack := NIL;
            RETURN FALSE;
         END;
         IF State <= yyLastReadTermState (* read or read terminal reduce ? *)
         THEN
            Stack := NIL;
            RETURN TRUE;
         END;
         
         LOOP (* reduce *)
            IF State =  yyStopState THEN
               Stack := NIL; 
               RETURN TRUE;
            ELSE 
               DEC (StackPtr, yyLength [State]);
               Nonterminal := yyLeftHandSide [State];
            END;

            State := Next (Stack^ [StackPtr], Nonterminal);
            (* Ensure Stack has room for at least 2 elements. *)
            IF StackPtr >= StackSize THEN
              ExpandStateStack
                (Stack, MAX (NUMBER ( Stack ^ ) * 2 , StackPtr + 2 ) );
              StackSize := NUMBER (Stack^); 
            END;
            INC (StackPtr);
            Stack^ [StackPtr] := State (*ParserDebug*);
            IF State < yyFirstFinalState
            THEN EXIT;
            END; (* read nonterminal ? *)
            State := yyFinalToProd [State]; (* read nonterminal reduce *)
            Stack^ [StackPtr] := State (*ParserDebug*);
         END;
      END;
    END IsContinuation;
(*
   compute a set of terminal symbols that can be used to restart
   parsing in a given stack configuration. we simulate parsing until
   end of file using a suffix program synthesized by the function
   Continuation. All symbols acceptable in the states reached during
   the simulation can be used to restart parsing.
*)

PROCEDURE ComputeRestartPoints (
          ParseStack    : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType;
      VAR RestartSet    : IntSets.T     ) =
   VAR
      Stack             : yyStackType;
      State             : yyStateRange;
      Nonterminal       : yySymbolRange;
      ContinueSet       : IntSets.T;
   BEGIN
      RestartSet := IntSets . Empty ( );
      Stack := NEW (yyStackType, StackSize);
      SUBARRAY (Stack^, 0, StackPtr+1 )
        := SUBARRAY (ParseStack^, 0, StackPtr+1 );
      ContinueSet := IntSets . Empty ( );
      State := Stack^ [StackPtr];

      LOOP
         (* Ensure Stack has room for at least 2 elements. *)
         IF StackPtr >= StackSize THEN
            ExpandStateStack
              (Stack, MAX (NUMBER (Stack ^) * 2 , StackPtr + 2 ) );
            StackSize := NUMBER (Stack^); 
         END;
         Stack^ [StackPtr] := State;
         ComputeContinuation (Stack, StackSize, StackPtr, (*OUT*) ContinueSet);
         RestartSet := IntSets.Union (RestartSet, ContinueSet);
         State := Next (State, yyContinuation [State]);

          IF State >= yyFirstFinalState THEN (* final state ? *)
            IF State <= yyLastReadTermState THEN (* read terminal reduce ? *)
               INC (StackPtr);
               State := yyFinalToProd [State];
               Stack^ [StackPtr] := State (*ParserDebug*);
            END;

            LOOP (* reduce *)
               IF State = yyStopState THEN
                  Stack := NIL;
                  ContinueSet := NIL;
                  RETURN;
               ELSE 
                  DEC (StackPtr, yyLength [State]);
                  Nonterminal := yyLeftHandSide [State];
               END;

               State := Next (Stack^ [StackPtr], Nonterminal);
               INC (StackPtr);
               IF State < yyFirstFinalState
               THEN EXIT;
               END; (* read nonterminal ? *)
               State := yyFinalToProd [State]; (* read nonterminal reduce *)
            END (*LOOP*);
         ELSE (* read *)
            INC (StackPtr);
         END;
      END;
   END ComputeRestartPoints;

(* access the parse table:   Next : State x Symbol -> State *)

PROCEDURE Next
   (State: yyStateRange; Symbol: yySymbolRange)
   : yyStateRange =
   VAR
      TCombPtr          : yyTCombTypePtr;
      NCombPtr          : yyNCombTypePtr;
   BEGIN
      IF Symbol <= yyLastTerminal THEN
         LOOP
            TCombPtr 
              := LOOPHOLE 
                   ( LOOPHOLE (yyTBasePtr [State],INTEGER) 
                     + Symbol * BYTESIZE (yyTCombType)
                   ,yyTCombTypePtr);
            IF TCombPtr^.Check # State THEN
               State := yyDefault [State];
               IF State = yyNoState THEN RETURN yyNoState; END;
            ELSE
               RETURN TCombPtr^.Next;
            END;
         END;
      ELSE
        NCombPtr 
          := LOOPHOLE 
               ( LOOPHOLE (yyNBasePtr [State],INTEGER) 
                 + (Symbol-(yyLastTerminal+1))
                   * BYTESIZE (yyNCombType)
               ,yyNCombTypePtr);
        RETURN NCombPtr^;
      END;
   END Next;
   
  PROCEDURE BeginFM3Parser ()=
   BEGIN
(* line 67 "FM3Parser.lalr" *)
 
      IF NOT yyIsInitialized THEN
         yyIsInitialized := TRUE;
      END;
   END BeginFM3Parser;

(*EXPORTED*)
  PROCEDURE CloseFM3Parser ()=
   BEGIN
(* line 69 "FM3Parser.lalr" *)
 
   END CloseFM3Parser;

BEGIN
    <*ASSERT BYTESIZE (yyTableElmt) = 2 *>
    yyIsInitialized := FALSE;
     ParsTabName := "FM3Parser.Tab";
  END FM3Parser.

