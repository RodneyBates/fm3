
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

(* WARNING: Do not put a lone single quote in a semantic action, e.g.:
            (* Don't do this. *).  Probably applies to double quote too.
            lalr will run to the end of its internal buffer looking
            for the quote's mate and give an unclosed-string error.
*)
            
SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the front of the parser interface. */ 
EXPORT
  {
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3IntToks;
    IMPORT FM3ParsePass;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  {

(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3SrcToks AS Stk;
    IMPORT FM3ParsePass;
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_L , Push_LP , Push_LCr , Push_LCP_rp , Push_LCP_eCP_rP ,
      Push_LCPeCprp , Push_LIP , Push_LIP_rip , Push_EIP , Push_ECIP , 
      Push_ECIP_riP , Push_LCBr , Push_LCIri , Push_LI3 , Push_LI6 , Push_LCeCr ,
      Push_LCIeCri , Push_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global (Notwithstanding "LOCAL",) declarations of the Parser procedure. */ 
LOCAL
  { TYPE Sk = FM3Scopes . ScopeKindTyp ;
    TYPE Dkt = FM3Decls . DeclKindTyp ; 
    TYPE Uk = FM3Units . UnitKindTyp ;

    PROCEDURE Test ( READONLY Attr : tParsAttribute )
    = VAR Debug : INTEGER := 0
    ; BEGIN
        IF Attr . PaInt = FIRST ( INTEGER)
        THEN
          Debug := 19
        END 
      END Test ;

  }

/* Parser module initialization. */ 
BEGIN
  { } 
/* Parser module final cleanup. */ 
CLOSE { }

(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code will use the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)

(* These are probably not used by lalr: 
    TkMinTok                                     =     1

    StkUnknown                                   =     1 (*16_01 *)
    StkBOF                                       =     2 (*16_02 *)
    StkEOF                                       =     3 (*16_03 *)
*)

    (* Reserved words: *) 
    StkRwAND                                     =     5 (*16_05 *)
    StkRwANY                                     =     6 (*16_06 *)
    StkRwARRAY                                   =     7 (*16_07 *)
    StkRwAS                                      =     8 (*16_08 *)
    StkRwBEGIN                                   =     9 (*16_09 *)
    StkRwBITS                                    =    10 (*16_0a *)
    StkRwBRANDED                                 =    11 (*16_0b *)
    StkRwBY                                      =    12 (*16_0c *)
    StkRwCASE                                    =    13 (*16_0d *)
    StkRwCONST                                   =    14 (*16_0e *)
    StkRwDIV                                     =    15 (*16_0f *)
    StkRwDO                                      =    16 (*16_10 *)
    StkRwELSE                                    =    17 (*16_11 *)
    StkRwELSIF                                   =    18 (*16_12 *)
    StkRwEND                                     =    19 (*16_13 *)
    StkRwEVAL                                    =    20 (*16_14 *)
    StkRwEXCEPT                                  =    21 (*16_15 *)
    StkRwEXCEPTION                               =    22 (*16_16 *)
    StkRwEXIT                                    =    23 (*16_17 *)
    StkRwEXPORTS                                 =    24 (*16_18 *)
    StkRwFINALLY                                 =    25 (*16_19 *)
    StkRwFOR                                     =    26 (*16_1a *)
    StkRwFROM                                    =    27 (*16_1b *)
    StkRwGENERIC                                 =    28 (*16_1c *)
    StkRwIF                                      =    29 (*16_1d *)
    StkRwIMPORT                                  =    30 (*16_1e *)
    StkRwIN                                      =    31 (*16_1f *)
    StkRwINTERFACE                               =    32 (*16_20 *)
    StkRwLOCK                                    =    33 (*16_21 *)
    StkRwLOOP                                    =    34 (*16_22 *)
    StkRwMETHODS                                 =    35 (*16_23 *)
    StkRwMOD                                     =    36 (*16_24 *)
    StkRwMODULE                                  =    37 (*16_25 *)
    StkRwNOT                                     =    38 (*16_26 *)
    StkRwOBJECT                                  =    39 (*16_27 *)
    StkRwOF                                      =    40 (*16_28 *)
    StkRwOR                                      =    41 (*16_29 *)
    StkRwOVERRIDES                               =    42 (*16_2a *)
    StkRwPROCEDURE                               =    43 (*16_2b *)
    StkRwRAISE                                   =    44 (*16_2c *)
    StkRwRAISES                                  =    45 (*16_2d *)
    StkRwREADONLY                                =    46 (*16_2e *)
    StkRwRECORD                                  =    47 (*16_2f *)
    StkRwREF                                     =    48 (*16_30 *)
    StkRwREPEAT                                  =    49 (*16_31 *)
    StkRwRETURN                                  =    50 (*16_32 *)
    StkRwREVEAL                                  =    51 (*16_33 *)
    StkRwROOT                                    =    52 (*16_34 *)
    StkRwSET                                     =    53 (*16_35 *)
    StkRwTHEN                                    =    54 (*16_36 *)
    StkRwTO                                      =    55 (*16_37 *)
    StkRwTRY                                     =    56 (*16_38 *)
    StkRwTYPE                                    =    57 (*16_39 *)
    StkRwTYPECASE                                =    58 (*16_3a *)
    StkRwUNSAFE                                  =    59 (*16_3b *)
    StkRwUNTIL                                   =    60 (*16_3c *)
    StkRwUNTRACED                                =    61 (*16_3d *)
    StkRwVALUE                                   =    62 (*16_3e *)
    StkRwVAR                                     =    63 (*16_3f *)
    StkRwWHILE                                   =    64 (*16_c0 00 *)
    StkRwWITH                                    =    65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =    66 (*16_c2 00 *)
    StkDot                                       =    67 (*16_c3 00 *)
    StkEqual                                     =    68 (*16_c4 00 *)
    StkOpenParen                                 =    69 (*16_c5 00 *)
    StkCloseParen                                =    70 (*16_c6 00 *)
    StkComma                                     =    71 (*16_c7 00 *)
    StkColon                                     =    72 (*16_c8 00 *)
    StkSubtype                                   =    73 (*16_c9 00 *)
    StkBecomes                                   =    74 (*16_ca 00 *)
    StkOpenBrace                                 =    75 (*16_cb 00 *)
    StkCloseBrace                                =    76 (*16_cc 00 *)
    StkStroke                                    =    77 (*16_cd 00 *)
    StkArrow                                     =    78 (*16_ce 00 *)
    StkEllipsis                                  =    79 (*16_cf 00 *)
    StkOpenBracket                               =    80 (*16_d0 00 *)
    StkCloseBracket                              =    81 (*16_d1 00 *)
    StkUnequal                                   =    82 (*16_d2 00 *)
    StkLess                                      =    83 (*16_d3 00 *)
    StkGreater                                   =    84 (*16_d4 00 *)
    StkLessEqual                                 =    85 (*16_d5 00 *)
    StkGreaterEqual                              =    86 (*16_d6 00 *)
    StkPlus                                      =    87 (*16_d7 00 *)
    StkMinus                                     =    88 (*16_d8 00 *)
    StkAmpersand                                 =    89 (*16_d9 00 *)
    StkStar                                      =    90 (*16_da 00 *)
    StkSlash                                     =    91 (*16_db 00 *)
    StkDeref                                     =    92 (*16_dc 00 *)
    StkOpenPragma                                =    93 (*16_dd 00 *)
    StkClosePragma                               =    94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =    95 (*16_df 00 *)
    StkIntLit                                    =    96 (*16_e0 00 *)
    StkLongIntLit                                =    97 (*16_e1 00 *)
    StkBasedLit                                  =    98 (*16_e2 00 *)
    StkLongBasedLit                              =    99 (*16_e3 00 *)
    StkRealLit                                   =   100 (*16_e4 00 *)
    StkLongRealLit                               =   101 (*16_e5 00 *)
    StkExtendedLit                               =   102 (*16_e6 00 *)
    StkTextLit                                   =   103 (*16_e7 00 *)
    StkWideTextLit                               =   104 (*16_e8 00 *)
    StkCharLit                                   =   105 (*16_e9 00 *)
    StkWideCharLit                               =   106 (*16_ea 00 *)
    StkLexErrChars                               =   107 (*16_eb 00 *)
    StkReservedId                                =   108 (*16_ec 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *)

(* Reserved identifiers needn't be known to lalr for parsing, so embedded
   semantic actions can refer to them as FM3SrtcToks . Rid*, and no copying
   into here is necessary.
*) 

(* ------------------------------- Productions. ---------------------------- *)

(* NOTE: Modula-3's idea that semicolons can optionally be separators
   or terminators fails to apply to imports, exports, or declarations,
   where they can only be terminators.  But commas are always separators.
   Regardless of the source syntax, in the internal token streams, an
   empty list of any kind has a unique empty-list token, while a nonempty
   list has a left token, separator tokens, and a right token.   
*) 

(* NOTE: regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the attribute of the RHS's
   leftmost token.
*) 


RULE

(* ------------------------- Compilation units ---------------------- *)

   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   UnitId : StkIdent
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position ;

(* IF FM3ParsePass . DeclIdL2R ( Itk . ItkUnitId , $1 )
       THEN $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       ELSE $$ . Scan . SaAtom := FM3Base . AtomNull ;
       END (*IF*) ;
*)
       FM3Units . UnitStackTopRef ^ . UntUnitIdAtom := $$ . Scan . SaAtom ;
     } . 
       
   UnitIdImpliedEXPORTS : UnitId 
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ;
       (* Synthesize EXPORTS <self>. *) 
       Push_LIP ( Itk . ItkExportIdListLt , 1 , $1 . Scan . Position )  ; 
       Push_LIP
         ( Itk . ItkExportIdListLt + Itk . LtToListElem
         , $1 . Scan . SaAtom 
         , $1 . Scan . Position
         ) ;
       Push_LIP ( Itk . ItkExportIdListRt , 1 , $1 . Scan . Position ) ;
     } .

   UnitIdAndExports : UnitId Exports 
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ; } .

   UnitIdAndExports : UnitIdImpliedEXPORTS
     { $$ . Scan . SaAtom := $1 . Scan . SaAtom ; } . 

   InterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInterface ; } .

   ModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkModule ; } .

   GenInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenInterface ; } . 

   GenModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkGenModule ; } . 

   InstInterfaceKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstInterface ; } . 

   InstModuleKind : /*Empty*/ 
       { FM3Units . UnitStackTopRef ^ . UntKind := Uk . UkInstModule ; } . 

   Interface : 
       OptUnsafe StkRwINTERFACE UnitId InterfaceKind StkSemicolon
       Imports BlockDeclList StkRwEND StkIdent StkDot .

   Module :
       OptUnsafe StkRwMODULE UnitIdAndExports ModuleKind StkSemicolon
       Imports Block StkIdent StkDot .

   GenInterface :
       StkRwGENERIC StkRwINTERFACE UnitId GenInterfaceKind GenFormalList
       StkSemicolon Imports BlockDeclList StkRwEND StkIdent StkDot . 

   GenModule :
       StkRwGENERIC StkRwMODULE UnitId GenModuleKind GenFormalList
       StkSemicolon Imports Block StkIdent StkDot . 

   InstInterface :
       OptUnsafe StkRwINTERFACE UnitId InstInterfaceKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   InstModule :
       OptUnsafe StkRwMODULE UnitIdAndExports InstModuleKind StkEqual
       StkIdent GenActualList StkRwEND StkIdent StkDot . 

   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   CaptureCoord : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
     
   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 
 
(* ----------------------------- Identifiers ---------------------------- *)

   IdentRef : StkIdent
     { FM3ParsePass . IdentRefL2R ( $1 ) ; } .

(* List of one or more comma-separated Idents.*)
   IdPlusList : IdentRef 
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma IdentRef
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } .

   (* DeclIdListElems . PaInt > 0 is count of valid Idents. *)
   (* In source syntax, one of these is never empty and always
      comma-separated.  Internally, invalid (reserved or repeated)
      idents may be removed, which could leave it empty.  But then
      the entire declaration is removed after issuing error messages.
   *) 

   DeclIdListElems : StkIdent
     { $$ . PaInt (* Valid Id count. *)
         := ORD
              ( FM3ParsePass . DeclIdL2R
                  ( FM3Decls . TopDeclInfo ( ) . DiIdTok 
                  , FM3Decls . TopDeclInfo ( ) . DiKind
                  , IdAttribute := $1
                  )
              ) ;
     } . 
     
   DeclIdListElems : DeclIdListElems StkComma StkIdent
     { IF FM3ParsePass . DeclIdL2R
            ( FM3Decls . TopDeclInfo ( ) . DiIdTok
            , FM3Decls . TopDeclInfo ( ) . DiKind
            , IdAttribute := $3
            )
       (* ^No seprators here.  It would be kinda silly. *) 
       THEN (* Use this ident. *) $$ . PaInt := $1 . PaInt + 1 ;  
       ELSE $$ . PaInt := $1 . PaInt (* Valid Id count, no increase. *) ; 
       END (*IF*) ;
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma IdentRef
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated qualified Idents. *)
   QualIdStarList : QualIdStarList StkComma QualId
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   QualIdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 
     
(* (Possibly) Qualified ident. *)   
   QualId : StkIdent { FM3ParsePass . IdentRefL2R ( $1 ) ; } .

   QualId : StkIdent StkDot StkIdent
     { FM3ParsePass . QualIdentL2R ( $1 , $3 ) ; } ; .

   TypeId : QualId.

   (* Make ROOT and UNTRACED ROOT look like reserved idents, even though
      they are reserved words in source syntax.
   *) 

   TypeId : StkRwROOT
     { FM3ParsePass . Push_LIP
         ( Itk . ItkReservedId , Stk . RidROOT , $1 . Scan . Position ) ; 
     } . 

   TypeId : StkRwUNTRACED StkRwROOT
     { FM3ParsePass . Push_LIP
         ( Itk . ItkReservedId , Stk . RidUNTRACEDROOT , $1 . Scan . Position ) ; 
     } . 

(*  ----------------------------- Imports -----------------------. *) 

   Imports : ImportsLt ImportsRecurse ImportsRt 
     { $$ . PaInt := $2 . PaInt (* Imported interface Count. *) ;
       $$ . PaLong := $2 . PaLong (* Imported unqualified Ident Count. *) ;
     } .
   ImportsLt : /*Empty*/ { FM3ParsePass . ImportsLt ( ) ; } . 
   ImportsRt : /*Empty*/ { FM3ParsePass . ImportsRt ( ) ; } . 
   ImportsRecurse : ImportsRecurse ImportItem  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt ;
       $$ . PaLong := $1 . PaLong + $2 . PaLong ;
     } .
   ImportsRecurse : /*Empty*/
     { $$ . PaInt := 0; 
       $$ . PaLong := 0L; 
     } . 

   (* IMPORT .. *) 
   ImportItem : StkRwIMPORT ImportIntfPlusList StkSemicolon  
     { $$ . PaInt := $2 . PaInt ;
       $$ . PaLong := 0L ; 
     } .
   ImportIntfPlusList : StkIdent 
     { $$ . PaInt := 1 ;
       FM3ParsePass . Import
         ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       Push_LI3
         ( Itk . ItkImport
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         ) ;
     } . 
   ImportIntfPlusList : ImportIntfPlusList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ;
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3ParsePass . Import
         ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
       Push_LI3
         ( Itk . ItkImport
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

   (* FROM Id IMPORT ... *) 
   ImportItem : FromImportPlusList StkSemicolon 
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaLong := $1 . PaLong ; 
     } .
   FromImportPlusList : StkRwFROM IdentRef StkRwIMPORT StkIdent
     { $$ . PaInt := 1 (* InterfaceCt. *) ;
       $$ . PaLong := 1L ;
       $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
       $$ . Scan . Position := $2 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $2 . Scan . SaAtom
         , $2 . Scan . Position 
         , $4 . Scan . SaAtom
         , $4 . Scan . Position 
         ) ; 
       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $2 . Scan . SaAtom
         , $2 . Scan . Position . Line
         , $2 . Scan . Position . Column
         , $4 . Scan . SaAtom
         , $4 . Scan . Position . Line
         , $4 . Scan . Position . Column
         ) ;
     } . 
   FromImportPlusList : FromImportPlusList StkComma IdentRef
     { $$ . PaInt := 1 ;
       $$ . PaLong := $1 . PaLong + 1L ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $1 . Scan . SaAtom
         , $1 . Scan . Position 
         , $3 . Scan . SaAtom
         , $3 . Scan . Position 
         ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
       Push_LI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

(* IMPORT Id AS Id; *)
(*
   ImportItem : StkRwFROM IdentRef StkRwIMPORT IdPlusList StkSemicolon 
     { $$ . PaInt := 1 ;
       $$ . PaLong := VAL ( $4 . PaInt (* IdPlusList Ct. *) , LONGINT ) ;
       Push_LCIeCri
         ( Itk . ItkImportAsLt
         , $1 . PaUnnestCoord
         , $4 . PaInt
         , $3 . PaUnnestCoord
         );
     } .
*)
(* ------------------------------- Exports ------------------------- . *)

(* Exports.  Possibly absent, in which case construct "EXPORTS Main".
   Otherwise contains at least one ident. Bracket with ItkExportIdList*.
*) 

   ExportsLt : StkRwEXPORTS
     { $$ . Scan . Position := $1 . Scan . Position ;
       (* Although an export list is not exactly a scope, we use the scope
          and DeclInfo mechanisms to check reserved and duplicated idents.
          ScopeRtL2R will handle the legal ones specially.
       *)
       $$ . PaConstructNo 
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkExports , $1 . Scan . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
    (* ^Because ScopeLtL2R Pushes a token, thus changing UnnestCoord. *) 
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkNull
                  , DiIdListTok := Itk . ItkExportIdListLt 
                  , DiIdTok := Itk . ItkExportIdListLt + Itk . LtToListElem
                  , DiIdSepTok := Itk . ItkExportIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkExports 
                  }
              ) ;
     
     } . 

   Exports : ExportsLt DeclIdListElems  
     { IF $2 . PaInt > 0 (* Some valid idents. *)
       THEN 
         MakeListPos (* The identifier list. *) 
           ( $$
           , Itk . ItkExportIdListLt
           , $1 . Scan . Position
           , ElemsAttr := $2
           ) ; 
       END (*IF*) ;
       <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt (* Scope No. *) *>
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ; 
     } .

(* ------------------------ Generic parameters ---------------------- . *)

(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos
         ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* ------------------------- Constant Declarations -------------------- . *) 

   ConstDeclGroup : StkRwCONST ConstDecls .
   ConstDecls : ConstDecl . 
   ConstDecls : ConstDecls ConstDecl . 
   ConstDecl : StkIdent OptConstType StkEqual Expr StkSemicolon .
   OptConstType : StkColon Type
     { $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ; } . 

(* -------------------------- Type Declarations. --------------------- . *)

   TypeRelation : StkEqual { $$ . PaTok1 := Itk . ItkTypeDeclLt ; } .<

   TypeRelation : StkSubtype { $$ . PaTok1 := Itk . ItkSubtypeDeclLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. type decls. *) 

   (* TypeDeclGroup is a list of type declarations all following
      a single occurrence of "TYPE".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "TYPE".  
   *)
   
   TypeDeclGroupLt : StkRwTYPE
     { $$ . Scan . Position := $1 . Scan . Position; } .

   TypeDeclGroup : TypeDeclGroupLt TypeDeclList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ; } . 

   TypeDeclList : /*Empty*/ { $$ . PaInt := 0 ; } .

   TypeDeclList : TypeDeclPlus { $$ . PaInt := $1 . PaInt ; } . 
   
   TypeDeclPlus : TypeDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   TypeDeclPlus : TypeDeclPlus TypeDecl StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       Push_ECIP
         ( Itk . ItkBlockDeclListLt
         , $2 . PaUnnestCoord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

   TypeDeclId : StkIdent
     { IF FM3ParsePass . DeclIdL2R ( Itk . ItkDeclId , Dkt . DkType , $1 ) 
       THEN (* Valid Id, count and use it. *)
         $$ . PaInt := 1 (* Decl count. *) 
       ELSE $$ . PaInt := - FM3ParsePass . StartSkipping ( )
                      (* <0 => it's a skip depth. *)
       END (*IF*) 
     } .

   TypeDecl : TypeDeclId TypeRelation Type  
     { IF $1 . PaInt > 0 
       THEN $$ . PaInt := 1 (* BlockDecl count. *) ; 
         IF FM3ParsePass . SkipDepth = 0 
         THEN 
           Push_LCP_eCP_rP
             ( $2 . PaTok1 
             , $1 . PaUnnestCoord
             , $1 . Scan . Position
             , $2 . PaUnnestCoord
             , $2 . Scan . Position
             , $1 . Scan . Position 
             ) ;
         END (*IF*) 
       ELSE
         $$ . PaInt := 0 (* BlockDecl count. *) ; 
         <* ASSERT $1 . PaInt (* Skipping depth *)
                   = - FM3ParsePass . StopSkipping ( )
         *>
       END (*IF*) ;
     } . 

(* ----------------------------- Revelations ---------------------------- *) 

   RevelationRelation : StkEqual { $$ . PaTok1 := Itk . ItkFullRevealLt ; } .

   RevelationRelation : StkSubtype { $$ . PaTok1 := Itk . ItkPartialRevealLt ; } . 

   (* PaInt is declaration count of nearly every NT Re. revelations. *) 

   (* RevelationGroup is a list of revelations all following
      a single occurrence of "REVEAL".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "REVEAL".  
   *)
   
   RevelationGroupLt : StkRwREVEAL
     {  $$. Scan . Position := $1 . Scan . Position  } .

   RevelationGroup : RevelationGroupLt RevelationList
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ; } . 

   RevelationList : /*Empty*/ { $$ . PaInt := 0 ; } .

   RevelationList : RevelationPlus { $$ . PaInt := $1 . PaInt ; } . 
   
   RevelationPlus : Revelation StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   RevelationPlus : RevelationPlus Revelation StkSemicolon
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       Push_ECIP
         ( Itk . ItkBlockDeclListLt
         , $2 . PaUnnestCoord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

   Revelation : TypeId RevelationRelation Type  
     { $$ . PaInt := 1 (* BlockDecl count. *) ;
(* CHECK^ Do we really want to count this as a block decl?  It occupies a space in the
          Blockdecl list,  but does not introduce a new identifier.
*) 
       IF FM3ParsePass . SkipDepth = 0 
       THEN 
         Push_LCP_eCP_rP
           ( $2 . PaTok1 
           , $1 . PaUnnestCoord
           , $1 . Scan . Position
           , $2 . PaUnnestCoord
           , $2 . Scan . Position
           , $1 . Scan . Position 
           ) ;
       END (*IF*) 
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   (* VarDeclGroup, VarDeclList, VarDecl . PaInt is declaration count. *) 

   (* VarDeclGroup is a list of variable declarations all following
      a single occurrence of "VAR".  The parsing removes this grouping
      from the internal token stream, as if every semicolon-terminated
      declaration had its own occurrence of "VAR".  But a comma-separated
      list of identifiers on a single type/expression is preserved.
   *)
   
   VarDeclGroupLt : StkRwVAR
     { $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVarDeclLt
                  , DiIdListTok := Itk . ItkVarDeclIdListLt 
                  , DiIdTok := Itk . ItkVarDeclIdListLt + Itk . LtToListElem
                  , DiIdSepTok := Itk . ItkVarDeclIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVar
                  }
              ) ;
       $$ . Scan . Position := $1 . Scan . Position;
     } .

   VarDeclGroup : VarDeclGroupLt VarDeclList 
      { $$ . PaInt (* Decl count. *) := $2 . PaInt ;
        <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
      } . 

   VarDeclList : /*Empty*/ 
      { $$ . PaInt := 0 ;
        (*Push_LIP_rip
          ( Itk . ItkVarDeclListLt , 0 , FM3Scanner . Attribute . Position ) ;
        *)
      } .

   VarDeclList : VarDeclPlus  
     { $$ . PaInt := $1 . PaInt ; 
       (*FM3ParsePass . MakeListPos
         ( $$
         , Itk . ItkVarDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
       *) 
     } . 
   
   VarDeclPlus : VarDecl StkSemicolon  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   VarDeclPlus : VarDeclPlus VarDecl StkSemicolon 
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $2 . PaInt ;
       Push_ECIP
         ( Itk . ItkBlockDeclListLt
         , $2 . PaUnnestCoord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* Used for variable and field declarations. *)

   VarDecl : VarDeclIds OptDeclType OptDeclValue 
     { VAR LOk := FM3ParsePass . RequireTypeAndOrValue
                    ( $1 . Scan . Position , $2 . PaBool , $3 . PaBool ) ;
       (* ^Check this even if there are no valid ids. *)
       BEGIN 
         IF $1 . PaInt < 0 (* Skipping this decl?  *) 
         THEN (* VarDeclIds calls for skipping the declaration. *)
           $$ . PaInt := 0 (* Contribution to BlockDeclCt. *) ; 
           <* ASSERT FM3ParsePass . StopSkipping ( ) = - $1 . PaInt *> 
         ELSIF FM3ParsePass . SkipDepth > 0
               (* Skipping some containing construct? *)
         THEN (* No output. *) 
         ELSIF NOT LOk 
         THEN (* Everything was empty anyway.  No output. *) 
         ELSE
           $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
           WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
           DO 
             Push_LCP_eCP_zCP_rP (* The declaration itself. *) 
               ( WDeclInfo . DiDeclTok 
               , $1 . PaUnnestCoord
               , $1 . Scan . Position
               , $2 . PaUnnestCoord
               , $2 . Scan . Position
               , $3 . PaUnnestCoord
               , $3 . Scan . Position 
               , $1 . Scan . Position 
              ) ;
           END (*WITH*) 
         END (*IF*)
       END (*Block*) 
     } . 

   (* VarDeclIds.PaInt > 0 is ident count.  < 0 is -skipdepth. *) 
   VarDeclIds : DeclIdListElems 
     { $$ . Scan . Position := $1 . Scan . Position ;

       IF $1 . PaInt = 0 (* No usable idents. *)
       THEN (* Start skipping this decl. *) 
         $$ . PaInt  := - FM3ParsePass . StartSkipping ( ) ;
           (* ^Negative Skipping depth. *)
       ELSE
         $$ . PaInt := $1 . PaInt (* Valid id count. *) ;
         MakeListPos (* The identifier list. *) 
           ( $$
           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
           , $1 . Scan . Position
           , ElemsAttr := $1
           ) ; 
       END (*IF*) ;
     } .

   OptDeclType : StkColon Type 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclType : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 
   OptDeclValue : StkBecomes Expr 
     { $$ . PaBool (* Present. *) := TRUE ;
       $$ . Scan . Position := $1 . Scan . Position ; 
     } . 
   OptDeclValue : /*Empty*/
     { $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position ; 
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type :  TypeId . 

   Type : StkRwREF Type 
     { Push_LCP_rp
         ( Itk . ItkREFDefLt
         , $1 . PaUnnestCoord
         , $1 . Scan . Position 
         ) ;
     } . 

(* -----------------------------Field decl lists ---------------------------- *)

(* Used in both record types and object types. *) 

   FieldDeclList : /*Empty*/
      { Push_LIP_rip
          ( Itk . ItkFieldDeclListLt , 0 , FM3Scanner . Attribute . Position ) ; 
      } .

   FieldDeclList : FieldDeclPlus OptSemicolon 
     { FM3ParsePass . MakeListPos
         ( $$
         , Itk . ItkFieldDeclListLt
         , $1 . Scan . Position
         , $1 (* For element count & Left patch coord. *) 
         ) ;
     } . 
   
   FieldDeclPlus : VarDecl  
     { $$ . PaInt (* Decl count. *) := $1 . PaInt ; } .

   FieldDeclPlus : FieldDeclPlus StkSemicolon VarDecl
     { $$ . PaInt (* Decl count. *):= $1 . PaInt + $3 . PaInt ;
       Push_ECIP
         ( Itk . ItkFieldDeclListLt
         , $2 . PaUnnestCoord 
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } . 

(* ----------------------------- Record Types -------------------------- *)

   RecTypeLt : StkRwRECORD  
     { $$ . PaConstructNo  
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkRec , $1 . Scan . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
       $$ . PaInt (* DeclInfoDepth *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkFieldDeclLt
                  , DiIdListTok := Itk . ItkFieldDeclIdListLt
                  , DiIdTok := Itk . ItkFieldDeclIdListLt + Itk . LtToListElem
                  , DiIdSepTok := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkRecField 
                  }
              ) ;
     } . 
 
   Type : RecTypeLt FieldDeclList StkRwEND
     { FM3ParsePass . Push_LCIP_rip
         ( Itk . ItkRecDefLt
         , $1 . PaUnnestCoord
         , $2 . PaInt (* Count of decls, fields, formals, etc. *) 
         , $1 . Scan . Position
         ) ;
       <* ASSERT FM3Decls . PopDeclInfo ( )
                 = $1 . PaInt (* DeclInfoDepth. *) *> 
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ; 
     } .

(* ------------------ Procedure Types and Signatures ------------------- *)

   Type : StkRwPROCEDURE Signature
     { Push_LCP_rp
         ( Itk . ItkProcTypeLt , $2 . PaUnnestCoord , $1 . Scan . Position ) ;
     } . 

(* Procedure signature (without PROCEDURE or Ident). *) 
   Signature : Formals ResultType Raises
     { VAR LTok : Itk . TokTyp;
       BEGIN
         IF $2 . PaBool (* Has result type *) 
         THEN LTok := Itk . ItkFuncSignatureLt ;
         ELSE LTok := Itk . ItkProcSignatureLt ;
         END (*IF*);
         Push_LCP_rp ( LTok,  $1 . PaUnnestCoord , $1 . Scan . Position );
       END (*Block*) 
     }.

(* List of formal decls. *)

(* Formals, FormalPlus, Formal . PaInt
   is formals count. *)

   Formals : StkOpenParen StkCloseParen /* Empty formals list. */
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := 0 ; 
       FM3ParsePass . ScopeEmpty ( Sk . SkFormals ) ; 
       PushUnnest ( Itk . ItkFormalsListEmpty )
     } .
   Formals : FormalsLt FormalPlus OptSemicolon StkCloseParen
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaInt := $2 . PaInt ; 
       FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ;
       MakeListPos
         ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $2 ) ;
(* FIXME^ different tokens for different formal modes. *) 
     } .
   FormalsLt : StkOpenParen 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaConstructNo 
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkFormals , $1 . Scan . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
    (* ^ScopeLtL2R Pushes a token and changes UnnestCoord. *) 
     } . 
   FormalPlus : FormalPlus StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + $3 . PaInt ;
       Push_ECIP
         ( Itk . ItkFormalsListLt 
         , $2 . PaUnnestCoord 
         , $1 . PaInt 
         , $2 . Scan . Position
         ) ; 
     } .  
   FormalPlus : Formal 
     { $$ . PaInt := $1 . PaInt ; } .

(* Formal parameter modes. *) 
   FormalLt : /*Empty*/
     { $$ . Scan . Position := FM3Scanner . Attribute . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;  
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdTok := Itk . ItkVALUEFormalIdListLt + Itk . LtToListElem
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .
   FormalLt : StkRwVALUE 
     { $$ . Scan . Position := $1 . Scan . Position ;
       $$ . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVALUEFormalLt
                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                  , DiIdTok := Itk . ItkVALUEFormalIdListLt + Itk . LtToListElem
                  , DiIdSepTok
                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .

   FormalLt : StkRwVAR 
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkVARFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkVARFormalLt
                  , DiIdListTok := Itk . ItkVARFormalIdListLt 
                  , DiIdTok := Itk . ItkVARFormalIdListLt + Itk . LtToListElem
                  , DiIdSepTok := Itk . ItkVARFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkVALUEFormal
                  }
              ) ;
     } .
   FormalLt : StkRwREADONLY
     { $$ . Scan . Position := $1 . Scan . Position ; 
       $$ . PaByte := ORD ( Dkt . DkROFormal ) ;
       $$ . PaInt (* DeclInfoDepth after push. *) 
         := FM3Decls . PushDeclInfo
              ( FM3Decls . DeclInfoTyp
                  { DiDeclTok := Itk . ItkROFormalLt
                  , DiIdListTok := Itk . ItkROFormalIdListLt 
                  , DiIdTok := Itk . ItkROFormalIdListLt + Itk . LtToListElem
                  , DiIdSepTok := Itk . ItkROFormalIdListLt + Itk . LtToListSep
                  , DiKind := Dkt . DkROFormal
                  }
              ) ;
     } .

(* Formal is a formal declaration with PaInt valid ids. *)

   Formal : FormalLt FormalIds FormalType FormalExpr
     { $$ . Scan . Position := $1 . Scan . Position ; 
       WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
       DO (* Do these checks  even if no valid ids. *)
         VAR LOk := TRUE ; 
         BEGIN 
           IF VAL ( $1 . PaByte , Dkt ) = Dkt . DkVARFormal   
           THEN
             IF NOT $3 . PaBool (* Formal type is present (absent?). *)
             THEN
               FM3Messages . ErrorArr
                 ( ARRAY OF REFANY 
                     { " VAR formal must have a type (2.2.8)." } 
                 , $2 . Scan . Position
                 ) ;
               LOk := FALSE ; 
(* FIXME: Arrange to skip the FormalExpr, if any. *) 
             END (*IF*) ; 
             IF $4 . PaBool (* Formal expression is present? *) 
             THEN
               FM3Messages . ErrorArr
                 ( ARRAY OF REFANY 
                     { " VAR formal cannot have a default expression (2.2.8)." }
                 , $4 . Scan . Position
                 ) ;
               LOk := FALSE ; 
(* FIXME: Arrange to skip the FormalExpr, if any. *) 
             END (*IF*) ;
           ELSE (* VALUE or READONLY *)  
             LOk := FM3ParsePass . RequireTypeAndOrValue
                      ( $2 . Scan . Position , $3 . PaBool , $4 . PaBool )
           END (*IF*) ;

           IF $2 . PaInt < 0 (* FormalIds calls for skipping the decl? *)
           THEN 
             $$ . PaInt := 0 ;
             <* ASSERT FM3ParsePass . StopSkipping ( ) = - $2 . PaInt *>
           ELSIF FM3ParsePass . SkipDepth > 0
                 (* Skipping some containing construct? *)
           THEN (* No output. *) 
             $$ . PaInt := 0 ;
           ELSIF NOT LOk 
           THEN (* Everything was empty anyway.  No output. *) 
             $$ . PaInt := 0 ;
           ELSE 
             $$ .PaInt := $2 . PaInt (* Valid Id count. *) ;  
             Push_LCP_eCP_zCP_rP 
               ( WDeclInfo . DiDeclTok 
               , $1 . PaUnnestCoord
               , $2 . Scan . Position
               , $3 . PaUnnestCoord
               , $3 . Scan . Position
               , $4 . PaUnnestCoord
               , $4 . Scan . Position 
               , $1 . Scan . Position 
               ) ;
           END (*WITH*) 
         END (*IF*) ;
         <* ASSERT FM3Decls . PopDeclInfo ( ) = $1 . PaInt *>
       END (*Block*) 
     } .

   (* FormalIds.PaInt > 0 is ident count.  < 0 is -skipdepth. *) 
   FormalIds : DeclIdListElems 
     { $$ . Scan . Position  := $1 . Scan . Position ; 
       IF $1 . PaInt = 0 (* No valid ids. *)
       THEN (* Start skipping this formal. *) 
         $$ . PaInt (* Negative Skipping depth. *) 
           := - FM3ParsePass . StartSkipping ( ) ;
       ELSE
         $$ .PaInt := $1 . PaInt (* Valid Id Ct. *) ; 
         MakeListPos
           ( $$
           , FM3Decls . TopDeclInfo ( ) . DiIdListTok
           , $1 . Scan . Position
           , ElemsAttr := $1
           ) ; 
       END (*IF*) ;
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . PaBool (* Type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position;
(* This looks redundant to Itk<mode>FormalType & Itk<mode>FormalVal,
   which already bracket the type of a formal. 
       Push_LCP_rp
         ( Itk . ItkFormalTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
*) 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
(* This looks redundant to Itk<mode>FormalVal & Itk<mode>FormalRt,
   which already bracket the type of a formal. 
       Push_LCP_rp
         (  Itk . ItkFormalExprLt, $1 . PaUnnestCoord , $1 . Scan . Position );
*) 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature result type. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         (Itk . ItkResultTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ; 
     } .

(* Signature RAISES. *) 
   Raises : StkRwRAISES StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkRaisesANY ,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position , $2 ) ;
     } . 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_LP
         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------------ Procedures ------------------------------ *)

   ProcDecl : StkRwPROCEDURE StkIdent Signature OptBody 
     { VAR LTokLt : Itk . TokTyp; 
       BEGIN 
         CASE FM3Units . UnitStackTopRef ^ . UntKind OF 
         | Uk . UkInterface 
         , Uk . UkGenInterface  
         , Uk . UkInstInterface  
         => IF $4 . PaBool 
            THEN
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY 
                  { " A procedure in an interface must not have a body (2.5.2)." }
                , $4 . Scan . Position
                );  

            END (*IF*); 
            LTokLt := Itk . ItkProcNoBodyLt ; 
         | Uk . UkModule  
         , Uk . UkGenModule  
         , Uk . UkInstModule  
         => IF NOT $4 . PaBool 
            THEN 
              FM3Messages . ErrorArr
                ( ARRAY OF REFANY
                    { " A procedure in a module must have a body (2.5)." } 
                , $4 . Scan . Position
                ); 
            END (*IF*); 
            LTokLt := Itk . ItkProcWBodyLt ; 
(* TODO: Error recovery.  Insert or remove body. *) 
         END (*CASE*);
         Push_LCIri ( LTokLt,  $1 . PaUnnestCoord, $2 . Scan . SaAtom ); 
       END (*Block*) 
     } . 

(*
   OptBody : OptBodyAbsent .  
   OptBody : OptBodyPresent .
*)
   OptBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       $$ . PaConstructNo := FM3Base . AtomNull ; 
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LP ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } . 
   OptBody : StkEqual ProcBodyScopeLt Block StkIdent StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := TRUE ; 
       $$ . PaConstructNo := $4 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_LCP_rp
         ( Itk . ItkProcBodyLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
       FM3ParsePass . ScopeRtL2R ( $2 . PaConstructNo ) ; 
     } .
   ProcBodyScopeLt : /* Empty */
     { $$ . PaConstructNo
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkProcBody , FM3Scanner . Attribute . Position ) ;
       $$ . PaUnnestCoord := UnnestCoord ( ) ;
    (* ^ScopeLtL2R Pushes a token and changes UnnestCoord. *) 
     } .

(* ---------------------------- Expressions ---------------------------- *)

   Expr: IdentRef . 

   Expr: StkIntLit .

   Expr : Expr StkDeref . 

(* ------------------------------ Blocks ------------------------------- *)


   BlockLt : /*EMPTY*/
     { $$ . PaConstructNo
         := FM3ParsePass . ScopeLtL2R
              ( Sk . SkBlock , FM3Scanner . Attribute . Position ) ;
       Push_LIP
         ( Itk . ItkBlockLt
         , $$ . PaConstructNo
         , FM3Scanner . Attribute . Position
         ); 
     } .

   Block : BlockLt BlockDeclList StkRwBEGIN StmtList StkRwEND
     { FM3ParsePass . ScopeRtL2R ( $1 . PaConstructNo ) ; 
       Push_ECIP_riP
         ( Itk . ItkBlockLt
         , $3 . PaUnnestCoord
         , $1 . PaConstructNo 
         , $3 . Scan . Position
         , $1 . Scan . Position
         ) ;
     } .
     
(* ------------------------ Block declarations ------------------------- *)

   BlockDecl : ConstDeclGroup { $$ . PaInt := $1 . PaInt ; } .
   BlockDecl : TypeDeclGroup { $$ . PaInt := $1 . PaInt ; } . 
   BlockDecl : ExceptDeclGroup { $$ . PaInt := $1 . PaInt ; } . 
   BlockDecl : VarDeclGroup { $$ . PaInt := $1 . PaInt ; } . 
   BlockDecl : ProcDecl { $$ . PaInt := 1 ; } .
   BlockDecl : RevelationGroup { $$ . PaInt := $1 . PaInt ; } . 
 
   (* A block declaration always includes a terminating semicolon in the
      source syntax, but we emit only Itk _separators_. *)

   BlockDeclList : /*Empty*/
     { Push_LIP_rip
         ( Itk . ItkBlockDeclListLt , 0 , FM3Scanner . Attribute . Position ) ; 
     } .
     
   BlockDeclList : BlockDeclPlus 
     { MakeListPos
         ( $$
         , Itk . ItkBlockDeclListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .
     
   BlockDeclPlus : BlockDecl 
     { $$ . PaInt := $1 . PaInt (* Decl count. *) ; } .

   BlockDeclPlus : BlockDeclPlus BlockDecl  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt (* Decl count. *) ;
       Push_ECIP (* Internal separator. *)
         ( Itk . ItkBlockDeclListLt
         , $2 . PaUnnestCoord
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .

(* ---------------------------- Statements ----------------------------- *)

   StmtList : /*Empty*/
     { Push_LIP_rip
         ( Itk . ItkStmtListLt , 0 , FM3Scanner . Attribute . Position ) ; 
     } .

   StmtList : StmtPlus OptSemicolon 
     { MakeListPos
         ( $$
         , Itk . ItkStmtListLt
         , $1 . Scan . Position
         , $1 (* Used for element count and left patch coordinate. *) 
         ) ;
     } .

   StmtPlus : Stmt { $$ . PaInt := $1 . PaInt (* Stmt count. *) ; } .
     
   StmtPlusList : StmtPlusList StkSemicolon Stmt  
     { $$ . PaInt := $1 . PaInt + 1 (* Stmt count. *) ;
       Push_ECIP (* Internal separator. *)
         ( Itk . ItkStmtListLt
         , $2 . PaUnnestCoord
         , $1 . PaInt
         , $2 . Scan . Position
         ) ; 
     } .
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr
     { Push_LCPeCprp
         ( Itk . ItkBecomesLt
         , $1 . PaUnnestCoord
         , $2 . PaUnnestCoord
         , $2 . Scan . Position
         ) ;
     } . 

(* END of FM3Parser.lalr. *)


