
(* This file was generated by metaprogram lalr,
   with command line:
   ../lib/lalr -M -g -i -t -d -D -k FM3Parser.lalr
*)




  UNSAFE MODULE FM3Parser;

  IMPORT FM3Scanner;

IMPORT Fmt, OSError, Rd, Thread, Text, TextWr, Word, Wr;

IMPORT Positions, Strings, IntSets, System;

IMPORT FM3SharedUtils;


(* -------------------------------------------------------------------------- *)
                   (* Global insertions from the .lalr file: *)

(* line 38 "FM3Parser.lalr" *)


(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023..2024 Rodney M. Bates.                                     *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

    IMPORT FM3Base;
    IMPORT FM3Decls;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3SrcToks AS Stk;
    IMPORT FM3ParsePass;
    IMPORT FM3Extern; 
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_L , Push_LP , Push_LCr , Push_LCP_rp , Push_LCP_eCP_rP ,
      Push_LCPeCprp , Push_LIP , Push_LIP_rip , Push_EIP , Push_ECIP , 
      Push_ECIP_riP , Push_LCBr , Push_LCIri , Push_LI3 , Push_LI6 , Push_LCeCr ,
      Push_LCIeCri , Push_LCP_eCP_zCP_rP , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  

               (* End of global insertions from the .lalr file: *) 
(* -------------------------------------------------------------------------- *)

CONST
   yyInitStackSize      = 100;
   yyStackExpansionFactor = 2.0;
   yyNoState            = 0;

(* -------------------------------------------------------------------------- *)
                        (* Lalr-generated constants: *) 

   yyFirstTerminal          = 0;
   yyLastTerminal           = 107;
   yyFirstSymbol            = 0;
   yyLastSymbol             = 224;
   yyTableMax               = 413;
   yyNTableMax              = 535;
   yyFirstReadState         = 1;
   yyLastReadState          = 144;
   yyFirstReadTermState             = 145;
   yyLastReadTermState              = 214;
   yyLastReadNontermState           = 280;
   yyFirstReduceState               = 281;
   yyLastReduceState                = 469;
   yyStartState             = 1;
   yyStopState              = 281;

                    (*  End of lalr-generated constants: *) 
(* -------------------------------------------------------------------------- *)

TYPE
   M2SHORTCARD = [ 0 .. 16_FFFF ];
   yyTableElmt = M2SHORTCARD;
   
CONST yyTableElmtBits = BITSIZE ( yyTableElmt );

   (* The conversion to Modula-3 is very fragile, in part due to the
      use of unsafe address arithmetic.
      On the one hand, some types, in some contexts, need to be
      subranges (particularly, as fixed array subscript types),
      and other times, need to have the same size as in Modula-2, to avoid
      undermining various unsafe address arithmetic.  Modula-3 infers
      its own sizes from subranges, except for fields and elements when
      BITS FOR is used.  But assignments involving scalars with BITS FOR
      types present problems and even CM3 code generator failures.

      So if it is a BITS FOR type, its name ends in "Packed", otherwise
      not, the relevant ones ending in "Range".

      Additionally, CM3 has code generator failures assigning between two
      BITS FOR types, at times.  Actual cases where this has happened are
      replaced by two-step copies with an intermediate, unpacked temporary.
  
      These BITS FOR types must occupy exactly a Modula2-SHORTCARD, when used
      as elements or fields, but must their have subrange bounds when
      used as array subscript types. There a few places where a scalar
      of one of these also must occupy exactly a Modula2-SHORTCARD. 
   *)
CONST
   yyFirstFinalState    = yyFirstReadTermState;
   (* ^Any action that does a reduce, i.e., readTermReduce, readNTReduce,
       or simple Reduce.  These are are actions, not true item-set states.
   *) 
   yyLastState          = yyLastReduceState;

TYPE
   yyTCombRangePacked      = BITS yyTableElmtBits FOR [0 .. yyTableMax];
   yyNCombRangePacked      = BITS yyTableElmtBits
                             FOR [yyLastTerminal + 1 .. yyNTableMax];
   yyStateRange            = [0 .. yyLastState];
   yyStateRangePacked      = BITS yyTableElmtBits FOR yyStateRange;
   yyReadRange             = [yyFirstReadState .. yyLastReadState];
   yyReadRangePacked       = BITS yyTableElmtBits FOR yyReadRange;
   yyReadReduceRangePacked = BITS yyTableElmtBits
                             FOR [yyFirstReadTermState .. yyLastReadNontermState];
   yyReduceRangePacked     = BITS yyTableElmtBits
                             FOR [yyFirstReduceState .. yyLastReduceState];
   yySymbolRange           = [yyFirstSymbol .. yyLastSymbol];
   yySymbolRangePacked     = BITS yyTableElmtBits FOR yySymbolRange;
   yyTCombType          = RECORD Check, Next: yyStateRangePacked; END;
   yyNCombType          = yyStateRangePacked;
   yyTCombTypePtr       = UNTRACED BRANDED REF  yyTCombType;
   yyNCombTypePtr       = UNTRACED BRANDED REF  yyNCombType;
   yyStackPtrType       = BITS yyTableElmtBits FOR yyTableElmt;
   yyStackType          = REF  ARRAY OF yyStateRangePacked;
   yyAttributeStackType = REF  ARRAY OF tParsAttribute;

VAR
   yyTBasePtr
     (* Subscripted by a state-number action, used in combination
        with a terminal to find the new action after shifting
        the terminal in this state.
     *) 
     := ARRAY [0 .. yyLastReadState] OF yyTCombTypePtr
         {
           (*   0*) ADR (yyTComb [   0]) , (*   1*) ADR (yyTComb [   0])
         , (*   2*) ADR (yyTComb [   1]) , (*   3*) ADR (yyTComb [   0])
         , (*   4*) ADR (yyTComb [   0]) , (*   5*) ADR (yyTComb [   0])
         , (*   6*) ADR (yyTComb [   2]) , (*   7*) ADR (yyTComb [   1])
         , (*   8*) ADR (yyTComb [   2]) , (*   9*) ADR (yyTComb [   0])
         , (*  10*) ADR (yyTComb [   0]) , (*  11*) ADR (yyTComb [   0])
         , (*  12*) ADR (yyTComb [  22]) , (*  13*) ADR (yyTComb [   0])
         , (*  14*) ADR (yyTComb [   5]) , (*  15*) ADR (yyTComb [   3])
         , (*  16*) ADR (yyTComb [   4]) , (*  17*) ADR (yyTComb [   1])
         , (*  18*) ADR (yyTComb [   5]) , (*  19*) ADR (yyTComb [   3])
         , (*  20*) ADR (yyTComb [   0]) , (*  21*) ADR (yyTComb [   6])
         , (*  22*) ADR (yyTComb [   0]) , (*  23*) ADR (yyTComb [   0])
         , (*  24*) ADR (yyTComb [   0]) , (*  25*) ADR (yyTComb [   7])
         , (*  26*) ADR (yyTComb [   1]) , (*  27*) ADR (yyTComb [   8])
         , (*  28*) ADR (yyTComb [   4]) , (*  29*) ADR (yyTComb [   0])
         , (*  30*) ADR (yyTComb [   9]) , (*  31*) ADR (yyTComb [   0])
         , (*  32*) ADR (yyTComb [  14]) , (*  33*) ADR (yyTComb [  12])
         , (*  34*) ADR (yyTComb [   0]) , (*  35*) ADR (yyTComb [  10])
         , (*  36*) ADR (yyTComb [   9]) , (*  37*) ADR (yyTComb [   0])
         , (*  38*) ADR (yyTComb [   1]) , (*  39*) ADR (yyTComb [   0])
         , (*  40*) ADR (yyTComb [  45]) , (*  41*) ADR (yyTComb [  11])
         , (*  42*) ADR (yyTComb [   2]) , (*  43*) ADR (yyTComb [  15])
         , (*  44*) ADR (yyTComb [   0]) , (*  45*) ADR (yyTComb [  21])
         , (*  46*) ADR (yyTComb [  15]) , (*  47*) ADR (yyTComb [   3])
         , (*  48*) ADR (yyTComb [ 108]) , (*  49*) ADR (yyTComb [ 111])
         , (*  50*) ADR (yyTComb [  16]) , (*  51*) ADR (yyTComb [  20])
         , (*  52*) ADR (yyTComb [   0]) , (*  53*) ADR (yyTComb [   4])
         , (*  54*) ADR (yyTComb [  14]) , (*  55*) ADR (yyTComb [ 107])
         , (*  56*) ADR (yyTComb [   0]) , (*  57*) ADR (yyTComb [   0])
         , (*  58*) ADR (yyTComb [   3]) , (*  59*) ADR (yyTComb [   5])
         , (*  60*) ADR (yyTComb [   6]) , (*  61*) ADR (yyTComb [  67])
         , (*  62*) ADR (yyTComb [  13]) , (*  63*) ADR (yyTComb [  74])
         , (*  64*) ADR (yyTComb [  95]) , (*  65*) ADR (yyTComb [   0])
         , (*  66*) ADR (yyTComb [  25]) , (*  67*) ADR (yyTComb [   7])
         , (*  68*) ADR (yyTComb [  28]) , (*  69*) ADR (yyTComb [  10])
         , (*  70*) ADR (yyTComb [ 110]) , (*  71*) ADR (yyTComb [  48])
         , (*  72*) ADR (yyTComb [  60]) , (*  73*) ADR (yyTComb [  71])
         , (*  74*) ADR (yyTComb [  15]) , (*  75*) ADR (yyTComb [ 104])
         , (*  76*) ADR (yyTComb [  58]) , (*  77*) ADR (yyTComb [  62])
         , (*  78*) ADR (yyTComb [  39]) , (*  79*) ADR (yyTComb [ 116])
         , (*  80*) ADR (yyTComb [ 119]) , (*  81*) ADR (yyTComb [   0])
         , (*  82*) ADR (yyTComb [  79]) , (*  83*) ADR (yyTComb [   0])
         , (*  84*) ADR (yyTComb [  90]) , (*  85*) ADR (yyTComb [  65])
         , (*  86*) ADR (yyTComb [  75]) , (*  87*) ADR (yyTComb [ 111])
         , (*  88*) ADR (yyTComb [  78]) , (*  89*) ADR (yyTComb [  91])
         , (*  90*) ADR (yyTComb [ 183]) , (*  91*) ADR (yyTComb [ 186])
         , (*  92*) ADR (yyTComb [  92]) , (*  93*) ADR (yyTComb [ 128])
         , (*  94*) ADR (yyTComb [   0]) , (*  95*) ADR (yyTComb [  97])
         , (*  96*) ADR (yyTComb [ 209]) , (*  97*) ADR (yyTComb [   1])
         , (*  98*) ADR (yyTComb [ 130]) , (*  99*) ADR (yyTComb [ 215])
         , (* 100*) ADR (yyTComb [ 222]) , (* 101*) ADR (yyTComb [  98])
         , (* 102*) ADR (yyTComb [ 106]) , (* 103*) ADR (yyTComb [ 250])
         , (* 104*) ADR (yyTComb [ 261]) , (* 105*) ADR (yyTComb [ 117])
         , (* 106*) ADR (yyTComb [ 128]) , (* 107*) ADR (yyTComb [  36])
         , (* 108*) ADR (yyTComb [  27]) , (* 109*) ADR (yyTComb [ 109])
         , (* 110*) ADR (yyTComb [ 152]) , (* 111*) ADR (yyTComb [ 218])
         , (* 112*) ADR (yyTComb [ 125]) , (* 113*) ADR (yyTComb [ 156])
         , (* 114*) ADR (yyTComb [ 126]) , (* 115*) ADR (yyTComb [ 129])
         , (* 116*) ADR (yyTComb [ 156]) , (* 117*) ADR (yyTComb [  29])
         , (* 118*) ADR (yyTComb [ 135]) , (* 119*) ADR (yyTComb [ 165])
         , (* 120*) ADR (yyTComb [ 167]) , (* 121*) ADR (yyTComb [   0])
         , (* 122*) ADR (yyTComb [ 239]) , (* 123*) ADR (yyTComb [   2])
         , (* 124*) ADR (yyTComb [  31]) , (* 125*) ADR (yyTComb [  37])
         , (* 126*) ADR (yyTComb [ 140]) , (* 127*) ADR (yyTComb [ 171])
         , (* 128*) ADR (yyTComb [ 170]) , (* 129*) ADR (yyTComb [   0])
         , (* 130*) ADR (yyTComb [ 174]) , (* 131*) ADR (yyTComb [ 180])
         , (* 132*) ADR (yyTComb [ 181]) , (* 133*) ADR (yyTComb [ 278])
         , (* 134*) ADR (yyTComb [ 280]) , (* 135*) ADR (yyTComb [  39])
         , (* 136*) ADR (yyTComb [ 160]) , (* 137*) ADR (yyTComb [ 189])
         , (* 138*) ADR (yyTComb [ 188]) , (* 139*) ADR (yyTComb [ 192])
         , (* 140*) ADR (yyTComb [ 202]) , (* 141*) ADR (yyTComb [ 289])
         , (* 142*) ADR (yyTComb [ 306]) , (* 143*) ADR (yyTComb [ 176])
         , (* 144*) ADR (yyTComb [ 210])
         };
         
   yyNBasePtr
     (* Subscripted by a state-number action, used in combination
        with a nonterminal to find the new action after shifting
        the nonterminal in this state.
     *) 
     := ARRAY [0 .. yyLastReadState] OF yyNCombTypePtr
         {
           (*   0*) ADR (yyNComb [ 108]) , (*   1*) ADR (yyNComb [ 108])
         , (*   2*) ADR (yyNComb [ 108]) , (*   3*) ADR (yyNComb [ 108])
         , (*   4*) ADR (yyNComb [ 109]) , (*   5*) ADR (yyNComb [ 108])
         , (*   6*) ADR (yyNComb [ 108]) , (*   7*) ADR (yyNComb [ 108])
         , (*   8*) ADR (yyNComb [ 108]) , (*   9*) ADR (yyNComb [ 108])
         , (*  10*) ADR (yyNComb [ 108]) , (*  11*) ADR (yyNComb [ 108])
         , (*  12*) ADR (yyNComb [ 108]) , (*  13*) ADR (yyNComb [ 108])
         , (*  14*) ADR (yyNComb [ 108]) , (*  15*) ADR (yyNComb [ 108])
         , (*  16*) ADR (yyNComb [ 108]) , (*  17*) ADR (yyNComb [ 108])
         , (*  18*) ADR (yyNComb [ 108]) , (*  19*) ADR (yyNComb [ 108])
         , (*  20*) ADR (yyNComb [ 109]) , (*  21*) ADR (yyNComb [ 108])
         , (*  22*) ADR (yyNComb [ 108]) , (*  23*) ADR (yyNComb [ 108])
         , (*  24*) ADR (yyNComb [ 108]) , (*  25*) ADR (yyNComb [ 110])
         , (*  26*) ADR (yyNComb [ 108]) , (*  27*) ADR (yyNComb [ 108])
         , (*  28*) ADR (yyNComb [ 108]) , (*  29*) ADR (yyNComb [ 108])
         , (*  30*) ADR (yyNComb [ 108]) , (*  31*) ADR (yyNComb [ 108])
         , (*  32*) ADR (yyNComb [ 108]) , (*  33*) ADR (yyNComb [ 108])
         , (*  34*) ADR (yyNComb [ 108]) , (*  35*) ADR (yyNComb [ 108])
         , (*  36*) ADR (yyNComb [ 108]) , (*  37*) ADR (yyNComb [ 116])
         , (*  38*) ADR (yyNComb [ 108]) , (*  39*) ADR (yyNComb [ 134])
         , (*  40*) ADR (yyNComb [ 108]) , (*  41*) ADR (yyNComb [ 108])
         , (*  42*) ADR (yyNComb [ 108]) , (*  43*) ADR (yyNComb [ 108])
         , (*  44*) ADR (yyNComb [ 108]) , (*  45*) ADR (yyNComb [ 108])
         , (*  46*) ADR (yyNComb [ 108]) , (*  47*) ADR (yyNComb [ 123])
         , (*  48*) ADR (yyNComb [ 139]) , (*  49*) ADR (yyNComb [ 109])
         , (*  50*) ADR (yyNComb [ 108]) , (*  51*) ADR (yyNComb [ 114])
         , (*  52*) ADR (yyNComb [ 175]) , (*  53*) ADR (yyNComb [ 108])
         , (*  54*) ADR (yyNComb [ 110]) , (*  55*) ADR (yyNComb [ 111])
         , (*  56*) ADR (yyNComb [ 194]) , (*  57*) ADR (yyNComb [ 249])
         , (*  58*) ADR (yyNComb [ 108]) , (*  59*) ADR (yyNComb [ 108])
         , (*  60*) ADR (yyNComb [ 216]) , (*  61*) ADR (yyNComb [ 108])
         , (*  62*) ADR (yyNComb [ 108]) , (*  63*) ADR (yyNComb [ 115])
         , (*  64*) ADR (yyNComb [ 108]) , (*  65*) ADR (yyNComb [ 139])
         , (*  66*) ADR (yyNComb [ 108]) , (*  67*) ADR (yyNComb [ 108])
         , (*  68*) ADR (yyNComb [ 113]) , (*  69*) ADR (yyNComb [ 123])
         , (*  70*) ADR (yyNComb [ 112]) , (*  71*) ADR (yyNComb [ 108])
         , (*  72*) ADR (yyNComb [ 110]) , (*  73*) ADR (yyNComb [ 108])
         , (*  74*) ADR (yyNComb [ 116]) , (*  75*) ADR (yyNComb [ 133])
         , (*  76*) ADR (yyNComb [ 123]) , (*  77*) ADR (yyNComb [ 123])
         , (*  78*) ADR (yyNComb [ 136]) , (*  79*) ADR (yyNComb [ 108])
         , (*  80*) ADR (yyNComb [ 118]) , (*  81*) ADR (yyNComb [ 268])
         , (*  82*) ADR (yyNComb [ 124]) , (*  83*) ADR (yyNComb [ 144])
         , (*  84*) ADR (yyNComb [ 108]) , (*  85*) ADR (yyNComb [ 108])
         , (*  86*) ADR (yyNComb [ 108]) , (*  87*) ADR (yyNComb [ 147])
         , (*  88*) ADR (yyNComb [ 108]) , (*  89*) ADR (yyNComb [ 108])
         , (*  90*) ADR (yyNComb [ 183]) , (*  91*) ADR (yyNComb [ 139])
         , (*  92*) ADR (yyNComb [ 108]) , (*  93*) ADR (yyNComb [ 130])
         , (*  94*) ADR (yyNComb [ 323]) , (*  95*) ADR (yyNComb [ 108])
         , (*  96*) ADR (yyNComb [ 254]) , (*  97*) ADR (yyNComb [ 108])
         , (*  98*) ADR (yyNComb [ 130]) , (*  99*) ADR (yyNComb [ 342])
         , (* 100*) ADR (yyNComb [ 230]) , (* 101*) ADR (yyNComb [ 108])
         , (* 102*) ADR (yyNComb [ 108]) , (* 103*) ADR (yyNComb [ 381])
         , (* 104*) ADR (yyNComb [ 268]) , (* 105*) ADR (yyNComb [ 108])
         , (* 106*) ADR (yyNComb [ 108]) , (* 107*) ADR (yyNComb [ 327])
         , (* 108*) ADR (yyNComb [ 108]) , (* 109*) ADR (yyNComb [ 108])
         , (* 110*) ADR (yyNComb [ 108]) , (* 111*) ADR (yyNComb [ 108])
         , (* 112*) ADR (yyNComb [ 110]) , (* 113*) ADR (yyNComb [ 108])
         , (* 114*) ADR (yyNComb [ 108]) , (* 115*) ADR (yyNComb [ 108])
         , (* 116*) ADR (yyNComb [ 114]) , (* 117*) ADR (yyNComb [ 108])
         , (* 118*) ADR (yyNComb [ 108]) , (* 119*) ADR (yyNComb [ 108])
         , (* 120*) ADR (yyNComb [ 108]) , (* 121*) ADR (yyNComb [ 191])
         , (* 122*) ADR (yyNComb [ 413]) , (* 123*) ADR (yyNComb [ 108])
         , (* 124*) ADR (yyNComb [ 419]) , (* 125*) ADR (yyNComb [ 108])
         , (* 126*) ADR (yyNComb [ 108]) , (* 127*) ADR (yyNComb [ 108])
         , (* 128*) ADR (yyNComb [ 108]) , (* 129*) ADR (yyNComb [ 108])
         , (* 130*) ADR (yyNComb [ 160]) , (* 131*) ADR (yyNComb [ 108])
         , (* 132*) ADR (yyNComb [ 108]) , (* 133*) ADR (yyNComb [ 273])
         , (* 134*) ADR (yyNComb [ 419]) , (* 135*) ADR (yyNComb [ 108])
         , (* 136*) ADR (yyNComb [ 108]) , (* 137*) ADR (yyNComb [ 108])
         , (* 138*) ADR (yyNComb [ 108]) , (* 139*) ADR (yyNComb [ 171])
         , (* 140*) ADR (yyNComb [ 108]) , (* 141*) ADR (yyNComb [ 274])
         , (* 142*) ADR (yyNComb [ 207]) , (* 143*) ADR (yyNComb [ 108])
         , (* 144*) ADR (yyNComb [ 108])
         };
         
   yyDefault
     := ARRAY [0 .. yyLastReadState] OF [ 0 .. yyLastReadState ]
         {
           (*   0*)    0 , (*   1*)    0 , (*   2*)    0 , (*   3*)    4
         , (*   4*)    0 , (*   5*)    0 , (*   6*)    0 , (*   7*)    0
         , (*   8*)    0 , (*   9*)    0 , (*  10*)  133 , (*  11*)    0
         , (*  12*)    0 , (*  13*)   25 , (*  14*)    0 , (*  15*)    0
         , (*  16*)    0 , (*  17*)    0 , (*  18*)    0 , (*  19*)    0
         , (*  20*)   25 , (*  21*)    0 , (*  22*)  116 , (*  23*)  130
         , (*  24*)  131 , (*  25*)    0 , (*  26*)    0 , (*  27*)    0
         , (*  28*)    0 , (*  29*)  134 , (*  30*)    0 , (*  31*)   54
         , (*  32*)    0 , (*  33*)    0 , (*  34*)  142 , (*  35*)    0
         , (*  36*)    0 , (*  37*)  122 , (*  38*)    0 , (*  39*)  124
         , (*  40*)    0 , (*  41*)    0 , (*  42*)    0 , (*  43*)    0
         , (*  44*)   87 , (*  45*)   88 , (*  46*)   68 , (*  47*)   87
         , (*  48*)   49 , (*  49*)    0 , (*  50*)    0 , (*  51*)    0
         , (*  52*)   99 , (*  53*)    0 , (*  54*)    0 , (*  55*)    0
         , (*  56*)   99 , (*  57*)   99 , (*  58*)   97 , (*  59*)    0
         , (*  60*)   78 , (*  61*)    0 , (*  62*)    0 , (*  63*)    0
         , (*  64*)    0 , (*  65*)   87 , (*  66*)   88 , (*  67*)    0
         , (*  68*)    0 , (*  69*)   78 , (*  70*)    0 , (*  71*)    0
         , (*  72*)    0 , (*  73*)    0 , (*  74*)    0 , (*  75*)    0
         , (*  76*)    0 , (*  77*)   75 , (*  78*)    0 , (*  79*)    0
         , (*  80*)    0 , (*  81*)   99 , (*  82*)    0 , (*  83*)   87
         , (*  84*)   88 , (*  85*)    0 , (*  86*)    0 , (*  87*)   74
         , (*  88*)    0 , (*  89*)    0 , (*  90*)   91 , (*  91*)    0
         , (*  92*)    0 , (*  93*)    0 , (*  94*)   99 , (*  95*)    0
         , (*  96*)  100 , (*  97*)    0 , (*  98*)    0 , (*  99*)   74
         , (* 100*)   74 , (* 101*)    0 , (* 102*)    0 , (* 103*)   78
         , (* 104*)   78 , (* 105*)    0 , (* 106*)    0 , (* 107*)  134
         , (* 108*)    0 , (* 109*)    0 , (* 110*)    0 , (* 111*)    0
         , (* 112*)    0 , (* 113*)    0 , (* 114*)    0 , (* 115*)    0
         , (* 116*)    0 , (* 117*)    0 , (* 118*)    0 , (* 119*)    0
         , (* 120*)    0 , (* 121*)  141 , (* 122*)    0 , (* 123*)    0
         , (* 124*)   87 , (* 125*)    0 , (* 126*)    0 , (* 127*)    0
         , (* 128*)    0 , (* 129*)  139 , (* 130*)    0 , (* 131*)    0
         , (* 132*)    0 , (* 133*)    0 , (* 134*)    0 , (* 135*)    0
         , (* 136*)    0 , (* 137*)    0 , (* 138*)    0 , (* 139*)    0
         , (* 140*)    0 , (* 141*)    0 , (* 142*)    0 , (* 143*)    0
         , (* 144*)    0
         };
         
   yyTComb
     := ARRAY yyTCombRangePacked OF yyTCombType
         {
           (*   0*) yyTCombType {   5,  281} , (*   1*) yyTCombType {   0,    0}
         , (*   2*) yyTCombType {   0,    0} , (*   3*) yyTCombType {   0,    0}
         , (*   4*) yyTCombType {   0,    0} , (*   5*) yyTCombType {   0,    0}
         , (*   6*) yyTCombType {   0,    0} , (*   7*) yyTCombType {   0,    0}
         , (*   8*) yyTCombType {   0,    0} , (*   9*) yyTCombType {  11,  333}
         , (*  10*) yyTCombType {  38,   39} , (*  11*) yyTCombType { 123,  124}
         , (*  12*) yyTCombType {   0,    0} , (*  13*) yyTCombType {   0,    0}
         , (*  14*) yyTCombType {  11,  333} , (*  15*) yyTCombType {   0,    0}
         , (*  16*) yyTCombType {   0,    0} , (*  17*) yyTCombType {   0,    0}
         , (*  18*) yyTCombType {   0,    0} , (*  19*) yyTCombType {  11,  333}
         , (*  20*) yyTCombType {  26,   27} , (*  21*) yyTCombType {  42,  177}
         , (*  22*) yyTCombType {  47,  313} , (*  23*) yyTCombType {  53,  181}
         , (*  24*) yyTCombType {  59,  184} , (*  25*) yyTCombType {  60,  407}
         , (*  26*) yyTCombType {  67,  188} , (*  27*) yyTCombType {  11,  333}
         , (*  28*) yyTCombType {   1,    2} , (*  29*) yyTCombType {  69,  313}
         , (*  30*) yyTCombType {  11,  333} , (*  31*) yyTCombType {  12,  331}
         , (*  32*) yyTCombType {   1,  311} , (*  33*) yyTCombType {   2,    3}
         , (*  34*) yyTCombType {   6,    7} , (*  35*) yyTCombType {  14,   15}
         , (*  36*) yyTCombType {  12,  331} , (*  37*) yyTCombType {   1,  311}
         , (*  38*) yyTCombType {   2,    4} , (*  39*) yyTCombType {   6,    8}
         , (*  40*) yyTCombType {  45,  469} , (*  41*) yyTCombType {  12,  331}
         , (*  42*) yyTCombType {  58,   59} , (*  43*) yyTCombType {  11,  333}
         , (*  44*) yyTCombType {  66,  385} , (*  45*) yyTCombType { 107,  461}
         , (*  46*) yyTCombType { 108,  109} , (*  47*) yyTCombType {  68,  314}
         , (*  48*) yyTCombType { 117,  118} , (*  49*) yyTCombType {  12,   13}
         , (*  50*) yyTCombType { 124,  464} , (*  51*) yyTCombType {  11,  333}
         , (*  52*) yyTCombType {  12,   16} , (*  53*) yyTCombType {  97,  185}
         , (*  54*) yyTCombType {  71,  189} , (*  55*) yyTCombType { 107,  461}
         , (*  56*) yyTCombType { 125,  126} , (*  57*) yyTCombType {  11,  333}
         , (*  58*) yyTCombType { 135,  136} , (*  59*) yyTCombType {   1,  146}
         , (*  60*) yyTCombType {  32,  416} , (*  61*) yyTCombType {   0,    0}
         , (*  62*) yyTCombType {   0,    0} , (*  63*) yyTCombType {  11,  333}
         , (*  64*) yyTCombType {  40,  324} , (*  65*) yyTCombType {  12,  331}
         , (*  66*) yyTCombType {   9,   10} , (*  67*) yyTCombType {  17,  152}
         , (*  68*) yyTCombType {   9,   21} , (*  69*) yyTCombType {  19,  154}
         , (*  70*) yyTCombType {  24,  155} , (*  71*) yyTCombType {  28,  156}
         , (*  72*) yyTCombType {  17,   18} , (*  73*) yyTCombType {  12,  331}
         , (*  74*) yyTCombType {  19,   20} , (*  75*) yyTCombType {  36,  161}
         , (*  76*) yyTCombType {  32,  416} , (*  77*) yyTCombType {  32,  416}
         , (*  78*) yyTCombType {  33,  159} , (*  79*) yyTCombType {  12,  331}
         , (*  80*) yyTCombType {  33,  160} , (*  81*) yyTCombType {  46,   47}
         , (*  82*) yyTCombType {  50,  180} , (*  83*) yyTCombType {  54,   32}
         , (*  84*) yyTCombType {  32,  158} , (*  85*) yyTCombType {  12,  331}
         , (*  86*) yyTCombType {  61,  382} , (*  87*) yyTCombType {  45,  469}
         , (*  88*) yyTCombType {  51,  384} , (*  89*) yyTCombType {  43,   44}
         , (*  90*) yyTCombType {  40,  324} , (*  91*) yyTCombType {  66,  385}
         , (*  92*) yyTCombType {  51,   52} , (*  93*) yyTCombType {  63,  384}
         , (*  94*) yyTCombType {  68,   69} , (*  95*) yyTCombType {   4,  145}
         , (*  96*) yyTCombType {   7,  147} , (*  97*) yyTCombType {   8,  148}
         , (*  98*) yyTCombType {  15,  150} , (*  99*) yyTCombType {  16,  151}
         , (* 100*) yyTCombType {  18,  153} , (* 101*) yyTCombType {  21,   22}
         , (* 102*) yyTCombType {  25,  149} , (* 103*) yyTCombType {  27,   28}
         , (* 104*) yyTCombType {  30,   31} , (* 105*) yyTCombType {  35,   36}
         , (* 106*) yyTCombType {  41,  165} , (* 107*) yyTCombType {  43,  178}
         , (* 108*) yyTCombType {  62,  187} , (* 109*) yyTCombType {  32,  416}
         , (* 110*) yyTCombType {  74,   40} , (* 111*) yyTCombType {  40,  324}
         , (* 112*) yyTCombType {  40,   41} , (* 113*) yyTCombType {  40,  324}
         , (* 114*) yyTCombType {  64,  386} , (* 115*) yyTCombType {  40,  324}
         , (* 116*) yyTCombType {  40,  324} , (* 117*) yyTCombType {  48,  350}
         , (* 118*) yyTCombType {  40,  324} , (* 119*) yyTCombType {  40,  324}
         , (* 120*) yyTCombType {  49,  351} , (* 121*) yyTCombType {  40,  324}
         , (* 122*) yyTCombType {  48,  350} , (* 123*) yyTCombType {  71,   72}
         , (* 124*) yyTCombType {  76,   77} , (* 125*) yyTCombType {  49,  351}
         , (* 126*) yyTCombType {  55,  431} , (* 127*) yyTCombType {  48,  350}
         , (* 128*) yyTCombType {  76,  314} , (* 129*) yyTCombType {  70,  434}
         , (* 130*) yyTCombType {  49,  351} , (* 131*) yyTCombType {  72,  323}
         , (* 132*) yyTCombType {  77,  313} , (* 133*) yyTCombType {  61,  382}
         , (* 134*) yyTCombType {  78,  186} , (* 135*) yyTCombType {  85,  194}
         , (* 136*) yyTCombType {  72,  323} , (* 137*) yyTCombType {  40,  324}
         , (* 138*) yyTCombType {  61,   62} , (* 139*) yyTCombType {  61,  382}
         , (* 140*) yyTCombType {  63,  384} , (* 141*) yyTCombType {  61,  382}
         , (* 142*) yyTCombType {  73,   74} , (* 143*) yyTCombType {  86,   87}
         , (* 144*) yyTCombType {  88,  355} , (* 145*) yyTCombType {  82,  429}
         , (* 146*) yyTCombType {  63,   52} , (* 147*) yyTCombType {  73,  190}
         , (* 148*) yyTCombType {  63,  384} , (* 149*) yyTCombType {  82,  429}
         , (* 150*) yyTCombType {  75,  191} , (* 151*) yyTCombType {  48,  350}
         , (* 152*) yyTCombType {  55,  431} , (* 153*) yyTCombType {  82,   83}
         , (* 154*) yyTCombType {  49,  351} , (* 155*) yyTCombType {  70,   71}
         , (* 156*) yyTCombType {  84,  428} , (* 157*) yyTCombType {  89,  195}
         , (* 158*) yyTCombType {  92,  197} , (* 159*) yyTCombType {  48,  350}
         , (* 160*) yyTCombType {  84,  428} , (* 161*) yyTCombType {  64,  386}
         , (* 162*) yyTCombType {  49,  351} , (* 163*) yyTCombType {  95,  200}
         , (* 164*) yyTCombType { 101,  203} , (* 165*) yyTCombType {  48,  350}
         , (* 166*) yyTCombType {  75,  192} , (* 167*) yyTCombType {  75,  193}
         , (* 168*) yyTCombType {  49,  351} , (* 169*) yyTCombType {  64,   65}
         , (* 170*) yyTCombType {  88,  178} , (* 171*) yyTCombType {  48,  350}
         , (* 172*) yyTCombType { 102,  204} , (* 173*) yyTCombType {  55,  431}
         , (* 174*) yyTCombType {  49,  351} , (* 175*) yyTCombType {  55,  431}
         , (* 176*) yyTCombType {  70,  434} , (* 177*) yyTCombType {  55,  431}
         , (* 178*) yyTCombType {  70,  434} , (* 179*) yyTCombType {  55,   56}
         , (* 180*) yyTCombType {  70,  434} , (* 181*) yyTCombType {  55,  431}
         , (* 182*) yyTCombType {  79,  425} , (* 183*) yyTCombType { 105,  205}
         , (* 184*) yyTCombType {  70,  434} , (* 185*) yyTCombType {  80,  427}
         , (* 186*) yyTCombType {  79,  425} , (* 187*) yyTCombType {  79,   62}
         , (* 188*) yyTCombType {  79,  425} , (* 189*) yyTCombType {  80,  427}
         , (* 190*) yyTCombType {  79,  425} , (* 191*) yyTCombType {  80,   81}
         , (* 192*) yyTCombType {  90,  360} , (* 193*) yyTCombType {  80,  427}
         , (* 194*) yyTCombType { 106,  206} , (* 195*) yyTCombType {  91,  361}
         , (* 196*) yyTCombType {  93,  198} , (* 197*) yyTCombType {  90,  360}
         , (* 198*) yyTCombType {  98,  201} , (* 199*) yyTCombType {  75,  420}
         , (* 200*) yyTCombType {  91,  361} , (* 201*) yyTCombType {  93,  199}
         , (* 202*) yyTCombType {  90,  360} , (* 203*) yyTCombType {  98,  202}
         , (* 204*) yyTCombType { 109,  110} , (* 205*) yyTCombType {  91,  361}
         , (* 206*) yyTCombType {  49,  179} , (* 207*) yyTCombType {  87,  166}
         , (* 208*) yyTCombType {  87,  167} , (* 209*) yyTCombType {  87,  168}
         , (* 210*) yyTCombType {  87,  169} , (* 211*) yyTCombType {  87,  170}
         , (* 212*) yyTCombType {  87,  171} , (* 213*) yyTCombType {  87,  172}
         , (* 214*) yyTCombType {  87,  173} , (* 215*) yyTCombType {  87,  174}
         , (* 216*) yyTCombType {  87,  175} , (* 217*) yyTCombType {  87,  176}
         , (* 218*) yyTCombType {  96,  370} , (* 219*) yyTCombType { 110,  207}
         , (* 220*) yyTCombType { 112,  208} , (* 221*) yyTCombType { 114,  209}
         , (* 222*) yyTCombType { 113,  341} , (* 223*) yyTCombType {  96,  370}
         , (* 224*) yyTCombType { 115,  116} , (* 225*) yyTCombType { 116,   23}
         , (* 226*) yyTCombType {  90,  360} , (* 227*) yyTCombType { 113,  114}
         , (* 228*) yyTCombType {  96,  370} , (* 229*) yyTCombType {  91,  361}
         , (* 230*) yyTCombType { 118,  119} , (* 231*) yyTCombType { 100,  371}
         , (* 232*) yyTCombType { 119,  210} , (* 233*) yyTCombType { 120,  121}
         , (* 234*) yyTCombType {  90,  360} , (* 235*) yyTCombType { 126,  127}
         , (* 236*) yyTCombType { 100,  371} , (* 237*) yyTCombType {  91,  361}
         , (* 238*) yyTCombType { 127,  211} , (* 239*) yyTCombType { 128,  294}
         , (* 240*) yyTCombType {  90,  360} , (* 241*) yyTCombType { 100,  371}
         , (* 242*) yyTCombType { 111,  112} , (* 243*) yyTCombType {  91,  361}
         , (* 244*) yyTCombType { 130,  321} , (* 245*) yyTCombType { 130,  321}
         , (* 246*) yyTCombType {  90,  360} , (* 247*) yyTCombType { 132,  133}
         , (* 248*) yyTCombType { 122,  460} , (* 249*) yyTCombType {  91,  361}
         , (* 250*) yyTCombType { 131,  212} , (* 251*) yyTCombType { 131,   25}
         , (* 252*) yyTCombType {  96,  370} , (* 253*) yyTCombType { 122,  157}
         , (* 254*) yyTCombType {  99,   53} , (* 255*) yyTCombType { 136,  137}
         , (* 256*) yyTCombType { 137,  213} , (* 257*) yyTCombType { 138,  295}
         , (* 258*) yyTCombType {  99,   54} , (* 259*) yyTCombType { 103,  377}
         , (* 260*) yyTCombType {  96,  370} , (* 261*) yyTCombType { 139,  130}
         , (* 262*) yyTCombType {  99,  182} , (* 263*) yyTCombType {  99,   57}
         , (* 264*) yyTCombType { 103,  377} , (* 265*) yyTCombType { 100,  371}
         , (* 266*) yyTCombType {  96,  370} , (* 267*) yyTCombType {  99,  183}
         , (* 268*) yyTCombType { 140,  141} , (* 269*) yyTCombType { 103,  377}
         , (* 270*) yyTCombType { 104,  378} , (* 271*) yyTCombType { 143,  144}
         , (* 272*) yyTCombType {  96,  370} , (* 273*) yyTCombType { 100,  371}
         , (* 274*) yyTCombType { 100,  183} , (* 275*) yyTCombType { 104,  378}
         , (* 276*) yyTCombType {  99,   58} , (* 277*) yyTCombType { 144,  214}
         , (* 278*) yyTCombType {   0,    0} , (* 279*) yyTCombType { 100,  371}
         , (* 280*) yyTCombType { 104,  378} , (* 281*) yyTCombType {  91,  196}
         , (* 282*) yyTCombType { 122,   30} , (* 283*) yyTCombType { 100,   97}
         , (* 284*) yyTCombType { 111,  340} , (* 285*) yyTCombType { 100,  371}
         , (* 286*) yyTCombType { 111,  115} , (* 287*) yyTCombType {   0,    0}
         , (* 288*) yyTCombType {   0,    0} , (* 289*) yyTCombType {   0,    0}
         , (* 290*) yyTCombType { 122,  162} , (* 291*) yyTCombType {   0,    0}
         , (* 292*) yyTCombType { 133,  330} , (* 293*) yyTCombType { 103,  377}
         , (* 294*) yyTCombType { 134,  157} , (* 295*) yyTCombType {   0,    0}
         , (* 296*) yyTCombType { 122,  163} , (* 297*) yyTCombType { 133,  330}
         , (* 298*) yyTCombType { 141,  330} , (* 299*) yyTCombType { 134,  460}
         , (* 300*) yyTCombType {   0,    0} , (* 301*) yyTCombType { 103,  377}
         , (* 302*) yyTCombType { 122,  164} , (* 303*) yyTCombType { 141,  330}
         , (* 304*) yyTCombType { 104,  378} , (* 305*) yyTCombType { 133,  330}
         , (* 306*) yyTCombType {   0,    0} , (* 307*) yyTCombType { 103,  377}
         , (* 308*) yyTCombType { 133,  330} , (* 309*) yyTCombType {   0,    0}
         , (* 310*) yyTCombType {   0,    0} , (* 311*) yyTCombType {   0,    0}
         , (* 312*) yyTCombType { 104,  378} , (* 313*) yyTCombType { 103,  377}
         , (* 314*) yyTCombType {   0,    0} , (* 315*) yyTCombType { 142,  452}
         , (* 316*) yyTCombType { 141,  330} , (* 317*) yyTCombType {   0,    0}
         , (* 318*) yyTCombType { 104,  378} , (* 319*) yyTCombType { 141,  330}
         , (* 320*) yyTCombType { 142,  452} , (* 321*) yyTCombType { 133,  330}
         , (* 322*) yyTCombType {   0,    0} , (* 323*) yyTCombType { 134,   30}
         , (* 324*) yyTCombType { 104,  378} , (* 325*) yyTCombType {   0,    0}
         , (* 326*) yyTCombType {   0,    0} , (* 327*) yyTCombType {   0,    0}
         , (* 328*) yyTCombType {   0,    0} , (* 329*) yyTCombType { 133,  330}
         , (* 330*) yyTCombType {   0,    0} , (* 331*) yyTCombType { 134,  162}
         , (* 332*) yyTCombType { 141,  330} , (* 333*) yyTCombType {   0,    0}
         , (* 334*) yyTCombType {   0,    0} , (* 335*) yyTCombType { 133,  330}
         , (* 336*) yyTCombType {   0,    0} , (* 337*) yyTCombType { 134,  163}
         , (* 338*) yyTCombType {   0,    0} , (* 339*) yyTCombType {   0,    0}
         , (* 340*) yyTCombType { 141,  330} , (* 341*) yyTCombType { 133,  330}
         , (* 342*) yyTCombType {   0,    0} , (* 343*) yyTCombType { 134,  164}
         , (* 344*) yyTCombType {   0,    0} , (* 345*) yyTCombType {   0,    0}
         , (* 346*) yyTCombType { 141,  330} , (* 347*) yyTCombType {   0,    0}
         , (* 348*) yyTCombType {   0,    0} , (* 349*) yyTCombType { 142,  452}
         , (* 350*) yyTCombType {   0,    0} , (* 351*) yyTCombType {   0,    0}
         , (* 352*) yyTCombType { 141,  330} , (* 353*) yyTCombType {   0,    0}
         , (* 354*) yyTCombType {   0,    0} , (* 355*) yyTCombType {   0,    0}
         , (* 356*) yyTCombType {   0,    0} , (* 357*) yyTCombType { 142,  452}
         , (* 358*) yyTCombType {   0,    0} , (* 359*) yyTCombType {   0,    0}
         , (* 360*) yyTCombType {   0,    0} , (* 361*) yyTCombType {   0,    0}
         , (* 362*) yyTCombType {   0,    0} , (* 363*) yyTCombType { 142,  452}
         , (* 364*) yyTCombType {   0,    0} , (* 365*) yyTCombType {   0,    0}
         , (* 366*) yyTCombType {   0,    0} , (* 367*) yyTCombType {   0,    0}
         , (* 368*) yyTCombType {   0,    0} , (* 369*) yyTCombType { 142,  452}
         , (* 370*) yyTCombType {   0,    0} , (* 371*) yyTCombType {   0,    0}
         , (* 372*) yyTCombType {   0,    0} , (* 373*) yyTCombType {   0,    0}
         , (* 374*) yyTCombType {   0,    0} , (* 375*) yyTCombType {   0,    0}
         , (* 376*) yyTCombType {   0,    0} , (* 377*) yyTCombType {   0,    0}
         , (* 378*) yyTCombType {   0,    0} , (* 379*) yyTCombType {   0,    0}
         , (* 380*) yyTCombType {   0,    0} , (* 381*) yyTCombType {   0,    0}
         , (* 382*) yyTCombType {   0,    0} , (* 383*) yyTCombType {   0,    0}
         , (* 384*) yyTCombType {   0,    0} , (* 385*) yyTCombType {   0,    0}
         , (* 386*) yyTCombType {   0,    0} , (* 387*) yyTCombType {   0,    0}
         , (* 388*) yyTCombType {   0,    0} , (* 389*) yyTCombType {   0,    0}
         , (* 390*) yyTCombType {   0,    0} , (* 391*) yyTCombType {   0,    0}
         , (* 392*) yyTCombType {   0,    0} , (* 393*) yyTCombType {   0,    0}
         , (* 394*) yyTCombType {   0,    0} , (* 395*) yyTCombType {   0,    0}
         , (* 396*) yyTCombType {   0,    0} , (* 397*) yyTCombType {   0,    0}
         , (* 398*) yyTCombType {   0,    0} , (* 399*) yyTCombType {   0,    0}
         , (* 400*) yyTCombType {   0,    0} , (* 401*) yyTCombType {   0,    0}
         , (* 402*) yyTCombType {   0,    0} , (* 403*) yyTCombType {   0,    0}
         , (* 404*) yyTCombType {   0,    0} , (* 405*) yyTCombType {   0,    0}
         , (* 406*) yyTCombType {   0,    0} , (* 407*) yyTCombType {   0,    0}
         , (* 408*) yyTCombType {   0,    0} , (* 409*) yyTCombType {   0,    0}
         , (* 410*) yyTCombType {   0,    0} , (* 411*) yyTCombType {   0,    0}
         , (* 412*) yyTCombType {   0,    0} , (* 413*) yyTCombType {   0,    0}
         };
         
   yyNComb 
     (* This bounds range is arbitrary, unjustified, and confusing.
        It has nothing to do with states, actions, symbols, or anything
        else.  It is just a space for interspersed actions.  Moreover,
        during use, its elements are accessed only by unsafe pointers to
        them, from elements of yyNBasePtr, not by subscripts, for a bit
        of speed.  It would make the most sense to start it at zero, like
        yyTComb.  But that would require care to make consistent changes.
     *) 
     := ARRAY yyNCombRangePacked OF yyNCombType
         {
           (* 108*)  217 , (* 109*)    5 , (* 110*)  218 , (* 111*)  219
         , (* 112*)  220 , (* 113*)  221 , (* 114*)  222 , (* 115*)  215
         , (* 116*)  216 , (* 117*)    0 , (* 118*)  120 , (* 119*)    0
         , (* 120*)    0 , (* 121*)  129 , (* 122*)  139 , (* 123*)    0
         , (* 124*)    0 , (* 125*)    6 , (* 126*)    9 , (* 127*)   26
         , (* 128*)  223 , (* 129*)   29 , (* 130*)  108 , (* 131*)  111
         , (* 132*)  122 , (* 133*)  117 , (* 134*)  128 , (* 135*)  132
         , (* 136*)  138 , (* 137*)   35 , (* 138*)   38 , (* 139*)  232
         , (* 140*)   14 , (* 141*)  226 , (* 142*)  227 , (* 143*)   24
         , (* 144*)  258 , (* 145*)  229 , (* 146*)   73 , (* 147*)   11
         , (* 148*)   12 , (* 149*)  224 , (* 150*)  225 , (* 151*)   17
         , (* 152*)   19 , (* 153*)  260 , (* 154*)   85 , (* 155*)  113
         , (* 156*)   48 , (* 157*)   61 , (* 158*)  267 , (* 159*)   42
         , (* 160*)  229 , (* 161*)   50 , (* 162*)   51 , (* 163*)   45
         , (* 164*)   48 , (* 165*)   90 , (* 166*)  267 , (* 167*)  270
         , (* 168*)   86 , (* 169*)   64 , (* 170*)   79 , (* 171*)  229
         , (* 172*)   96 , (* 173*)   90 , (* 174*)  273 , (* 175*)  270
         , (* 176*)  229 , (* 177*)  103 , (* 178*)   43 , (* 179*)  275
         , (* 180*)   96 , (* 181*)  229 , (* 182*)  273 , (* 183*)  256
         , (* 184*)  229 , (* 185*)  103 , (* 186*)   94 , (* 187*)  275
         , (* 188*)  234 , (* 189*)   43 , (* 190*)   49 , (* 191*)   89
         , (* 192*)   51 , (* 193*)   99 , (* 194*)   66 , (* 195*)  131
         , (* 196*)  257 , (* 197*)   63 , (* 198*)  140 , (* 199*)   84
         , (* 200*)   92 , (* 201*)   93 , (* 202*)   88 , (* 203*)   33
         , (* 204*)   55 , (* 205*)  235 , (* 206*)   55 , (* 207*)   75
         , (* 208*)   70 , (* 209*)   75 , (* 210*)  261 , (* 211*)  280
         , (* 212*)  236 , (* 213*)  237 , (* 214*)  228 , (* 215*)  276
         , (* 216*)   34 , (* 217*)   37 , (* 218*)  277 , (* 219*)  278
         , (* 220*)  107 , (* 221*)  266 , (* 222*)   82 , (* 223*)  276
         , (* 224*)  262 , (* 225*)   78 , (* 226*)  277 , (* 227*)  278
         , (* 228*)  107 , (* 229*)  264 , (* 230*)   11 , (* 231*)  236
         , (* 232*)  237 , (* 233*)   76 , (* 234*)  265 , (* 235*)   78
         , (* 236*)  143 , (* 237*)  230 , (* 238*)  231 , (* 239*)   80
         , (* 240*)  259 , (* 241*)  268 , (* 242*)    0 , (* 243*)   91
         , (* 244*)   95 , (* 245*)   93 , (* 246*)    0 , (* 247*)   46
         , (* 248*)  233 , (* 249*)  231 , (* 250*)   61 , (* 251*)  239
         , (* 252*)  240 , (* 253*)  241 , (* 254*)  242 , (* 255*)  243
         , (* 256*)  244 , (* 257*)  245 , (* 258*)  246 , (* 259*)  247
         , (* 260*)  248 , (* 261*)  249 , (* 262*)  250 , (* 263*)  251
         , (* 264*)  252 , (* 265*)  253 , (* 266*)  254 , (* 267*)  236
         , (* 268*)   98 , (* 269*)   60 , (* 270*)  239 , (* 271*)  240
         , (* 272*)  241 , (* 273*)  242 , (* 274*)  243 , (* 275*)  244
         , (* 276*)  245 , (* 277*)  246 , (* 278*)  247 , (* 279*)  248
         , (* 280*)  249 , (* 281*)  250 , (* 282*)  251 , (* 283*)  252
         , (* 284*)  253 , (* 285*)  254 , (* 286*)  236 , (* 287*)  237
         , (* 288*)   60 , (* 289*)  255 , (* 290*)   63 , (* 291*)  236
         , (* 292*)   98 , (* 293*)  134 , (* 294*)  142 , (* 295*)  238
         , (* 296*)    0 , (* 297*)    0 , (* 298*)  101 , (* 299*)    0
         , (* 300*)    0 , (* 301*)    0 , (* 302*)   61 , (* 303*)    0
         , (* 304*)    0 , (* 305*)  236 , (* 306*)  237 , (* 307*)    0
         , (* 308*)   67 , (* 309*)   68 , (* 310*)    0 , (* 311*)    0
         , (* 312*)   11 , (* 313*)   11 , (* 314*)  263 , (* 315*)    0
         , (* 316*)   37 , (* 317*)    0 , (* 318*)    0 , (* 319*)  272
         , (* 320*)    0 , (* 321*)  100 , (* 322*)  102 , (* 323*)    0
         , (* 324*)    0 , (* 325*)  239 , (* 326*)  240 , (* 327*)  241
         , (* 328*)  242 , (* 329*)  243 , (* 330*)  244 , (* 331*)  245
         , (* 332*)  246 , (* 333*)  247 , (* 334*)  248 , (* 335*)  249
         , (* 336*)  250 , (* 337*)  251 , (* 338*)  252 , (* 339*)  253
         , (* 340*)  254 , (* 341*)  105 , (* 342*)   63 , (* 343*)   60
         , (* 344*)  239 , (* 345*)  240 , (* 346*)  241 , (* 347*)  242
         , (* 348*)  243 , (* 349*)  244 , (* 350*)  245 , (* 351*)  246
         , (* 352*)  247 , (* 353*)  248 , (* 354*)  249 , (* 355*)  250
         , (* 356*)  251 , (* 357*)  252 , (* 358*)  253 , (* 359*)  254
         , (* 360*)  236 , (* 361*)  237 , (* 362*)   60 , (* 363*)    0
         , (* 364*)    0 , (* 365*)    0 , (* 366*)    0 , (* 367*)    0
         , (* 368*)    0 , (* 369*)  269 , (* 370*)    0 , (* 371*)    0
         , (* 372*)    0 , (* 373*)    0 , (* 374*)    0 , (* 375*)   48
         , (* 376*)    0 , (* 377*)  267 , (* 378*)    0 , (* 379*)  236
         , (* 380*)  237 , (* 381*)    0 , (* 382*)    0 , (* 383*)    0
         , (* 384*)   90 , (* 385*)    0 , (* 386*)  270 , (* 387*)    0
         , (* 388*)  271 , (* 389*)    0 , (* 390*)    0 , (* 391*)   96
         , (* 392*)    0 , (* 393*)  273 , (* 394*)    0 , (* 395*)    0
         , (* 396*)  103 , (* 397*)    0 , (* 398*)  275 , (* 399*)  239
         , (* 400*)  240 , (* 401*)  241 , (* 402*)  242 , (* 403*)  243
         , (* 404*)  244 , (* 405*)  245 , (* 406*)  246 , (* 407*)  247
         , (* 408*)  248 , (* 409*)  249 , (* 410*)  250 , (* 411*)  251
         , (* 412*)  252 , (* 413*)  253 , (* 414*)  254 , (* 415*)   61
         , (* 416*)    0 , (* 417*)   60 , (* 418*)  239 , (* 419*)  240
         , (* 420*)  241 , (* 421*)  242 , (* 422*)  243 , (* 423*)  244
         , (* 424*)  245 , (* 425*)  246 , (* 426*)  247 , (* 427*)  248
         , (* 428*)  249 , (* 429*)  250 , (* 430*)  251 , (* 431*)  252
         , (* 432*)  253 , (* 433*)  254 , (* 434*)  276 , (* 435*)  123
         , (* 436*)   60 , (* 437*)  279 , (* 438*)  278 , (* 439*)    0
         , (* 440*)    0 , (* 441*)  135 , (* 442*)    0 , (* 443*)    0
         , (* 444*)  125 , (* 445*)    0 , (* 446*)    0 , (* 447*)    0
         , (* 448*)    0 , (* 449*)    0 , (* 450*)    0 , (* 451*)  274
         , (* 452*)    0 , (* 453*)  104 , (* 454*)  106 , (* 455*)   63
         , (* 456*)  229 , (* 457*)    0 , (* 458*)    0 , (* 459*)    0
         , (* 460*)    0 , (* 461*)   48 , (* 462*)    0 , (* 463*)  267
         , (* 464*)    0 , (* 465*)    0 , (* 466*)    0 , (* 467*)   48
         , (* 468*)    0 , (* 469*)  267 , (* 470*)   90 , (* 471*)    0
         , (* 472*)  270 , (* 473*)    0 , (* 474*)   43 , (* 475*)    0
         , (* 476*)   90 , (* 477*)   96 , (* 478*)  270 , (* 479*)  273
         , (* 480*)    0 , (* 481*)    0 , (* 482*)  103 , (* 483*)   96
         , (* 484*)  275 , (* 485*)  273 , (* 486*)    0 , (* 487*)    0
         , (* 488*)  103 , (* 489*)    0 , (* 490*)  275 , (* 491*)    0
         , (* 492*)    0 , (* 493*)    0 , (* 494*)    0 , (* 495*)    0
         , (* 496*)    0 , (* 497*)    0 , (* 498*)    0 , (* 499*)    0
         , (* 500*)    0 , (* 501*)    0 , (* 502*)    0 , (* 503*)    0
         , (* 504*)    0 , (* 505*)    0 , (* 506*)    0 , (* 507*)    0
         , (* 508*)    0 , (* 509*)    0 , (* 510*)    0 , (* 511*)    0
         , (* 512*)    0 , (* 513*)    0 , (* 514*)    0 , (* 515*)    0
         , (* 516*)    0 , (* 517*)    0 , (* 518*)    0 , (* 519*)    0
         , (* 520*)  276 , (* 521*)    0 , (* 522*)    0 , (* 523*)  277
         , (* 524*)  278 , (* 525*)  107 , (* 526*)  276 , (* 527*)    0
         , (* 528*)    0 , (* 529*)  277 , (* 530*)  278 , (* 531*)  107
         , (* 532*)   46 , (* 533*)  233 , (* 534*)  231 , (* 535*)    0
         };
         
   yyLength
     (* Subscripted by a reduce action, maps to LHS length of the
        production to reduce by. A<a> is a reduce action number.
        P<p> is the correponding production number.
     *)
     := ARRAY yyReduceRangePacked OF yyTableElmt
         {
           (*A 281(P   1)*)    2 , (*A 282(P   2)*)    1 , (*A 283(P   3)*)    1
         , (*A 284(P   4)*)    1 , (*A 285(P   5)*)    1 , (*A 286(P   6)*)    1
         , (*A 287(P   7)*)    1 , (*A 288(P   8)*)    1 , (*A 289(P   9)*)    1
         , (*A 290(P  10)*)    1 , (*A 291(P  11)*)    2 , (*A 292(P  12)*)    0
         , (*A 293(P  13)*)    0 , (*A 294(P  14)*)    0 , (*A 295(P  15)*)    0
         , (*A 296(P  16)*)    0 , (*A 297(P  17)*)    0 , (*A 298(P  18)*)    3
         , (*A 299(P  19)*)    7 , (*A 300(P  20)*)    3 , (*A 301(P  21)*)    5
         , (*A 302(P  22)*)    3 , (*A 303(P  23)*)    7 , (*A 304(P  24)*)    4
         , (*A 305(P  25)*)    7 , (*A 306(P  26)*)    3 , (*A 307(P  27)*)    9
         , (*A 308(P  28)*)    3 , (*A 309(P  29)*)    8 , (*A 310(P  30)*)    1
         , (*A 311(P  31)*)    0 , (*A 312(P  32)*)    0 , (*A 313(P  33)*)    1
         , (*A 314(P  34)*)    0 , (*A 315(P  35)*)    1 , (*A 316(P  36)*)    1
         , (*A 317(P  37)*)    3 , (*A 318(P  38)*)    1 , (*A 319(P  39)*)    3
         , (*A 320(P  40)*)    3 , (*A 321(P  41)*)    0 , (*A 322(P  42)*)    3
         , (*A 323(P  43)*)    0 , (*A 324(P  44)*)    1 , (*A 325(P  45)*)    3
         , (*A 326(P  46)*)    1 , (*A 327(P  47)*)    1 , (*A 328(P  48)*)    2
         , (*A 329(P  49)*)    3 , (*A 330(P  50)*)    0 , (*A 331(P  51)*)    0
         , (*A 332(P  52)*)    2 , (*A 333(P  53)*)    0 , (*A 334(P  54)*)    3
         , (*A 335(P  55)*)    1 , (*A 336(P  56)*)    3 , (*A 337(P  57)*)    2
         , (*A 338(P  58)*)    4 , (*A 339(P  59)*)    3 , (*A 340(P  60)*)    0
         , (*A 341(P  61)*)    2 , (*A 342(P  62)*)    1 , (*A 343(P  63)*)    3
         , (*A 344(P  64)*)    3 , (*A 345(P  65)*)    3 , (*A 346(P  66)*)    2
         , (*A 347(P  67)*)    0 , (*A 348(P  68)*)    1 , (*A 349(P  69)*)    2
         , (*A 350(P  70)*)    0 , (*A 351(P  71)*)    1 , (*A 352(P  72)*)    2
         , (*A 353(P  73)*)    3 , (*A 354(P  74)*)    1 , (*A 355(P  75)*)    4
         , (*A 356(P  76)*)    1 , (*A 357(P  77)*)    1 , (*A 358(P  78)*)    1
         , (*A 359(P  79)*)    2 , (*A 360(P  80)*)    0 , (*A 361(P  81)*)    1
         , (*A 362(P  82)*)    2 , (*A 363(P  83)*)    3 , (*A 364(P  84)*)    1
         , (*A 365(P  85)*)    3 , (*A 366(P  86)*)    1 , (*A 367(P  87)*)    1
         , (*A 368(P  88)*)    1 , (*A 369(P  89)*)    2 , (*A 370(P  90)*)    0
         , (*A 371(P  91)*)    1 , (*A 372(P  92)*)    2 , (*A 373(P  93)*)    3
         , (*A 374(P  94)*)    3 , (*A 375(P  95)*)    1 , (*A 376(P  96)*)    2
         , (*A 377(P  97)*)    0 , (*A 378(P  98)*)    1 , (*A 379(P  99)*)    2
         , (*A 380(P 100)*)    3 , (*A 381(P 101)*)    3 , (*A 382(P 102)*)    1
         , (*A 383(P 103)*)    2 , (*A 384(P 104)*)    0 , (*A 385(P 105)*)    2
         , (*A 386(P 106)*)    0 , (*A 387(P 107)*)    1 , (*A 388(P 108)*)    2
         , (*A 389(P 109)*)    1 , (*A 390(P 110)*)    1 , (*A 391(P 111)*)    1
         , (*A 392(P 112)*)    1 , (*A 393(P 113)*)    1 , (*A 394(P 114)*)    1
         , (*A 395(P 115)*)    1 , (*A 396(P 116)*)    1 , (*A 397(P 117)*)    1
         , (*A 398(P 118)*)    1 , (*A 399(P 119)*)    1 , (*A 400(P 120)*)    1
         , (*A 401(P 121)*)    1 , (*A 402(P 122)*)    1 , (*A 403(P 123)*)    1
         , (*A 404(P 124)*)    1 , (*A 405(P 125)*)    2 , (*A 406(P 126)*)    3
         , (*A 407(P 127)*)    0 , (*A 408(P 128)*)    2 , (*A 409(P 129)*)    1
         , (*A 410(P 130)*)    3 , (*A 411(P 131)*)    1 , (*A 412(P 132)*)    3
         , (*A 413(P 133)*)    2 , (*A 414(P 134)*)    3 , (*A 415(P 135)*)    2
         , (*A 416(P 136)*)    1 , (*A 417(P 137)*)    4 , (*A 418(P 138)*)    3
         , (*A 419(P 139)*)    1 , (*A 420(P 140)*)    0 , (*A 421(P 141)*)    1
         , (*A 422(P 142)*)    1 , (*A 423(P 143)*)    1 , (*A 424(P 144)*)    4
         , (*A 425(P 145)*)    1 , (*A 426(P 146)*)    2 , (*A 427(P 147)*)    0
         , (*A 428(P 148)*)    2 , (*A 429(P 149)*)    0 , (*A 430(P 150)*)    2
         , (*A 431(P 151)*)    0 , (*A 432(P 152)*)    2 , (*A 433(P 153)*)    4
         , (*A 434(P 154)*)    0 , (*A 435(P 155)*)    4 , (*A 436(P 156)*)    1
         , (*A 437(P 157)*)    1 , (*A 438(P 158)*)    4 , (*A 439(P 159)*)    1
         , (*A 440(P 160)*)    1 , (*A 441(P 161)*)    1 , (*A 442(P 162)*)    1
         , (*A 443(P 163)*)    1 , (*A 444(P 164)*)    1 , (*A 445(P 165)*)    1
         , (*A 446(P 166)*)    1 , (*A 447(P 167)*)    1 , (*A 448(P 168)*)    1
         , (*A 449(P 169)*)    1 , (*A 450(P 170)*)    1 , (*A 451(P 171)*)    2
         , (*A 452(P 172)*)    0 , (*A 453(P 173)*)    5 , (*A 454(P 174)*)    1
         , (*A 455(P 175)*)    1 , (*A 456(P 176)*)    1 , (*A 457(P 177)*)    1
         , (*A 458(P 178)*)    1 , (*A 459(P 179)*)    1 , (*A 460(P 180)*)    0
         , (*A 461(P 181)*)    1 , (*A 462(P 182)*)    1 , (*A 463(P 183)*)    2
         , (*A 464(P 184)*)    0 , (*A 465(P 185)*)    2 , (*A 466(P 186)*)    1
         , (*A 467(P 187)*)    3 , (*A 468(P 188)*)    1 , (*A 469(P 189)*)    3
         };
         
   yyLeftHandSide
     (* Subscripted by a reduce action, maps to LHS NT of the
        of production to reduce by.  A<a> is a reduce action number.
        P<p> is the correponding production number.
     *)
     := ARRAY yyReduceRangePacked OF yySymbolRangePacked
         {
           (*A 281(P   1)*)  224 , (*A 282(P   2)*)  109 , (*A 283(P   3)*)  109
         , (*A 284(P   4)*)  109 , (*A 285(P   5)*)  109 , (*A 286(P   6)*)  109
         , (*A 287(P   7)*)  109 , (*A 288(P   8)*)  115 , (*A 289(P   9)*)  116
         , (*A 290(P  10)*)  117 , (*A 291(P  11)*)  117 , (*A 292(P  12)*)  119
         , (*A 293(P  13)*)  120 , (*A 294(P  14)*)  121 , (*A 295(P  15)*)  122
         , (*A 296(P  16)*)  123 , (*A 297(P  17)*)  124 , (*A 298(P  18)*)  126
         , (*A 299(P  19)*)  113 , (*A 300(P  20)*)  129 , (*A 301(P  21)*)  108
         , (*A 302(P  22)*)  131 , (*A 303(P  23)*)  114 , (*A 304(P  24)*)  132
         , (*A 305(P  25)*)  110 , (*A 306(P  26)*)  134 , (*A 307(P  27)*)  111
         , (*A 308(P  28)*)  136 , (*A 309(P  29)*)  112 , (*A 310(P  30)*)  125
         , (*A 311(P  31)*)  125 , (*A 312(P  32)*)  138 , (*A 313(P  33)*)  139
         , (*A 314(P  34)*)  139 , (*A 315(P  35)*)  140 , (*A 316(P  36)*)  141
         , (*A 317(P  37)*)  141 , (*A 318(P  38)*)  142 , (*A 319(P  39)*)  142
         , (*A 320(P  40)*)  143 , (*A 321(P  41)*)  143 , (*A 322(P  42)*)  144
         , (*A 323(P  43)*)  144 , (*A 324(P  44)*)  145 , (*A 325(P  45)*)  145
         , (*A 326(P  46)*)  146 , (*A 327(P  47)*)  146 , (*A 328(P  48)*)  146
         , (*A 329(P  49)*)  128 , (*A 330(P  50)*)  147 , (*A 331(P  51)*)  149
         , (*A 332(P  52)*)  148 , (*A 333(P  53)*)  148 , (*A 334(P  54)*)  150
         , (*A 335(P  55)*)  151 , (*A 336(P  56)*)  151 , (*A 337(P  57)*)  150
         , (*A 338(P  58)*)  152 , (*A 339(P  59)*)  152 , (*A 340(P  60)*)  118
         , (*A 341(P  61)*)  118 , (*A 342(P  62)*)  153 , (*A 343(P  63)*)  153
         , (*A 344(P  64)*)  135 , (*A 345(P  65)*)  127 , (*A 346(P  66)*)  155
         , (*A 347(P  67)*)  155 , (*A 348(P  68)*)  156 , (*A 349(P  69)*)  158
         , (*A 350(P  70)*)  157 , (*A 351(P  71)*)  157 , (*A 352(P  72)*)  159
         , (*A 353(P  73)*)  159 , (*A 354(P  74)*)  161 , (*A 355(P  75)*)  160
         , (*A 356(P  76)*)  164 , (*A 357(P  77)*)  164 , (*A 358(P  78)*)  165
         , (*A 359(P  79)*)  167 , (*A 360(P  80)*)  166 , (*A 361(P  81)*)  166
         , (*A 362(P  82)*)  168 , (*A 363(P  83)*)  168 , (*A 364(P  84)*)  170
         , (*A 365(P  85)*)  169 , (*A 366(P  86)*)  171 , (*A 367(P  87)*)  171
         , (*A 368(P  88)*)  172 , (*A 369(P  89)*)  174 , (*A 370(P  90)*)  173
         , (*A 371(P  91)*)  173 , (*A 372(P  92)*)  175 , (*A 373(P  93)*)  175
         , (*A 374(P  94)*)  176 , (*A 375(P  95)*)  177 , (*A 376(P  96)*)  179
         , (*A 377(P  97)*)  178 , (*A 378(P  98)*)  178 , (*A 379(P  99)*)  180
         , (*A 380(P 100)*)  180 , (*A 381(P 101)*)  181 , (*A 382(P 102)*)  182
         , (*A 383(P 103)*)  162 , (*A 384(P 104)*)  162 , (*A 385(P 105)*)  183
         , (*A 386(P 106)*)  183 , (*A 387(P 107)*)  154 , (*A 388(P 108)*)  154
         , (*A 389(P 109)*)  154 , (*A 390(P 110)*)  154 , (*A 391(P 111)*)  154
         , (*A 392(P 112)*)  154 , (*A 393(P 113)*)  154 , (*A 394(P 114)*)  154
         , (*A 395(P 115)*)  154 , (*A 396(P 116)*)  154 , (*A 397(P 117)*)  154
         , (*A 398(P 118)*)  154 , (*A 399(P 119)*)  154 , (*A 400(P 120)*)  154
         , (*A 401(P 121)*)  154 , (*A 402(P 122)*)  154 , (*A 403(P 123)*)  154
         , (*A 404(P 124)*)  154 , (*A 405(P 125)*)  154 , (*A 406(P 126)*)  154
         , (*A 407(P 127)*)  200 , (*A 408(P 128)*)  200 , (*A 409(P 129)*)  201
         , (*A 410(P 130)*)  201 , (*A 411(P 131)*)  202 , (*A 412(P 132)*)  154
         , (*A 413(P 133)*)  154 , (*A 414(P 134)*)  203 , (*A 415(P 135)*)  204
         , (*A 416(P 136)*)  207 , (*A 417(P 137)*)  204 , (*A 418(P 138)*)  208
         , (*A 419(P 139)*)  208 , (*A 420(P 140)*)  210 , (*A 421(P 141)*)  210
         , (*A 422(P 142)*)  210 , (*A 423(P 143)*)  210 , (*A 424(P 144)*)  209
         , (*A 425(P 145)*)  211 , (*A 426(P 146)*)  212 , (*A 427(P 147)*)  212
         , (*A 428(P 148)*)  213 , (*A 429(P 149)*)  213 , (*A 430(P 150)*)  205
         , (*A 431(P 151)*)  205 , (*A 432(P 152)*)  206 , (*A 433(P 153)*)  206
         , (*A 434(P 154)*)  206 , (*A 435(P 155)*)  215 , (*A 436(P 156)*)  214
         , (*A 437(P 157)*)  216 , (*A 438(P 158)*)  214 , (*A 439(P 159)*)  163
         , (*A 440(P 160)*)  163 , (*A 441(P 161)*)  163 , (*A 442(P 162)*)  163
         , (*A 443(P 163)*)  163 , (*A 444(P 164)*)  163 , (*A 445(P 165)*)  163
         , (*A 446(P 166)*)  163 , (*A 447(P 167)*)  163 , (*A 448(P 168)*)  163
         , (*A 449(P 169)*)  163 , (*A 450(P 170)*)  163 , (*A 451(P 171)*)  163
         , (*A 452(P 172)*)  217 , (*A 453(P 173)*)  137 , (*A 454(P 174)*)  218
         , (*A 455(P 175)*)  218 , (*A 456(P 176)*)  218 , (*A 457(P 177)*)  218
         , (*A 458(P 178)*)  218 , (*A 459(P 179)*)  218 , (*A 460(P 180)*)  130
         , (*A 461(P 181)*)  130 , (*A 462(P 182)*)  220 , (*A 463(P 183)*)  220
         , (*A 464(P 184)*)  133 , (*A 465(P 185)*)  133 , (*A 466(P 186)*)  221
         , (*A 467(P 187)*)  221 , (*A 468(P 188)*)  222 , (*A 469(P 189)*)  223
         };
         
   yyContinuation
     := ARRAY [0 .. yyLastReadState] OF yySymbolRangePacked
         {
           (*:   0*)    0 , (*:   1*)   32 , (*:   2*)   32
         , (*:   3*)   95 , (*:   4*)   95 , (*:   5*)    0
         , (*:   6*)   32 , (*:   7*)   95 , (*:   8*)   95
         , (*:   9*)   66 , (*:  10*)   14 , (*:  11*)    9
         , (*:  12*)    9 , (*:  13*)   95 , (*:  14*)   30
         , (*:  15*)   95 , (*:  16*)   95 , (*:  17*)   66
         , (*:  18*)   95 , (*:  19*)   66 , (*:  20*)   95
         , (*:  21*)   95 , (*:  22*)   69 , (*:  23*)   70
         , (*:  24*)   70 , (*:  25*)   95 , (*:  26*)   19
         , (*:  27*)   95 , (*:  28*)   67 , (*:  29*)   19
         , (*:  30*)   95 , (*:  31*)   69 , (*:  32*)   70
         , (*:  33*)   66 , (*:  34*)    9 , (*:  35*)   95
         , (*:  36*)   66 , (*:  37*)    9 , (*:  38*)    9
         , (*:  39*)   19 , (*:  40*)   19 , (*:  41*)   95
         , (*:  42*)   19 , (*:  43*)   74 , (*:  44*)   95
         , (*:  45*)   19 , (*:  46*)   19 , (*:  47*)   19
         , (*:  48*)    9 , (*:  49*)    9 , (*:  50*)   66
         , (*:  51*)   68 , (*:  52*)   95 , (*:  53*)   19
         , (*:  54*)   69 , (*:  55*)   19 , (*:  56*)   95
         , (*:  57*)   95 , (*:  58*)   52 , (*:  59*)   19
         , (*:  60*)   19 , (*:  61*)   19 , (*:  62*)   95
         , (*:  63*)   19 , (*:  64*)   19 , (*:  65*)   95
         , (*:  66*)   19 , (*:  67*)   19 , (*:  68*)   19
         , (*:  69*)   19 , (*:  70*)   19 , (*:  71*)    6
         , (*:  72*)   71 , (*:  73*)   76 , (*:  74*)   95
         , (*:  75*)   95 , (*:  76*)   70 , (*:  77*)   70
         , (*:  78*)   95 , (*:  79*)   66 , (*:  80*)   66
         , (*:  81*)   95 , (*:  82*)   66 , (*:  83*)   95
         , (*:  84*)   66 , (*:  85*)   70 , (*:  86*)   68
         , (*:  87*)   95 , (*:  88*)   66 , (*:  89*)   66
         , (*:  90*)    9 , (*:  91*)    9 , (*:  92*)   66
         , (*:  93*)   68 , (*:  94*)   95 , (*:  95*)   66
         , (*:  96*)    9 , (*:  97*)   52 , (*:  98*)   68
         , (*:  99*)   95 , (*: 100*)    9 , (*: 101*)   66
         , (*: 102*)   66 , (*: 103*)    9 , (*: 104*)    9
         , (*: 105*)   66 , (*: 106*)   66 , (*: 107*)    9
         , (*: 108*)   19 , (*: 109*)   95 , (*: 110*)   67
         , (*: 111*)   66 , (*: 112*)   95 , (*: 113*)   66
         , (*: 114*)   95 , (*: 115*)   95 , (*: 116*)   69
         , (*: 117*)   19 , (*: 118*)   95 , (*: 119*)   67
         , (*: 120*)   66 , (*: 121*)    9 , (*: 122*)    9
         , (*: 123*)    9 , (*: 124*)   19 , (*: 125*)   19
         , (*: 126*)   95 , (*: 127*)   67 , (*: 128*)   69
         , (*: 129*)   69 , (*: 130*)   70 , (*: 131*)   70
         , (*: 132*)   66 , (*: 133*)   14 , (*: 134*)   19
         , (*: 135*)   19 , (*: 136*)   95 , (*: 137*)   67
         , (*: 138*)   69 , (*: 139*)   69 , (*: 140*)   66
         , (*: 141*)    9 , (*: 142*)    9 , (*: 143*)   95
         , (*: 144*)   67
         };
         
   yyFinalToProd
     (* Subscripted by a read-reduce action, maps to the reduce
        action to take after the read.
     *) 
     := ARRAY yyReadReduceRangePacked OF yyReduceRangePacked
         {
           (*RR: 145)*)  288 (*P7*) , (*RR: 146)*)  310 (*P29*)
         , (*RR: 147)*)  298 (*P17*) , (*RR: 148)*)  302 (*P21*)
         , (*RR: 149)*)  315 (*P34*) , (*RR: 150)*)  338 (*P57*)
         , (*RR: 151)*)  335 (*P54*) , (*RR: 152)*)  334 (*P53*)
         , (*RR: 153)*)  336 (*P55*) , (*RR: 154)*)  337 (*P56*)
         , (*RR: 155)*)  345 (*P64*) , (*RR: 156)*)  299 (*P18*)
         , (*RR: 157)*)  348 (*P67*) , (*RR: 158)*)  415 (*P134*)
         , (*RR: 159)*)  436 (*P155*) , (*RR: 160)*)  437 (*P156*)
         , (*RR: 161)*)  438 (*P157*) , (*RR: 162)*)  368 (*P87*)
         , (*RR: 163)*)  358 (*P77*) , (*RR: 164)*)  375 (*P94*)
         , (*RR: 165)*)  325 (*P44*) , (*RR: 166)*)  440 (*P159*)
         , (*RR: 167)*)  441 (*P160*) , (*RR: 168)*)  442 (*P161*)
         , (*RR: 169)*)  443 (*P162*) , (*RR: 170)*)  444 (*P163*)
         , (*RR: 171)*)  445 (*P164*) , (*RR: 172)*)  446 (*P165*)
         , (*RR: 173)*)  447 (*P166*) , (*RR: 174)*)  448 (*P167*)
         , (*RR: 175)*)  449 (*P168*) , (*RR: 176)*)  450 (*P169*)
         , (*RR: 177)*)  453 (*P172*) , (*RR: 178)*)  451 (*P170*)
         , (*RR: 179)*)  354 (*P73*) , (*RR: 180)*)  353 (*P72*)
         , (*RR: 181)*)  405 (*P124*) , (*RR: 182)*)  411 (*P130*)
         , (*RR: 183)*)  327 (*P46*) , (*RR: 184)*)  406 (*P125*)
         , (*RR: 185)*)  328 (*P47*) , (*RR: 186)*)  318 (*P37*)
         , (*RR: 187)*)  319 (*P38*) , (*RR: 188)*)  412 (*P131*)
         , (*RR: 189)*)  432 (*P151*) , (*RR: 190)*)  433 (*P152*)
         , (*RR: 191)*)  423 (*P142*) , (*RR: 192)*)  421 (*P140*)
         , (*RR: 193)*)  422 (*P141*) , (*RR: 194)*)  417 (*P136*)
         , (*RR: 195)*)  352 (*P71*) , (*RR: 196)*)  364 (*P83*)
         , (*RR: 197)*)  363 (*P82*) , (*RR: 198)*)  356 (*P75*)
         , (*RR: 199)*)  357 (*P76*) , (*RR: 200)*)  362 (*P81*)
         , (*RR: 201)*)  366 (*P85*) , (*RR: 202)*)  367 (*P86*)
         , (*RR: 203)*)  373 (*P92*) , (*RR: 204)*)  372 (*P91*)
         , (*RR: 205)*)  380 (*P99*) , (*RR: 206)*)  379 (*P98*)
         , (*RR: 207)*)  301 (*P20*) , (*RR: 208)*)  342 (*P61*)
         , (*RR: 209)*)  343 (*P62*) , (*RR: 210)*)  303 (*P22*)
         , (*RR: 211)*)  305 (*P24*) , (*RR: 212)*)  344 (*P63*)
         , (*RR: 213)*)  307 (*P26*) , (*RR: 214)*)  309 (*P28*)
         , (*RR: 215)*)  306 (*P25*) , (*RR: 216)*)  308 (*P27*)
         , (*RR: 217)*)  282 (*P1*) , (*RR: 218)*)  283 (*P2*)
         , (*RR: 219)*)  284 (*P3*) , (*RR: 220)*)  285 (*P4*)
         , (*RR: 221)*)  286 (*P5*) , (*RR: 222)*)  287 (*P6*)
         , (*RR: 223)*)  300 (*P19*) , (*RR: 224)*)  329 (*P48*)
         , (*RR: 225)*)  332 (*P51*) , (*RR: 226)*)  339 (*P58*)
         , (*RR: 227)*)  320 (*P39*) , (*RR: 228)*)  435 (*P154*)
         , (*RR: 229)*)  439 (*P158*) , (*RR: 230)*)  467 (*P186*)
         , (*RR: 231)*)  468 (*P187*) , (*RR: 232)*)  465 (*P184*)
         , (*RR: 233)*)  466 (*P185*) , (*RR: 234)*)  349 (*P68*)
         , (*RR: 235)*)  413 (*P132*) , (*RR: 236)*)  326 (*P45*)
         , (*RR: 237)*)  387 (*P106*) , (*RR: 238)*)  388 (*P107*)
         , (*RR: 239)*)  389 (*P108*) , (*RR: 240)*)  390 (*P109*)
         , (*RR: 241)*)  391 (*P110*) , (*RR: 242)*)  392 (*P111*)
         , (*RR: 243)*)  393 (*P112*) , (*RR: 244)*)  394 (*P113*)
         , (*RR: 245)*)  395 (*P114*) , (*RR: 246)*)  396 (*P115*)
         , (*RR: 247)*)  397 (*P116*) , (*RR: 248)*)  398 (*P117*)
         , (*RR: 249)*)  399 (*P118*) , (*RR: 250)*)  400 (*P119*)
         , (*RR: 251)*)  401 (*P120*) , (*RR: 252)*)  402 (*P121*)
         , (*RR: 253)*)  403 (*P122*) , (*RR: 254)*)  404 (*P123*)
         , (*RR: 255)*)  409 (*P128*) , (*RR: 256)*)  381 (*P100*)
         , (*RR: 257)*)  410 (*P129*) , (*RR: 258)*)  408 (*P127*)
         , (*RR: 259)*)  430 (*P149*) , (*RR: 260)*)  322 (*P41*)
         , (*RR: 261)*)  414 (*P133*) , (*RR: 262)*)  418 (*P137*)
         , (*RR: 263)*)  426 (*P145*) , (*RR: 264)*)  424 (*P143*)
         , (*RR: 265)*)  419 (*P138*) , (*RR: 266)*)  383 (*P102*)
         , (*RR: 267)*)  454 (*P173*) , (*RR: 268)*)  359 (*P78*)
         , (*RR: 269)*)  365 (*P84*) , (*RR: 270)*)  455 (*P174*)
         , (*RR: 271)*)  374 (*P93*) , (*RR: 272)*)  369 (*P88*)
         , (*RR: 273)*)  459 (*P178*) , (*RR: 274)*)  376 (*P95*)
         , (*RR: 275)*)  457 (*P176*) , (*RR: 276)*)  458 (*P177*)
         , (*RR: 277)*)  462 (*P181*) , (*RR: 278)*)  456 (*P175*)
         , (*RR: 279)*)  463 (*P182*) , (*RR: 280)*)  304 (*P23*)
         }; 

VAR
   yyIsInitialized      : BOOLEAN;
   yyTableFile          : System.tFile;
   yyErrMsgWrT          : TextWr . T;
  yyErrorPos           : FM3Scanner.tPosition;
   yyMsgLineLen         : INTEGER;
   
(* Copied in from Parser.m30.orig: *) 
    PROCEDURE ExpandStateStack ( VAR Stack : yyStackType ; ToSize : INTEGER ) =

      VAR LOldStack : yyStackType;
      VAR LStackNumber : INTEGER; 
      BEGIN
        LStackNumber := NUMBER ( Stack ^ );
        IF LStackNumber < ToSize
        THEN
          LOldStack := Stack; 
          Stack := NEW ( yyStackType , ToSize );
          SUBARRAY ( Stack ^ , 0 , LStackNumber ) := LOldStack ^;
          LOldStack := NIL; 
        END;
      END ExpandStateStack; 

    PROCEDURE ExpandAttributeStack
      ( VAR Stack : yyAttributeStackType ; ToSize : INTEGER ) =

      VAR LOldStack : yyAttributeStackType;
      VAR LStackNumber : INTEGER; 
      BEGIN
        LStackNumber := NUMBER ( Stack ^ );
        IF LStackNumber < ToSize
        THEN
          LOldStack := Stack; 
          Stack := NEW ( yyAttributeStackType , ToSize );
          SUBARRAY ( Stack ^ , 0 , LStackNumber ) := LOldStack ^;
          LOldStack := NIL; 
        END; 
      END ExpandAttributeStack; 
(* END From Parser.m30.orig: *) 

(*EXPORTED*)
PROCEDURE TokenName (Token: INTEGER; VAR Name: TEXT) =
   BEGIN
(*TODO: Implement a version of this that returns, e.g. BEGIN
        instead of StkRwBegin.  Use it in messages giving error token,
        expected token(s), and inserted token(s).
*)
      CASE Token OF
(* -------------------------------------------------------------------------- *)
                          (* Lalr-generated token names. *) 
      | 0 => Name := "_EndOfFile";
      | 5 => Name := "StkRwAND";
      | 6 => Name := "StkRwANY";
      | 7 => Name := "StkRwARRAY";
      | 8 => Name := "StkRwAS";
      | 9 => Name := "StkRwBEGIN";
      | 10 => Name := "StkRwBITS";
      | 11 => Name := "StkRwBRANDED";
      | 12 => Name := "StkRwBY";
      | 13 => Name := "StkRwCASE";
      | 14 => Name := "StkRwCONST";
      | 15 => Name := "StkRwDIV";
      | 16 => Name := "StkRwDO";
      | 17 => Name := "StkRwELSE";
      | 18 => Name := "StkRwELSIF";
      | 19 => Name := "StkRwEND";
      | 20 => Name := "StkRwEVAL";
      | 21 => Name := "StkRwEXCEPT";
      | 22 => Name := "StkRwEXCEPTION";
      | 23 => Name := "StkRwEXIT";
      | 24 => Name := "StkRwEXPORTS";
      | 25 => Name := "StkRwFINALLY";
      | 26 => Name := "StkRwFOR";
      | 27 => Name := "StkRwFROM";
      | 28 => Name := "StkRwGENERIC";
      | 29 => Name := "StkRwIF";
      | 30 => Name := "StkRwIMPORT";
      | 31 => Name := "StkRwIN";
      | 32 => Name := "StkRwINTERFACE";
      | 33 => Name := "StkRwLOCK";
      | 34 => Name := "StkRwLOOP";
      | 35 => Name := "StkRwMETHODS";
      | 36 => Name := "StkRwMOD";
      | 37 => Name := "StkRwMODULE";
      | 38 => Name := "StkRwNOT";
      | 39 => Name := "StkRwOBJECT";
      | 40 => Name := "StkRwOF";
      | 41 => Name := "StkRwOR";
      | 42 => Name := "StkRwOVERRIDES";
      | 43 => Name := "StkRwPROCEDURE";
      | 44 => Name := "StkRwRAISE";
      | 45 => Name := "StkRwRAISES";
      | 46 => Name := "StkRwREADONLY";
      | 47 => Name := "StkRwRECORD";
      | 48 => Name := "StkRwREF";
      | 49 => Name := "StkRwREPEAT";
      | 50 => Name := "StkRwRETURN";
      | 51 => Name := "StkRwREVEAL";
      | 52 => Name := "StkRwROOT";
      | 53 => Name := "StkRwSET";
      | 54 => Name := "StkRwTHEN";
      | 55 => Name := "StkRwTO";
      | 56 => Name := "StkRwTRY";
      | 57 => Name := "StkRwTYPE";
      | 58 => Name := "StkRwTYPECASE";
      | 59 => Name := "StkRwUNSAFE";
      | 60 => Name := "StkRwUNTIL";
      | 61 => Name := "StkRwUNTRACED";
      | 62 => Name := "StkRwVALUE";
      | 63 => Name := "StkRwVAR";
      | 64 => Name := "StkRwWHILE";
      | 65 => Name := "StkRwWITH";
      | 66 => Name := "StkSemicolon";
      | 67 => Name := "StkDot";
      | 68 => Name := "StkEqual";
      | 69 => Name := "StkOpenParen";
      | 70 => Name := "StkCloseParen";
      | 71 => Name := "StkComma";
      | 72 => Name := "StkColon";
      | 73 => Name := "StkSubtype";
      | 74 => Name := "StkBecomes";
      | 75 => Name := "StkOpenBrace";
      | 76 => Name := "StkCloseBrace";
      | 77 => Name := "StkStroke";
      | 78 => Name := "StkArrow";
      | 79 => Name := "StkEllipsis";
      | 80 => Name := "StkOpenBracket";
      | 81 => Name := "StkCloseBracket";
      | 82 => Name := "StkUnequal";
      | 83 => Name := "StkLess";
      | 84 => Name := "StkGreater";
      | 85 => Name := "StkLessEqual";
      | 86 => Name := "StkGreaterEqual";
      | 87 => Name := "StkPlus";
      | 88 => Name := "StkMinus";
      | 89 => Name := "StkAmpersand";
      | 90 => Name := "StkStar";
      | 91 => Name := "StkSlash";
      | 92 => Name := "StkDeref";
      | 93 => Name := "StkOpenPragma";
      | 94 => Name := "StkClosePragma";
      | 95 => Name := "StkIdent";
      | 96 => Name := "StkIntLit";
      | 97 => Name := "StkLongIntLit";
      | 98 => Name := "StkBasedLit";
      | 99 => Name := "StkLongBasedLit";
      | 100 => Name := "StkRealLit";
      | 101 => Name := "StkLongRealLit";
      | 102 => Name := "StkExtendedLit";
      | 103 => Name := "StkTextLit";
      | 104 => Name := "StkWideTextLit";
      | 105 => Name := "StkCharLit";
      | 106 => Name := "StkWideCharLit";
      | 107 => Name := "StkLexErrChars";
                      (* End of lalr-generated token names. *) 
(* -------------------------------------------------------------------------- *)
      ELSE Name := "" 
      END;
   END TokenName;

(* NOTE regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer, as it
   is before the reduce semantic actions are performed.  If the reduce
   is nonempty, this is a copy from the leftmost RHS's attribute.
   How confusing, but it preserves a bit of lalr's original parsing speed.
*) 

(*EXPORTED*)
  PROCEDURE FM3Parser (): CARDINAL =

(* -------------------------------------------------------------------------- *)
            (* Declarations from the LOCAL section of the .lalr file: *)
            
(* line 72 "FM3Parser.lalr" *)
 TYPE Skt = FM3Scopes . ScopeKindTyp ;
    TYPE Dkt = FM3Decls . DeclKindTyp ; 
    TYPE Ukt = FM3Units . UnitKindTyp ;

    PROCEDURE Test ( READONLY Attr : tParsAttribute )
    = VAR Debug : INTEGER := 0
    ; BEGIN
        IF Attr . PaInt = FIRST ( INTEGER)
        THEN
          Debug := 19
        END 
      END Test ;

  

        (* End of declarations from the LOCAL section of the .lalr file: *)
(* -------------------------------------------------------------------------- *)
   
   VAR
      yyRHSUnnestCoord        : LONGINT; 
      yyPrereduceUnnestCoord  : LONGINT; 
      yyState                 : yyStateRange;
      (* NOTE: "yyState" and other occurrences of "State" are misleading.
               They are, in general, parsing *actions*, only the low range
               up to yyLastReadState (a constant inserted by the generator)
               being truly states.  These correspond to item sets, and as
               actions, they mean read (it will be a terminal) and enter
               new state yyState.  Higher ranges are read-terminal-reduce,
               read-nonterminal-reduce, and just reduce actions.
               Deconfusing this terminology would require extensive and
               error-prone work.
      *) 
      yyTerminal        : yySymbolRange;
      yyNonterminal     : yySymbolRange;
        (* ^LHS NT to be pushed as result of a reduction.*)
     yyNTPos           : FM3Scanner.tPosition (* Position for yyNonterminal. *) ;  

      yyStackPtr        : yyStackPtrType;
      yyPrereduceStackPtr : yyStackPtrType;
      yyStackLAST       : INTEGER;
      yyStateStackSize  : INTEGER;
      yyAttrStackSize   := yyStateStackSize; 
      (* yyStackPtr, yyStackLAST, and yyStateStackSize always apply equally
         to yyStateStack and yyAttributeStack. *)
      yyStateStack      : yyStackType;
      yyAttributeStack  : yyAttributeStackType;
      yySynAttribute    : tParsAttribute;
        (* ^Synthesized attribute, by .lalr-provided semantic actions. *)
     yyRepairAttribute : FM3Scanner.tScanAttribute;
      yyRepairToken     : yySymbolRange;
      yyTCombPtr        : yyTCombTypePtr;
      yyNCombPtr        : yyNCombTypePtr;
      yyErrorCount      : CARDINAL;
      yyText            : TEXT; 
      yyTokenStringxxx  : TEXT (*ARRAY [0..127] OF CHAR*);
      (* ^For use in a debugger. *) 
      yyRepairsInserted : INTEGER;
      (* ^<0 => not repairing. Otherwise, number of tokens inserted so far. *)

   BEGIN (* FM3Parser *) 
     BeginFM3Parser ();
      yyState           := yyStartState;
     yyTerminal        := FM3Scanner.GetToken ();
      yyStateStackSize  := yyInitStackSize;
      yyAttrStackSize   := yyInitStackSize;
      yyStateStack      := NEW ( yyStackType , yyStateStackSize );
      yyAttributeStack  := NEW ( yyAttributeStackType , yyStateStackSize ); 
      yyStackLAST       := LAST ( yyStateStack ^ ) (* Of yyAttributeStack too. *);
      yyStackPtr        := 0;
      yyErrorCount      := 0;
      yyRepairsInserted := - 1;

      LOOP (* Through parsing actions. One iteration does:
              1) Any token deletions called for by an error.
              2) Any continuation token insertions called for 
                 after an error.
              3) Either: 
                 a) Possibly one read-reduce followed by 
                    a sequence of reduces
              or b) One read
           *)  
         (* Make room and push true state onto state stack. *) 
         IF yyStackPtr >= yyStackLAST 
         THEN
            yyStateStackSize
              := MAX ( NUMBER ( yyStateStack ^ ) * 2 , yyStackPtr + 2 ); 
            ExpandStateStack ( yyStateStack , yyStateStackSize ); 
            ExpandAttributeStack ( yyAttributeStack , yyStateStackSize );
            yyStackLAST
              := LAST ( yyStateStack ^ ) (* Of yyAttributeStack too. *);
         END (* IF *) ;
         yyStateStack^ [yyStackPtr] := (*State*)yyState;

         LOOP (* Through all continuation shifts, plus compute the state
                 after that.  This loop also goes through the default state
                 computations. *) 
            (* SPEC State := Next (State, Terminal); terminal transition *)
            
            yyTCombPtr := LOOPHOLE 
                            ( LOOPHOLE ( yyTBasePtr [yyState (*State*)] ,INTEGER) 
                              + yyTerminal * BYTESIZE (yyTCombType)
                            , yyTCombTypePtr
                            );
            IF yyTCombPtr^.Check = (*State*)yyState 
            THEN
               yyState := yyTCombPtr^.Next;
               EXIT;
            END (* IF *) ;
            (*State*)yyState := yyDefault [(*State*)yyState];

            IF yyState = yyNoState 
            THEN (* syntax error *)
               (*State*)yyState := yyStateStack^ [yyStackPtr];
               IF yyRepairsInserted >= 0 
               THEN (* Repairing. *)
                  (*ASSERT yyErrMsgWrT # NIL *)
                  yyRepairToken := yyContinuation [yyState];
                  yyState (*Any action*) := Next (yyState, yyRepairToken);
                  IF yyState <= yyLastReadTermState 
                  THEN (* read or read terminal reduce ? *)
                    FM3Scanner.ErrorAttribute 
                         (yyRepairToken, (*OUT*)yyRepairAttribute);
                     TokenName (yyRepairToken, (*OUT*) yyText);
                     IF yyRepairsInserted = 0 THEN 
                       Wr.PutText (yyErrMsgWrT, FM3Messages.NLIndent);
                       yyMsgLineLen := FM3Messages.IndentLen;
                       AppendToLine ("Repair token(s) inserted: ");
                     END (*IF*);
                     QuoteAndFillOnLine ( yyText );
                     INC (yyRepairsInserted );
                     IF yyState >= yyFirstFinalState 
                     THEN (* avoid second push *)
                        yyState (*Reduce*) := yyFinalToProd [(*Action*)yyState];
                     END (* IF *) ;
                     INC (yyStackPtr);
                     yyStateStack^ [yyStackPtr] := yyState;
                     WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
                     DO 
                       WParsAttr.Scan := yyRepairAttribute;
                       WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*                     PushUnnestStk (WParsAttr); *)
                     END (*WITH*)
                  END (* IF *) ;
                  IF yyState >= yyFirstFinalState 
                  THEN (* final state ? *)
                    EXIT;
                  END (* IF *) ;
               ELSE (* Report and start recovery. *)
                  INC (yyErrorCount);
                  ErrorRecovery 
                    (yyTerminal, yyStateStack,
                     NUMBER ( yyStateStack ^ ), yyStackPtr);
                  yyRepairsInserted := 0;
               END (* IF *) ;
            END (* IF *) ;
         END (* LOOP *) ;

         IF yyState >= yyFirstFinalState 
         THEN (* Action, ending with a reduce. *)
            IF yyState <= yyLastReadTermState (* read terminal reduce ? *) 
            THEN (* First do the read terminal. *)
              INC (yyStackPtr);
              (* Is there such a thing as a read-reduce action where the
                 reduce is by an empty production?  And so are all the
                 subsequent reduces?  If so, it is important to store into
                 the two stacks, which will not be overlaid by reduces.
              *)
              yyStateStack^ [yyStackPtr]
                := yyState (*Read terminal reduce action*) (*ParserDebug*);
              (* ^Not a true state.  Should be overlaid very soon.  But if
                  not, due to empty reduces, this will be the wrong value
                  in the state stack. *)
              WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
              DO
                WParsAttr := ParsAttrNull; 
                WParsAttr.Scan := FM3Scanner.Attribute;
                WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*              PushUnnestStk (WParsAttr); *) 
              END (*WITH*);
             yyTerminal := FM3Scanner.GetToken ();
              IF yyRepairsInserted >= 0
              (* ^0 => repairs been happening, tho' with no insertions. *) 
              THEN (* Finished with a repair. *) 
                 EmitSyntErrMsg ( );
                 yyRepairsInserted := - 1;
              END (*IF*);

               yyStateStack^ [yyStackPtr] := (*Reduce*)yyState (*ParserDebug*);
            END (* IF *) ;

            LOOP (* Through successive reductions *)
               yyPrereduceStackPtr := yyStackPtr;
               yySynAttribute := ParsAttrNull;
               yyPrereduceUnnestCoord := UnnestCoord ( );

(* -------------------------------------------------------------------------- *)
             (* Inserted semantic action code from the .lalr file: *)
             
              CASE yyState OF
              | 281 => (* P1 _0000_ (224): Compilation _EndOfFile .*)
                yyStateStack := NIL;
                yyAttributeStack := NIL;
                RETURN yyErrorCount;

              | 282,217 => (* P2 Compilation (109): Interface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 283,218 => (* P3 Compilation (109): Module .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 284,219 => (* P4 Compilation (109): GenInterface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 285,220 => (* P5 Compilation (109): GenModule .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 286,221 => (* P6 Compilation (109): InstInterface .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 287,222 => (* P7 Compilation (109): InstModule .*)
                DEC (yyStackPtr, 1); yyNonterminal := 109;

              | 288,145 => (* P8 UnitId (115): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 115;
                (* line 263 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom ;
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         FM3Units . UnitStackTopRef ^ . UntUnitIdentAtom := yySynAttribute . Scan . SaAtom ;
                         LScopeRef
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkModule
                                , FM3Scanner . Attribute . Position
                                ) ;
                         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
                         yySynAttribute . PaRefany := LScopeRef ;  
                       END ; 
                     
              | 289 => (* P9 UnitIdImpliedEXPORTS (116): UnitId .*)
                DEC (yyStackPtr, 1); yyNonterminal := 116;
                (* line 280 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position;
                       EVAL FM3Extern . GetExternInterface
                              ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom , IsImport := FALSE ) ; 
                     
              | 290 => (* P10 UnitIdAndExports (117): UnitIdImpliedEXPORTS .*)
                DEC (yyStackPtr, 1); yyNonterminal := 117;
                (* line 286 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN 
                         yySynAttribute . Scan . SaAtom (* Unit ident. *) := yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom ;
                         yySynAttribute . Scan . Position (* Of unit ident. *) := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         yySynAttribute . PaRefany 
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkModule
                                , FM3Scanner . Attribute . Position
                                ) ;
                         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
                         yySynAttribute . PaRefany := LScopeRef ;  
                       END ;  
                     
              | 291 => (* P11 UnitIdAndExports (117): UnitId Exports .*)
                DEC (yyStackPtr, 2); yyNonterminal := 117;
                (* line 302 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                     
              | 292 => (* P12 InterfaceKind (119): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 119;
                (* line 309 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; 
              | 293 => (* P13 ModuleKind (120): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 120;
                (* line 312 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkModule ; 
              | 294 => (* P14 GenInterfaceKind (121): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 121;
                (* line 315 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenInterface ; 
              | 295 => (* P15 GenModuleKind (122): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 122;
                (* line 318 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkGenModule ; 
              | 296 => (* P16 InstInterfaceKind (123): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 123;
                (* line 321 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; 
              | 297 => (* P17 InstModuleKind (124): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 124;
                (* line 324 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; 
              | 298,147 => (* P18 InterfaceLt (126): OptUnsafe StkRwINTERFACE StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 126;
                (* line 327 of "FM3Parser.lalr" *)
                 VAR LUnitRef : FM3Units . UnitRefTyp ; 
                       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
                       BEGIN
                         LUnitRef := FM3Units . UnitStackTopRef ;
                           (* ^Already pushed when source file was opened. *) 
                         LUnitRef ^ . UntUnsafe := yyAttributeStack^[yyStackPtr+1] . PaBool ; 
                         FM3ParsePass . InterfaceId
                           ( LUnitRef , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+3] . Scan . Position ) ;
                         LScopeRef 
                           := FM3Scopes . NewScopeRef 
                                ( LUnitRef , Skt . SkInterface , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                         LUnitRef ^ . UntScopeNo := LScopeRef ^ . ScpScopeNo ; 
                         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 299,156 => (* P19 InstInterface (113): InterfaceLt StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 7); yyNonterminal := 113;
                (* line 348 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstInterface ; 
              | 300,223 => (* P20 InterfaceMiddle (129): InterfaceLt StkSemicolon Imports .*)
                DEC (yyStackPtr, 3); yyNonterminal := 129;
                (* line 351 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInterface ; 
                         yySynAttribute . PaRefany (* ScopeRef *) := yyAttributeStack^[yyStackPtr+1] . PaRefany ;
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ;
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ;
                       END ; 
                     
              | 301,207 => (* P21 Interface (108): InterfaceMiddle BlockDeclList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 5); yyNonterminal := 108;
                (* line 363 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3ParsePass . DeclScopeRtL2R ( LScopeRef ) ;
                         <* ASSERT FM3Scopes . PopLookupScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
                         <* ASSERT FM3Scopes . PopDeclScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
                         FM3ParsePass . CheckUnitFinalId
                           ( FM3Units . UnitStackTopRef
                           , yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom
                           , Ukt . UkInterface
                           , yyAttributeStack^[yyStackPtr+4] . Scan . Position 
                           ) ; 
                         FM3ParsePass . Push_LCIP_rip 
                           ( Itk . ItkInterfaceLt
                           , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                           , FM3Units . UnitStackTopRef ^ . UntUnitNo 
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           ) ; 
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 302,148 => (* P22 ModuleLt (131): OptUnsafe StkRwMODULE StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 131;
                (* line 390 of "FM3Parser.lalr" *)
                 VAR LUnitRef : FM3Units . UnitRefTyp ; 
                       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;  
                       BEGIN
                         LUnitRef := FM3Units . UnitStackTopRef ;
                           (* ^Already pushed when source file was opened. *) 
                         LUnitRef ^ . UntUnsafe := yyAttributeStack^[yyStackPtr+1] . PaBool ; 
                         LUnitRef ^ . UntKind := Ukt . UkModule
                           (* ^Could change, if it turns out to be an instantiation. *) ; 
                         FM3ParsePass . ModuleId
                           ( LUnitRef , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+3] . Scan . Position ) ;
                         LScopeRef 
                           := FM3Scopes . NewScopeRef 
                                ( LUnitRef , Skt . SkModule , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                         LUnitRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ; 
                         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 303,210 => (* P23 InstModule (114): ModuleLt StkEqual StkIdent GenActualList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 7); yyNonterminal := 114;
                (* line 413 of "FM3Parser.lalr" *)
                 FM3Units . UnitStackTopRef ^ . UntKind := Ukt . UkInstModule ; 
              | 304,280 => (* P24 ModuleMiddle (132): ModuleLt Exports StkSemicolon Imports .*)
                DEC (yyStackPtr, 4); yyNonterminal := 132;
                (* line 416 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         yySynAttribute . PaRefany (* ScopeRef *) := yyAttributeStack^[yyStackPtr+1] . PaRefany ;
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ;
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ;
                       END ; 
                     
              | 305,211 => (* P25 Module (110): ModuleMiddle BlockDeclList StkRwBEGIN StmtList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 7); yyNonterminal := 110;
                (* line 428 of "FM3Parser.lalr" *)
                 VAR LUnitRef : FM3Units . UnitRefTyp ;
                       VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         LUnitRef := FM3Units . UnitStackTopRef ;
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3ParsePass . DeclScopeRtL2R ( LScopeRef ) ;
                         <* ASSERT FM3Scopes . PopLookupScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
                         <* ASSERT FM3Scopes . PopDeclScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo ) ; 
                         FM3ParsePass . CheckUnitFinalId
                           ( FM3Units . UnitStackTopRef
                           , yyAttributeStack^[yyStackPtr+6] . Scan . SaAtom
                           , Ukt . UkModule
                           , yyAttributeStack^[yyStackPtr+6] . Scan . Position 
                           ) ;
                         FM3ParsePass . Push_LCIP_eCiP_riP 
                           ( Itk . ItkModuleLt
                           , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                           , LUnitRef ^ . UntUnitNo 
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+3] . Scan . Position
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                           ) ; 
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 306,215 => (* P26 GenInterfaceLt (134): StkRwGENERIC StkRwINTERFACE UnitId .*)
                DEC (yyStackPtr, 3); yyNonterminal := 134;
                (* line 460 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN 
                         yySynAttribute . PaBool := yyAttributeStack^[yyStackPtr+1] . PaBool ;
                         yySynAttribute . PaByte := ORD ( Ukt . UkInterface ) ; 
                         LScopeRef 
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkInterface
                                , FM3Scanner . Attribute . Position
                                ) ;
                         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 307,213 => (* P27 GenInterface (111): GenInterfaceLt GenInterfaceKind GenFormalList StkSemicolon Imports BlockDeclList StkRwEND StkIdent StkDot .*)
                DEC (yyStackPtr, 9); yyNonterminal := 111;
                (* line 478 of "FM3Parser.lalr" *)
                 (* Scope ref:
                        FM3ParsePass . Push_LI ( Itk . ItkDeclScopeLt , yyAttributeStack^[yyStackPtr+1] . PaConstructNo ) ;
                       *) 
                     
              | 308,216 => (* P28 GenModuleLt (136): StkRwGENERIC StkRwMODULE UnitId .*)
                DEC (yyStackPtr, 3); yyNonterminal := 136;
                (* line 484 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN 
                         yySynAttribute . PaBool := yyAttributeStack^[yyStackPtr+1] . PaBool ;
                         yySynAttribute . PaByte := ORD ( Ukt . UkInterface ) ;
                         LScopeRef  
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkModule
                                , FM3Scanner . Attribute . Position
                                ) ;
                         FM3Units . UnitStackTopRef ^ . UntScopeNo := LScopeRef . ScpScopeNo ;
                         yySynAttribute . PaRefany := LScopeRef ;   
                       END ; 
                     
              | 309,214 => (* P29 GenModule (112): GenModuleLt GenModuleKind GenFormalList StkSemicolon Imports Block StkIdent StkDot .*)
                DEC (yyStackPtr, 8); yyNonterminal := 112;
                (* line 502 of "FM3Parser.lalr" *)
                 (* scope ref
                          FM3ParsePass . Push_LI ( Itk . ItkDeclScopeLt , yyAttributeStack^[yyStackPtr+1] . PaConstructNo ) ;
                       *) 
                     
              | 310,146 => (* P30 OptUnsafe (125): StkRwUNSAFE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 125;
                (* line 508 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Unsafe.*) := TRUE ; 
              | 311 => (* P31 OptUnsafe (125): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 125;
                (* line 509 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; 
              | 312 => (* P32 CaptureCoord (138): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 138;
                (* line 512 of "FM3Parser.lalr" *)
                 yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ; 
              | 313 => (* P33 OptSemicolon (139): StkSemicolon .*)
                DEC (yyStackPtr, 1); yyNonterminal := 139;

              | 314 => (* P34 OptSemicolon (139): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 139;

              | 315,149 => (* P35 IdentRef (140): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 140;
                (* line 520 of "FM3Parser.lalr" *)
                 FM3ParsePass . IdentRefL2R ( yyAttributeStack^[yyStackPtr+1] ) ; 
              | 316 => (* P36 IdPlusList (141): IdentRef .*)
                DEC (yyStackPtr, 1); yyNonterminal := 141;
                (* line 524 of "FM3Parser.lalr" *)
                 (* PaUnnestCoord copied from yyAttributeStack^[yyStackPtr+1] by parser. *) 
                       yySynAttribute . PaInt := 1 ;
                     
              | 317 => (* P37 IdPlusList (141): IdPlusList StkComma IdentRef .*)
                DEC (yyStackPtr, 3); yyNonterminal := 141;
                (* line 528 of "FM3Parser.lalr" *)
                 (* PaUnnestCoord copied from yyAttributeStack^[yyStackPtr+1] by parser. *) 
                       yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;
                     
              | 318,186 => (* P38 DeclIdListElems (142): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 142;
                (* line 540 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Valid Id count. *)
                         := ORD
                              ( FM3ParsePass . DeclIdL2R
                                  ( Itk . ItkDeclId 
                                  , FM3Decls . TopDeclInfo ( ) . DiKind
                                  , IdAttribute := yyAttributeStack^[yyStackPtr+1]
                                  )
                              ) ;
                     
              | 319,187 => (* P39 DeclIdListElems (142): DeclIdListElems StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 142;
                (* line 551 of "FM3Parser.lalr" *)
                 IF FM3ParsePass . DeclIdL2R
                            ( Itk . ItkDeclId 
                            , FM3Decls . TopDeclInfo ( ) . DiKind
                            , IdAttribute := yyAttributeStack^[yyStackPtr+3]
                            )
                       (* ^No Itk separators here.  It would be kinda silly. *) 
                       THEN (* Use this ident. *) yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;  
                       ELSE yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid Id count, no increase. *) ; 
                       END (*IF*) ;
                     
              | 320,227 => (* P40 IdStarList (143): IdStarList StkComma IdentRef .*)
                DEC (yyStackPtr, 3); yyNonterminal := 143;
                (* line 564 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ; 
              | 321 => (* P41 IdStarList (143): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 143;
                (* line 566 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ; 
              | 322,260 => (* P42 QualIdStarList (144): QualIdStarList StkComma QualId .*)
                DEC (yyStackPtr, 3); yyNonterminal := 144;
                (* line 570 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ; 
              | 323 => (* P43 QualIdStarList (144): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 144;
                (* line 572 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ; 
              | 324 => (* P44 QualId (145): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 145;
                (* line 575 of "FM3Parser.lalr" *)
                 FM3ParsePass . IdentRefL2R ( yyAttributeStack^[yyStackPtr+1] ) ; 
              | 325,165 => (* P45 QualId (145): StkIdent StkDot StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 145;
                (* line 578 of "FM3Parser.lalr" *)
                 FM3ParsePass . QualIdentL2R ( yyAttributeStack^[yyStackPtr+1] , yyAttributeStack^[yyStackPtr+3] ) ; 
              | 326,236 => (* P46 TypeId (146): QualId .*)
                DEC (yyStackPtr, 1); yyNonterminal := 146;

              | 327,183 => (* P47 TypeId (146): StkRwROOT .*)
                DEC (yyStackPtr, 1); yyNonterminal := 146;
                (* line 587 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LIP
                         ( Itk . ItkReservedId , Stk . RidROOT , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ; 
                     
              | 328,185 => (* P48 TypeId (146): StkRwUNTRACED StkRwROOT .*)
                DEC (yyStackPtr, 2); yyNonterminal := 146;
                (* line 592 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LIP
                         ( Itk . ItkReservedId , Stk . RidUNTRACEDROOT , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ; 
                     
              | 329,224 => (* P49 Imports (128): ImportsLt ImportsRecurse ImportsRt .*)
                DEC (yyStackPtr, 3); yyNonterminal := 128;
                (* line 599 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt (* Imported interface Count. *) ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+2] . PaLong (* Imported unqualified Ident Count. *) ;
                     
              | 330 => (* P50 ImportsLt (147): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 147;
                (* line 602 of "FM3Parser.lalr" *)
                 FM3ParsePass . ImportsLt ( ) ; 
              | 331 => (* P51 ImportsRt (149): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 149;
                (* line 603 of "FM3Parser.lalr" *)
                 FM3ParsePass . ImportsRt ( ) ; 
              | 332,225 => (* P52 ImportsRecurse (148): ImportsRecurse ImportItem .*)
                DEC (yyStackPtr, 2); yyNonterminal := 148;
                (* line 605 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong + yyAttributeStack^[yyStackPtr+2] . PaLong ;
                     
              | 333 => (* P53 ImportsRecurse (148): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 148;
                (* line 609 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0; 
                       yySynAttribute . PaLong := 0L; 
                     
              | 334,152 => (* P54 ImportItem (150): StkRwIMPORT ImportIntfPlusList StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 150;
                (* line 615 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       yySynAttribute . PaLong := 0L ; 
                     
              | 335,151 => (* P55 ImportIntfPlusList (151): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 151;
                (* line 619 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 ;
                       FM3ParsePass . Import
                         ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ; 
                       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
                       FM3ParsePass . Push_LI3
                         ( Itk . ItkImport
                         , yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Column
                         ) ;
                     
              | 336,153 => (* P56 ImportIntfPlusList (151): ImportIntfPlusList StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 151;
                (* line 631 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 ;
                       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
                       FM3ParsePass . Import
                         ( yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom , yyAttributeStack^[yyStackPtr+3] . Scan . Position ) ; 
                       FM3ParsePass . Push_LI3
                         ( Itk . ItkImport
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Column
                         ) ;
                     
              | 337,154 => (* P57 ImportItem (150): FromImportPlusList StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 150;
                (* line 645 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong ; 
                     
              | 338,150 => (* P58 FromImportPlusList (152): StkRwFROM IdentRef StkRwIMPORT StkIdent .*)
                DEC (yyStackPtr, 4); yyNonterminal := 152;
                (* line 649 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 (* InterfaceCt. *) ;
                       yySynAttribute . PaLong := 1L ;
                       yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+2] . Scan . Position ; 
                       FM3ParsePass . FromImport
                         ( yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position 
                         , yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position 
                         ) ; 
                       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
                       FM3ParsePass . Push_LI6
                         ( Itk . ItkFromImport
                           (* Interface operands on left, then Decl ID items on Right. *) 
                         , yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position . Column
                         , yyAttributeStack^[yyStackPtr+4] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+4] . Scan . Position . Column
                         ) ;
                     
              | 339,226 => (* P59 FromImportPlusList (152): FromImportPlusList StkComma IdentRef .*)
                DEC (yyStackPtr, 3); yyNonterminal := 152;
                (* line 672 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 ;
                       yySynAttribute . PaLong := yyAttributeStack^[yyStackPtr+1] . PaLong + 1L ;
                       yySynAttribute . Scan . SaAtom := yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       FM3ParsePass . FromImport
                         ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position 
                         ) ; 
                       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
                       FM3ParsePass . Push_LI6
                         ( Itk . ItkFromImport
                           (* Interface operands on left, then Decl ID items on Right. *) 
                         , yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position . Column
                         , yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Line
                         , yyAttributeStack^[yyStackPtr+3] . Scan . Position . Column
                         ) ;
                     
              | 340 => (* P60 Exports (118): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 118;
                (* line 713 of "FM3Parser.lalr" *)
                
                
                       (* FM3Extern . GetExternInterface
                            ( 1 . Scan . SaAtom , IsImport := FALSE ) ;
                       *) 
                     
              | 341 => (* P61 Exports (118): StkRwEXPORTS ExportPlus .*)
                DEC (yyStackPtr, 2); yyNonterminal := 118;

              | 342,208 => (* P62 ExportPlus (153): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 153;
                (* line 723 of "FM3Parser.lalr" *)
                 EVAL FM3Extern . GetExternInterface
                              ( yyAttributeStack^[yyStackPtr+1] . Scan . SaAtom , IsImport := FALSE ) ;
                     
              | 343,209 => (* P63 ExportPlus (153): ExportPlus StkComma StkIdent .*)
                DEC (yyStackPtr, 3); yyNonterminal := 153;
                (* line 728 of "FM3Parser.lalr" *)
                 EVAL FM3Extern . GetExternInterface
                              ( yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom , IsImport := FALSE ) ;
                     
              | 344,212 => (* P64 GenFormalList (135): StkOpenParen IdStarList StkCloseParen .*)
                DEC (yyStackPtr, 3); yyNonterminal := 135;
                (* line 736 of "FM3Parser.lalr" *)
                 MakeListPos 
                         ( yySynAttribute , Itk. ItkGenFormalIdListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                     
              | 345,155 => (* P65 GenActualList (127): StkOpenParen IdStarList StkCloseParen .*)
                DEC (yyStackPtr, 3); yyNonterminal := 127;
                (* line 742 of "FM3Parser.lalr" *)
                 (* Handle this in pass 1.
                          MakeListPos
                            ( yySynAttribute , Itk. ItkGenActualIdListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                       *) 
                     
              | 346 => (* P66 OptConstType (155): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 155;
                (* line 751 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := TRUE ; 
              | 347 => (* P67 OptConstType (155): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 155;
                (* line 753 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ; 
              | 348,157 => (* P68 ConstDeclGroupLt (156): StkRwCONST .*)
                DEC (yyStackPtr, 1); yyNonterminal := 156;
                (* line 762 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
              | 349,234 => (* P69 ConstDeclGroup (158): ConstDeclGroupLt ConstDeclList .*)
                DEC (yyStackPtr, 2); yyNonterminal := 158;
                (* line 765 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                        yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+2] . PaPos ; 
                      
              | 350 => (* P70 ConstDeclList (157): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 157;
                (* line 770 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ;
                       yySynAttribute . PaPos (* No trailing semicolon exists *)
                         := FM3Scanner . Attribute . Position ; 
                     
              | 351 => (* P71 ConstDeclList (157): ConstDeclPlus .*)
                DEC (yyStackPtr, 1); yyNonterminal := 157;
                (* line 776 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 352,195 => (* P72 ConstDeclPlus (159): ConstDecl StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 159;
                (* line 781 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+2] . Scan . Position ; 
                     
              | 353,180 => (* P73 ConstDeclPlus (159): ConstDeclPlus ConstDecl StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 159;
                (* line 786 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       IF yyAttributeStack^[yyStackPtr+2] . PaInt > 0
                       THEN  
                         yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+3] . Scan . Position ;
                         FM3ParsePass . Push_ECIP (* Insert a separator. *)
                           ( Itk . ItkBlockDeclListLt
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                           , yyAttributeStack^[yyStackPtr+1] . PaInt
                           , yyAttributeStack^[yyStackPtr+1] . PaPos (* Rt semicolon of yyAttributeStack^[yyStackPtr+1] *) 
                           ) ;
                       ELSE 
                         yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                       END (*IF*) ;  
                     
              | 354,179 => (* P74 ConstDeclId (161): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 161;
                (* line 804 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Ident count, 0 or 1. *) 
                         := ORD ( FM3ParsePass . DeclIdL2R
                                    ( Itk . ItkDeclId , Dkt . DkConst , yyAttributeStack^[yyStackPtr+1] )
                                ) 
                     
              | 355 => (* P75 ConstDecl (160): ConstDeclId OptDeclType StkEqual Expr .*)
                DEC (yyStackPtr, 4); yyNonterminal := 160;
                (* line 811 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Contribution to BlockDecl count. *) ;
                       IF yySynAttribute . PaInt > 0 
                       THEN 
                         FM3ParsePass . Push_LCP_eCPB_zCP_rP
                           ( Itk . ItkConstDeclLt 
                           , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                           , yyAttributeStack^[yyStackPtr+2] . PaBool (* Is present. *) 
                           
                           , yyAttributeStack^[yyStackPtr+4] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+3] . Scan . Position
                           
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                           ) ;
                       ELSE (* Skip the decl. *) 
                         FM3ParsePass . Push_LCIri
                           ( Itk . ItkSkipLt , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , FM3Globals . NextSkipNo ) ;
                         INC ( FM3Globals . NextSkipNo ) ;
                       END (*IF*) ;
                     
              | 356,198 => (* P76 TypeRelation (164): StkEqual .*)
                DEC (yyStackPtr, 1); yyNonterminal := 164;
                (* line 837 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := Itk . ItkTypeDeclLt ; 
              | 357,199 => (* P77 TypeRelation (164): StkSubtype .*)
                DEC (yyStackPtr, 1); yyNonterminal := 164;
                (* line 839 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := Itk . ItkSubtypeDeclLt ; 
              | 358,163 => (* P78 TypeDeclGroupLt (165): StkRwTYPE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 165;
                (* line 850 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
              | 359,268 => (* P79 TypeDeclGroup (167): TypeDeclGroupLt TypeDeclList .*)
                DEC (yyStackPtr, 2); yyNonterminal := 167;
                (* line 853 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                        yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+2] . PaPos ; 
                      
              | 360 => (* P80 TypeDeclList (166): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 166;
                (* line 858 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ;
                       yySynAttribute . PaPos (* No trailing semicolon exists *)
                         := FM3Scanner . Attribute . Position ; 
                     
              | 361 => (* P81 TypeDeclList (166): TypeDeclPlus .*)
                DEC (yyStackPtr, 1); yyNonterminal := 166;
                (* line 864 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 362,200 => (* P82 TypeDeclPlus (168): TypeDecl StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 168;
                (* line 869 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+2] . Scan . Position ; 
                     
              | 363,197 => (* P83 TypeDeclPlus (168): TypeDeclPlus TypeDecl StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 168;
                (* line 874 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       IF yyAttributeStack^[yyStackPtr+2] . PaInt > 0
                       THEN  
                         yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+3] . Scan . Position ;
                         FM3ParsePass . Push_ECIP (* Insert a separator. *)
                           ( Itk . ItkBlockDeclListLt
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                           , yyAttributeStack^[yyStackPtr+1] . PaInt
                           , yyAttributeStack^[yyStackPtr+1] . PaPos (* Rt semicolon of yyAttributeStack^[yyStackPtr+1] *) 
                           ) ;
                       ELSE 
                         yySynAttribute . PaPos (* Rt semicolon.*) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                       END (*IF*) ;  
                     
              | 364,196 => (* P84 TypeDeclId (170): StkIdent .*)
                DEC (yyStackPtr, 1); yyNonterminal := 170;
                (* line 890 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Ident count, 0 or 1. *) 
                         := ORD ( FM3ParsePass . DeclIdL2R
                                    ( Itk . ItkDeclId , Dkt . DkType , yyAttributeStack^[yyStackPtr+1] )
                                ) 
                     
              | 365,269 => (* P85 TypeDecl (169): TypeDeclId TypeRelation Type .*)
                DEC (yyStackPtr, 3); yyNonterminal := 169;
                (* line 897 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Contribution to BlockDecl count. *) ;
                       IF yySynAttribute . PaInt > 0 
                       THEN 
                         FM3ParsePass . Push_LCP_eCP_rP
                           ( yyAttributeStack^[yyStackPtr+2] . PaTok1 
                           , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                           ) ;
                       ELSE (* Skip the decl. *) 
                         FM3ParsePass . Push_LCIri
                           ( Itk . ItkSkipLt , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , FM3Globals . NextSkipNo ) ;
                         INC ( FM3Globals . NextSkipNo ) ;
                       END (*IF*) ;
                     
              | 366,201 => (* P86 RevelationRelation (171): StkEqual .*)
                DEC (yyStackPtr, 1); yyNonterminal := 171;
                (* line 917 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := Itk . ItkFullRevealLt ; 
              | 367,202 => (* P87 RevelationRelation (171): StkSubtype .*)
                DEC (yyStackPtr, 1); yyNonterminal := 171;
                (* line 919 of "FM3Parser.lalr" *)
                 yySynAttribute . PaTok1 := Itk . ItkPartialRevealLt ; 
              | 368,162 => (* P88 RevelationGroupLt (172): StkRwREVEAL .*)
                DEC (yyStackPtr, 1); yyNonterminal := 172;
                (* line 930 of "FM3Parser.lalr" *)
                  yySynAttribute. Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position  
              | 369,272 => (* P89 RevelationGroup (174): RevelationGroupLt RevelationList .*)
                DEC (yyStackPtr, 2); yyNonterminal := 174;
                (* line 933 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                        yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+2] . PaPos ; 
                      
              | 370 => (* P90 RevelationList (173): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 173;
                (* line 938 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 ;
                       yySynAttribute . PaPos (* No trailing semicolon exists. *)
                         := FM3Scanner . Attribute . Position ; 
                     
              | 371 => (* P91 RevelationList (173): RevelationPlus .*)
                DEC (yyStackPtr, 1); yyNonterminal := 173;
                (* line 944 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 372,204 => (* P92 RevelationPlus (175): Revelation StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 175;
                (* line 949 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+2] . Scan . Position ; 
                     
              | 373,203 => (* P93 RevelationPlus (175): RevelationPlus Revelation StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 175;
                (* line 954 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       IF yyAttributeStack^[yyStackPtr+2] . PaInt > 0
                       THEN 
                         yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+3] . Scan . Position ; 
                         FM3ParsePass . Push_ECIP (* Insert a separator. *) 
                           ( Itk . ItkBlockDeclListLt
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                           , yyAttributeStack^[yyStackPtr+1] . PaInt
                           , yyAttributeStack^[yyStackPtr+1] . PaPos 
                           ) ;
                       ELSE
                         yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                       END (*IF*) ; 
                     
              | 374,271 => (* P94 Revelation (176): TypeId RevelationRelation Type .*)
                DEC (yyStackPtr, 3); yyNonterminal := 176;
                (* line 970 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 (* BlockDecl count. *) ;
                (* CHECK^ Do we really want to count this as a block decl?  It occupies a 
                          space in the Blockdecl list, but does not introduce a new identifier,
                          but adds decl info about the identifier.
                *) 
                       FM3ParsePass . Push_LCP_eCP_rP
                         ( yyAttributeStack^[yyStackPtr+2] . PaTok1 
                         , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                         ) ;
                     
              | 375,164 => (* P95 VarDeclGroupLt (177): StkRwVAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 177;
                (* line 997 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* DeclInfoDepth *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiDeclTok := Itk . ItkVarDeclLt
                                  , DiIdListTok := Itk . ItkVarDeclIdListLt
                                  , DiIdTok := Itk . ItkDeclId
                                  , DiIdSepTok := Itk . ItkVarDeclIdListLt + Itk . LtToListSep
                                  , DiKind := Dkt . DkVar
                                  }
                              ) ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position;
                     
              | 376,274 => (* P96 VarDeclGroup (179): VarDeclGroupLt VarDeclList .*)
                DEC (yyStackPtr, 2); yyNonterminal := 179;
                (* line 1011 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+2] . PaInt ;
                        yySynAttribute . PaPos (* Rt Semicolon. *) := yyAttributeStack^[yyStackPtr+2] . PaPos ;  
                        <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt *>
                      
              | 377 => (* P97 VarDeclList (178): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 178;
                (* line 1017 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 0 (* Decl count. *) ;
                        yySynAttribute . PaPos (* No trailing semicolon exists. *)
                          := FM3Scanner.Attribute . Position ; 
                        (*Push_LIP_rip
                          ( Itk . ItkVarDeclListLt , 0 , FM3Scanner . Attribute . Position ) ;
                        *)
                      
              | 378 => (* P98 VarDeclList (178): VarDeclPlus .*)
                DEC (yyStackPtr, 1); yyNonterminal := 178;
                (* line 1026 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Decl count. *) ;
                       yySynAttribute . PaPos (* Rt Semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ;  
                
                       (*FM3ParsePass . MakeListPos
                         ( yySynAttribute
                         , Itk . ItkVarDeclListLt
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+1] (* For element count & Left patch coord. *) 
                         ) ;
                       *) 
                     
              | 379,206 => (* P99 VarDeclPlus (180): VarDecl StkSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 180;
                (* line 1039 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt Semicolon. *) := yyAttributeStack^[yyStackPtr+2] . Scan . Position ;  
                     
              | 380,205 => (* P100 VarDeclPlus (180): VarDeclPlus VarDecl StkSemicolon .*)
                DEC (yyStackPtr, 3); yyNonterminal := 180;
                (* line 1044 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt ;
                       IF yyAttributeStack^[yyStackPtr+2] . PaInt > 0
                       THEN 
                         yySynAttribute . PaPos (* Rt Semicolon. *) := yyAttributeStack^[yyStackPtr+3] . Scan . Position ;  
                         FM3ParsePass . Push_ECIP (* Insert a separator. *) 
                           ( Itk . ItkBlockDeclListLt
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                           , yyAttributeStack^[yyStackPtr+1] . PaInt
                           , yyAttributeStack^[yyStackPtr+1] . PaPos 
                           ) ;
                       ELSE
                         yySynAttribute . PaPos (* Rt Semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ;  
                       END (*IF*) ; 
                     
              | 381,256 => (* P101 VarDecl (181): VarDeclIds OptDeclType OptDeclValue .*)
                DEC (yyStackPtr, 3); yyNonterminal := 181;
                (* line 1062 of "FM3Parser.lalr" *)
                 IF FM3ParsePass . RequireTypeAndOrValue
                             ( yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] . PaBool , yyAttributeStack^[yyStackPtr+3] . PaBool ) 
                       (* ^Check this even if there are no valid ids. *)
                          AND yyAttributeStack^[yyStackPtr+1] . PaInt > 0 
                       THEN 
                         yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid id count. *) ;
                         WITH WDeclInfo = FM3Decls . TopDeclInfo ( )
                         DO 
                           FM3ParsePass . Push_LCP_eCP_zCP_rP (* The declaration itself. *) 
                             ( WDeclInfo . DiDeclTok 
                             , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+3] . Scan . Position 
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                            ) ;
                         END (*WITH*)
                       ELSE (* Skip the decl. *) 
                         FM3ParsePass . Push_LCIri
                           ( Itk . ItkSkipLt , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , FM3Globals . NextSkipNo ) ;
                         INC ( FM3Globals . NextSkipNo ) ; 
                         yySynAttribute . PaInt := 0 (* Contribution to BlockDeclCt. *) ; 
                       END (*IF*)
                     
              | 382 => (* P102 VarDeclIds (182): DeclIdListElems .*)
                DEC (yyStackPtr, 1); yyNonterminal := 182;
                (* line 1090 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid id count. *) ;
                       MakeListPos (* The identifier list. *) 
                         ( yySynAttribute
                         , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                (* CHECK: Do we still want different decl id tokens? *) 
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , ElemsAttr := yyAttributeStack^[yyStackPtr+1]
                         ) ; 
                     
              | 383,266 => (* P103 OptDeclType (162): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 162;
                (* line 1102 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := TRUE ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                     
              | 384 => (* P104 OptDeclType (162): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 162;
                (* line 1106 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ; 
                     
              | 385 => (* P105 OptDeclValue (183): StkBecomes Expr .*)
                DEC (yyStackPtr, 2); yyNonterminal := 183;
                (* line 1110 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := TRUE ;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                     
              | 386 => (* P106 OptDeclValue (183): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 183;
                (* line 1114 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ; 
                     
              | 387,237 => (* P107 Type (154): TypeId .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 388,238 => (* P108 Type (154): StkRwREF Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 154;
                (* line 1123 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LCP_rp
                         ( Itk . ItkREFDefLt
                         , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                         ) ;
                     
              | 389,239 => (* P109 Type (154): StkRidADDRESS .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 390,240 => (* P110 Type (154): StkRidBOOLEAN .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 391,241 => (* P111 Type (154): StkRidCARDINAL .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 392,242 => (* P112 Type (154): StkRidCHAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 393,243 => (* P113 Type (154): StkRidEXTENDED .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 394,244 => (* P114 Type (154): StkRidINTEGER .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 395,245 => (* P115 Type (154): StkRidLONGCARD .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 396,246 => (* P116 Type (154): StkRidLONGINT .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 397,247 => (* P117 Type (154): StkRiDLONGREAL .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 398,248 => (* P118 Type (154): StkRidMUTEX .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 399,249 => (* P119 Type (154): StkRidNULL .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 400,250 => (* P120 Type (154): StkRidREAL .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 401,251 => (* P121 Type (154): StkRidREFANY .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 402,252 => (* P122 Type (154): StkRidTEXT .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 403,253 => (* P123 Type (154): StkRidTYPECODE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 404,254 => (* P124 Type (154): StkRidWIDECHAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 154;

              | 405,181 => (* P125 Type (154): StkRwOBJECT StkRwEND .*)
                DEC (yyStackPtr, 2); yyNonterminal := 154;

              | 406,184 => (* P126 Type (154): StkRwUNTRACED StkRwOBJECT StkRwEND .*)
                DEC (yyStackPtr, 3); yyNonterminal := 154;

              | 407 => (* P127 FieldDeclList (200): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 200;
                (* line 1155 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LIP_rip
                          ( Itk . ItkFieldDeclListLt , 0 , FM3Scanner . Attribute . Position ) ; 
                      
              | 408,258 => (* P128 FieldDeclList (200): FieldDeclPlus OptSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 200;
                (* line 1160 of "FM3Parser.lalr" *)
                 FM3ParsePass . MakeListPos
                         ( yySynAttribute
                         , Itk . ItkFieldDeclListLt
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+1] (* For element count & Left patch coord. *) 
                         ) ;
                     
              | 409,255 => (* P129 FieldDeclPlus (201): VarDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 201;
                (* line 1169 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *) := yyAttributeStack^[yyStackPtr+1] . PaInt ; 
              | 410,257 => (* P130 FieldDeclPlus (201): FieldDeclPlus StkSemicolon VarDecl .*)
                DEC (yyStackPtr, 3); yyNonterminal := 201;
                (* line 1172 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt (* Decl count. *):= yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+3] . PaInt ;
                       FM3ParsePass . Push_ECIP
                         ( Itk . ItkFieldDeclListLt
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                         , yyAttributeStack^[yyStackPtr+1] . PaInt
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         ) ; 
                     
              | 411,182 => (* P131 RecTypeLt (202): StkRwRECORD .*)
                DEC (yyStackPtr, 1); yyNonterminal := 202;
                (* line 1184 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN 
                         yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ;
                         yySynAttribute . PaInt (* DeclInfoDepth *) 
                           := FM3Decls . PushDeclInfo
                                ( FM3Decls . DeclInfoTyp
                                    { DiDeclTok := Itk . ItkFieldDeclLt
                                    , DiIdListTok := Itk . ItkFieldDeclIdListLt
                                    , DiIdTok := Itk . ItkDeclId
                                    , DiIdSepTok := Itk . ItkFieldDeclIdListLt + Itk . LtToListSep
                                    , DiKind := Dkt . DkRecField 
                                    }
                                ) ;
                         LScopeRef 
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkRec
                                , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                                ) ;
                (* TODO: Store scope ref in record. *) 
                         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ;
                (* TODO: Store LScopeRef or its ScopeNo in the record type. *) 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
                         yySynAttribute . PaRefany := LScopeRef ;  
                       END; 
                     
              | 412,188 => (* P132 Type (154): RecTypeLt FieldDeclList StkRwEND .*)
                DEC (yyStackPtr, 3); yyNonterminal := 154;
                (* line 1213 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3ParsePass . DeclScopeRtL2R ( LScopeRef ) ;
                         <* ASSERT FM3Scopes . PopDeclScope ( ) = LScopeRef *>  
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
                         FM3ParsePass . Push_LCIP_rip
                           ( Itk . ItkRecDefLt
                           , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+2] . PaInt (* Count of decls, fields, formals, etc. *) 
                           , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                           ) ;
                         <* ASSERT FM3Decls . PopDeclInfo ( )
                                   = yyAttributeStack^[yyStackPtr+1] . PaInt (* DeclInfoDepth. *)
                            *> 
                       END; 
                     
              | 413,235 => (* P133 Type (154): StkRwPROCEDURE Signature .*)
                DEC (yyStackPtr, 2); yyNonterminal := 154;
                (* line 1235 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LCP_rp
                         ( Itk . ItkProcTypeLt , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                     
              | 414,261 => (* P134 Signature (203): Formals ResultType Raises .*)
                DEC (yyStackPtr, 3); yyNonterminal := 203;
                (* line 1241 of "FM3Parser.lalr" *)
                 VAR LTok : Itk . TokTyp;
                       BEGIN
                         IF yyAttributeStack^[yyStackPtr+2] . PaBool (* Has result type *) 
                         THEN LTok := Itk . ItkFuncSignatureLt ;
                         ELSE LTok := Itk . ItkProcSignatureLt ;
                         END (*IF*);
                         FM3ParsePass . Push_LCP_rp
                           ( LTok,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                       END (*Block*) 
                     
              | 415,158 => (* P135 Formals (204): StkOpenParen StkCloseParen .*)
                DEC (yyStackPtr, 2); yyNonterminal := 204;
                (* line 1258 of "FM3Parser.lalr" *)
                 VAR LTok : Itk . TokTyp ;
                       VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         yySynAttribute . PaInt := 0 ; 
                         LScopeRef
                           := FM3ParsePass . ScopeEmpty
                                ( Skt . SkFormals , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ; 
                  (* TODO: Store empty formals scope ref somewhare. *) 
                           FM3ParsePass . Push_LI
                             ( Itk . ItkScopeEmpty , LScopeRef ^ . ScpScopeNo  ) ;
                         PushUnnest ( Itk . ItkFormalsListEmpty ) ;
                       END ; 
                     
              | 416 => (* P136 FormalsLt (207): StkOpenParen .*)
                DEC (yyStackPtr, 1); yyNonterminal := 207;
                (* line 1274 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         LScopeRef
                           := FM3Scopes . NewScopeRef
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkFormals
                                , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                                ) ;
                (* TODO: Store formals scope ref somewhare. *) 
                         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
                (* TODO: Store LScopeRef or its ScopeNo in the signature. *) 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo  ) ;
                         yySynAttribute . PaRefany := LScopeRef ;  
                       END ; 
                     
              | 417,194 => (* P137 Formals (204): FormalsLt FormalPlus OptSemicolon StkCloseParen .*)
                DEC (yyStackPtr, 4); yyNonterminal := 204;
                (* line 1293 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ;
                       BEGIN
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt ; 
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3ParsePass . DeclScopeRtL2R ( LScopeRef ) ;
                         <* ASSERT FM3Scopes . PopDeclScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo  ) ;
                         MakeListPos
                           ( yySynAttribute , Itk . ItkFormalsListLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                (* TODO: Save this scope somewhere, for use if there is a proc body. *) 
                (* FIXME^ different tokens for different formal modes. *)
                       END ;
                     
              | 418,262 => (* P138 FormalPlus (208): FormalPlus StkSemicolon Formal .*)
                DEC (yyStackPtr, 3); yyNonterminal := 208;
                (* line 1310 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+3] . PaInt ;
                       FM3ParsePass . Push_ECIP
                         ( Itk . ItkFormalsListLt 
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord 
                         , yyAttributeStack^[yyStackPtr+1] . PaInt 
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         ) ; 
                     
              | 419,265 => (* P139 FormalPlus (208): Formal .*)
                DEC (yyStackPtr, 1); yyNonterminal := 208;
                (* line 1320 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ; 
              | 420 => (* P140 FormalLt (210): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 210;
                (* line 1324 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position ;
                       yySynAttribute . PaByte := ORD ( Dkt . DkVALUEFormal ) ;  
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiDeclTok := Itk . ItkVALUEFormalLt
                                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                                  , DiIdTok := Itk . ItkDeclId
                                  , DiIdSepTok
                                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                                  , DiKind := Dkt . DkVALUEFormal
                                  }
                              ) ;
                     
              | 421,192 => (* P141 FormalLt (210): StkRwVALUE .*)
                DEC (yyStackPtr, 1); yyNonterminal := 210;
                (* line 1339 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                       yySynAttribute . PaByte := ORD ( Dkt . DkVALUEFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiDeclTok := Itk . ItkVALUEFormalLt
                                  , DiIdListTok := Itk . ItkVALUEFormalIdListLt 
                                  , DiIdTok := Itk . ItkDeclId
                                  , DiIdSepTok
                                      := Itk . ItkVALUEFormalIdListLt + Itk . LtToListSep
                                  , DiKind := Dkt . DkVALUEFormal
                                  }
                              ) ;
                     
              | 422,193 => (* P142 FormalLt (210): StkRwVAR .*)
                DEC (yyStackPtr, 1); yyNonterminal := 210;
                (* line 1355 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       yySynAttribute . PaByte := ORD ( Dkt . DkVARFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiDeclTok := Itk . ItkVARFormalLt
                                  , DiIdListTok := Itk . ItkVARFormalIdListLt 
                                  , DiIdTok := Itk . ItkDeclId
                                  , DiIdSepTok := Itk . ItkVARFormalIdListLt + Itk . LtToListSep
                                  , DiKind := Dkt . DkVARFormal
                                  }
                              ) ;
                     
              | 423,191 => (* P143 FormalLt (210): StkRwREADONLY .*)
                DEC (yyStackPtr, 1); yyNonterminal := 210;
                (* line 1369 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       yySynAttribute . PaByte := ORD ( Dkt . DkROFormal ) ;
                       yySynAttribute . PaInt (* DeclInfoDepth after push. *) 
                         := FM3Decls . PushDeclInfo
                              ( FM3Decls . DeclInfoTyp
                                  { DiDeclTok := Itk . ItkROFormalLt
                                  , DiIdListTok := Itk . ItkROFormalIdListLt 
                                  , DiIdTok := Itk . ItkDeclId
                                  , DiIdSepTok := Itk . ItkROFormalIdListLt + Itk . LtToListSep
                                  , DiKind := Dkt . DkROFormal
                                  }
                              ) ;
                     
              | 424,264 => (* P144 Formal (209): FormalLt FormalIds FormalType FormalExpr .*)
                DEC (yyStackPtr, 4); yyNonterminal := 209;
                (* line 1386 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       VAR LOk := TRUE ; 
                       BEGIN (* Do these checks even if no valid ids. *) 
                         IF VAL ( yyAttributeStack^[yyStackPtr+1] . PaByte , Dkt ) = Dkt . DkVARFormal   
                         THEN
                           IF NOT yyAttributeStack^[yyStackPtr+3] . PaBool (* Formal type is present (absent?). *)
                           THEN
                             FM3Messages . ErrorArr
                               ( ARRAY OF REFANY 
                                   { " VAR formal must have a type (2.2.8)." } 
                               , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                               ) ;
                             LOk := FALSE ; 
                           END (*IF*) ; 
                           IF yyAttributeStack^[yyStackPtr+4] . PaBool (* Formal expression is present? *) 
                           THEN
                             FM3Messages . ErrorArr
                               ( ARRAY OF REFANY 
                                   { " VAR formal cannot have a default expression (2.2.8)." }
                               , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                               ) ;
                             LOk := FALSE ; 
                           END (*IF*) ;
                         ELSE (* VALUE or READONLY *)  
                           LOk := FM3ParsePass . RequireTypeAndOrValue
                                    ( yyAttributeStack^[yyStackPtr+2] . Scan . Position , yyAttributeStack^[yyStackPtr+3] . PaBool , yyAttributeStack^[yyStackPtr+4] . PaBool )
                         END (*IF*) ;
                
                         LOk := LOk AND yyAttributeStack^[yyStackPtr+2] . PaInt > 0 ;
                         
                         IF NOT LOk 
                         THEN (* Skip the whole decl, including possibly multiple idents. *)
                           yySynAttribute . PaInt := 0 ;
                           FM3ParsePass . Push_LCIri
                             ( Itk . ItkSkipLt
                             , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                             , FM3Globals . NextSkipNo
                             ) ;
                           INC ( FM3Globals . NextSkipNo ) ;
                         ELSE 
                           yySynAttribute .PaInt := yyAttributeStack^[yyStackPtr+2] . PaInt (* Valid Id count. *) ;  
                           FM3ParsePass . Push_LCP_eCP_zCP_rP 
                             ( FM3Decls . TopDeclInfo ( ) . DiDeclTok 
                             , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+3] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+3] . Scan . Position
                             , yyAttributeStack^[yyStackPtr+4] . PaUnnestCoord
                             , yyAttributeStack^[yyStackPtr+4] . Scan . Position 
                             , yyAttributeStack^[yyStackPtr+1] . Scan . Position 
                             ) ;
                         END (*IF*) ;
                         <* ASSERT FM3Decls . PopDeclInfo ( ) = yyAttributeStack^[yyStackPtr+1] . PaInt *>
                       END (*Block*) 
                     
              | 425 => (* P145 FormalIds (211): DeclIdListElems .*)
                DEC (yyStackPtr, 1); yyNonterminal := 211;
                (* line 1444 of "FM3Parser.lalr" *)
                 yySynAttribute . Scan . Position  := yyAttributeStack^[yyStackPtr+1] . Scan . Position ; 
                       yySynAttribute .PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Valid Id Ct. *) ; 
                       MakeListPos
                         ( yySynAttribute
                         , FM3Decls . TopDeclInfo ( ) . DiIdListTok
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , ElemsAttr := yyAttributeStack^[yyStackPtr+1]
                         ) ; 
                     
              | 426,263 => (* P146 FormalType (212): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 212;
                (* line 1456 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Type is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position;
                (* This looks redundant to Itk<mode>FormalType & Itk<mode>FormalVal,
                   which already bracket the type of a formal. 
                       FM3ParsePass . Push_LCP_rp
                         ( Itk . ItkFormalTypeLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                *) 
                     
              | 427 => (* P147 FormalType (212): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 212;
                (* line 1465 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       FM3ParsePass . Push_LP
                         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
                     
              | 428 => (* P148 FormalExpr (213): StkBecomes Expr .*)
                DEC (yyStackPtr, 2); yyNonterminal := 213;
                (* line 1473 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Expr is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                (* This looks redundant to Itk<mode>FormalVal & Itk<mode>FormalRt,
                   which already bracket the type of a formal. 
                       FM3ParsePass . Push_LCP_rp
                         (  Itk . ItkFormalExprLt, yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                *) 
                     
              | 429 => (* P149 FormalExpr (213): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 213;
                (* line 1482 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       FM3ParsePass . Push_LP
                         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
                     
              | 430,259 => (* P150 ResultType (205): StkColon Type .*)
                DEC (yyStackPtr, 2); yyNonterminal := 205;
                (* line 1490 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Result type is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       FM3ParsePass . Push_LCP_rp
                         (Itk . ItkResultTypeLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position); 
                     
              | 431 => (* P151 ResultType (205): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 205;
                (* line 1496 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       FM3ParsePass . Push_LP
                         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
                       yySynAttribute . PaUnnestCoord := UnnestCoord ( ) ; 
                     
              | 432,189 => (* P152 Raises (206): StkRwRAISES StkRwANY .*)
                DEC (yyStackPtr, 2); yyNonterminal := 206;
                (* line 1505 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       FM3ParsePass . Push_LCP_rp
                         ( Itk . ItkRaisesANY ,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord , yyAttributeStack^[yyStackPtr+1] . Scan . Position); 
                     
              | 433,190 => (* P153 Raises (206): StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace .*)
                DEC (yyStackPtr, 4); yyNonterminal := 206;
                (* line 1512 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := TRUE;
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       MakeListPos ( yySynAttribute , Itk . ItkRaisesSetLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position , yyAttributeStack^[yyStackPtr+2] ) ;
                     
              | 434 => (* P154 Raises (206): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 206;
                (* line 1517 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
                       yySynAttribute . Scan . Position := FM3Scanner . Attribute . Position; 
                       FM3ParsePass . Push_LP
                         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
                     
              | 435,228 => (* P155 ProcDecl (215): StkRwPROCEDURE StkIdent Signature OptProcBody .*)
                DEC (yyStackPtr, 4); yyNonterminal := 215;
                (* line 1526 of "FM3Parser.lalr" *)
                 VAR LTokLt : Itk . TokTyp; 
                       BEGIN 
                         CASE FM3Units . UnitStackTopRef ^ . UntKind OF 
                         | Ukt . UkInterface 
                         , Ukt . UkGenInterface  
                         , Ukt . UkInstInterface  
                         => IF yyAttributeStack^[yyStackPtr+4] . PaBool 
                            THEN
                              FM3Messages . ErrorArr
                                ( ARRAY OF REFANY 
                                  { " A procedure in an interface must not have a body (2.5.2)." }
                                , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                                );  
                
                            END (*IF*); 
                            LTokLt := Itk . ItkProcNoBodyLt ; 
                         | Ukt . UkModule  
                         , Ukt . UkGenModule  
                         , Ukt . UkInstModule  
                         => IF NOT yyAttributeStack^[yyStackPtr+4] . PaBool 
                            THEN 
                              FM3Messages . ErrorArr
                                ( ARRAY OF REFANY
                                    { " A procedure in a module must have a body (2.5)." } 
                                , yyAttributeStack^[yyStackPtr+4] . Scan . Position
                                ); 
                            END (*IF*); 
                            LTokLt := Itk . ItkProcWBodyLt ; 
                (* TODO: Error recovery.  Insert or remove body. *) 
                         END (*CASE*);
                         FM3ParsePass . Push_LCIri
                           ( LTokLt,  yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord, yyAttributeStack^[yyStackPtr+2] . Scan . SaAtom ) ; 
                       END (*Block*) 
                     
              | 436,159 => (* P156 OptProcBody (214): StkSemicolon .*)
                DEC (yyStackPtr, 1); yyNonterminal := 214;
                (* line 1562 of "FM3Parser.lalr" *)
                 yySynAttribute . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
                       yySynAttribute . PaConstructNo := FM3Base . AtomNull ; 
                       yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position; 
                       FM3ParsePass . Push_LP ( Itk . ItkProcBodyAbsent , yyAttributeStack^[yyStackPtr+1] . Scan . Position ); 
                     
              | 437,160 => (* P157 ProcBodyLt (216): StkEqual .*)
                DEC (yyStackPtr, 1); yyNonterminal := 216;
                (* line 1569 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         FM3ParsePass . Push_LP
                           ( Itk . ItkProcBodyLt , yyAttributeStack^[yyStackPtr+1] . Scan . Position ) ;
                         LScopeRef
                           := FM3Scopes . NewScopeRef 
                                ( FM3Units . UnitStackTopRef
                                , Skt . SkProcBody 
                                , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                                ) ;
                (* TODO: Store scope ref in proc type. *) 
                
                (* TODO: check duplicates between signature scope and body scope. *) 
                         FM3Scopes . PushDeclScopeRef ( LScopeRef ) ; 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
                (* TODO: Push signature scope onto lookup stack. *) 
                         FM3Scopes . PushLookupScopeRef ( LScopeRef ) ; 
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeLt , LScopeRef ^ . ScpScopeNo ) ; 
                         yySynAttribute . PaRefany := LScopeRef ; 
                       END ; 
                     
              | 438,161 => (* P158 OptProcBody (214): ProcBodyLt Block StkIdent StkSemicolon .*)
                DEC (yyStackPtr, 4); yyNonterminal := 214;
                (* line 1595 of "FM3Parser.lalr" *)
                 VAR LScopeRef : FM3Scopes . ScopeRefTyp ; 
                       BEGIN
                         yySynAttribute . PaBool (* Procedure has a body. *) := TRUE ; 
                         yySynAttribute . PaConstructNo (* Procedure Id *) := yyAttributeStack^[yyStackPtr+3] . Scan . SaAtom ;
                         yySynAttribute . Scan . Position := yyAttributeStack^[yyStackPtr+1] . Scan . Position ;
                         LScopeRef := NARROW ( yyAttributeStack^[yyStackPtr+1] . PaRefany , FM3Scopes . ScopeRefTyp ) ; 
                         FM3ParsePass . DeclScopeRtL2R ( LScopeRef ) ;
                         <* ASSERT FM3Scopes . PopDeclScope ( ) = LScopeRef *>
                         <* ASSERT FM3Scopes . PopLookupScope ( ) = LScopeRef *>
                         FM3ParsePass . Push_LI
                           ( Itk . ItkLookupScopeRt , LScopeRef ^ . ScpScopeNo ) ;
                         FM3ParsePass . Push_LI
                           ( Itk . ItkDeclScopeRt , LScopeRef ^ . ScpScopeNo ) ;
                         FM3ParsePass . Push_LP
                           ( Itk . ItkProcBodyRt , yyAttributeStack^[yyStackPtr+1] . Scan . Position );
                       END;
                     
              | 439,229 => (* P159 Expr (163): QualId .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 440,166 => (* P160 Expr (163): StkIntLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 441,167 => (* P161 Expr (163): StkLongIntLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 442,168 => (* P162 Expr (163): StkBasedLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 443,169 => (* P163 Expr (163): StkLongBasedLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 444,170 => (* P164 Expr (163): StkRealLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 445,171 => (* P165 Expr (163): StkLongRealLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 446,172 => (* P166 Expr (163): StkExtendedLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 447,173 => (* P167 Expr (163): StkTextLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 448,174 => (* P168 Expr (163): StkWideTextLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 449,175 => (* P169 Expr (163): StkCharLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 450,176 => (* P170 Expr (163): StkWideCharLit .*)
                DEC (yyStackPtr, 1); yyNonterminal := 163;

              | 451,178 => (* P171 Expr (163): Expr StkDeref .*)
                DEC (yyStackPtr, 2); yyNonterminal := 163;

              | 452 => (* P172 BlockLt (217): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 217;
                (* line 1633 of "FM3Parser.lalr" *)
                
                     
              | 453,177 => (* P173 Block (137): BlockLt BlockDeclList StkRwBEGIN StmtList StkRwEND .*)
                DEC (yyStackPtr, 5); yyNonterminal := 137;
                (* line 1637 of "FM3Parser.lalr" *)
                
                     
              | 454,267 => (* P174 BlockDecl (218): ConstDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1643 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 455,270 => (* P175 BlockDecl (218): TypeDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1647 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 456,278 => (* P176 BlockDecl (218): ExceptDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1651 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 457,275 => (* P177 BlockDecl (218): VarDeclGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1655 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 458,276 => (* P178 BlockDecl (218): ProcDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1659 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := 1 ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 459,273 => (* P179 BlockDecl (218): RevelationGroup .*)
                DEC (yyStackPtr, 1); yyNonterminal := 218;
                (* line 1663 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 460 => (* P180 BlockDeclList (130): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 130;
                (* line 1671 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LIP_rip
                         ( Itk . ItkBlockDeclListLt , 0 , FM3Scanner . Attribute . Position ) ; 
                     
              | 461 => (* P181 BlockDeclList (130): BlockDeclPlus .*)
                DEC (yyStackPtr, 1); yyNonterminal := 130;
                (* line 1676 of "FM3Parser.lalr" *)
                 MakeListPos
                         ( yySynAttribute
                         , Itk . ItkBlockDeclListLt
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+1] (* Used for element count and left patch coordinate. *) 
                         ) ;
                     
              | 462,277 => (* P182 BlockDeclPlus (220): BlockDecl .*)
                DEC (yyStackPtr, 1); yyNonterminal := 220;
                (* line 1685 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Decl count. *) ;
                       yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                     
              | 463,279 => (* P183 BlockDeclPlus (220): BlockDeclPlus BlockDecl .*)
                DEC (yyStackPtr, 2); yyNonterminal := 220;
                (* line 1690 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + yyAttributeStack^[yyStackPtr+2] . PaInt (* Decl count. *) ;
                
                       IF yyAttributeStack^[yyStackPtr+2] . PaInt > 0
                       THEN
                         yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+2] . PaPos ; 
                         FM3ParsePass . Push_ECIP (* Insert a separator. *)
                           ( Itk . ItkBlockDeclListLt
                           , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                           , yyAttributeStack^[yyStackPtr+1] . PaInt
                           , yyAttributeStack^[yyStackPtr+1] . PaPos 
                           ) ;
                       ELSE 
                         yySynAttribute . PaPos (* Rt semicolon. *) := yyAttributeStack^[yyStackPtr+1] . PaPos ; 
                       END (*IF*) ; 
                     
              | 464 => (* P184 StmtList (133): .*)
                yyAttributeStack [ yyStackPtr + 1 ] . Scan . Position
    := FM3Scanner . Attribute . Position; 
yyNonterminal := 133;
                (* line 1709 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LIP_rip
                         ( Itk . ItkStmtListLt , 0 , FM3Scanner . Attribute . Position ) ; 
                     
              | 465,232 => (* P185 StmtList (133): StmtPlus OptSemicolon .*)
                DEC (yyStackPtr, 2); yyNonterminal := 133;
                (* line 1714 of "FM3Parser.lalr" *)
                 MakeListPos
                         ( yySynAttribute
                         , Itk . ItkStmtListLt
                         , yyAttributeStack^[yyStackPtr+1] . Scan . Position
                         , yyAttributeStack^[yyStackPtr+1] (* Used for element count and left patch coordinate. *) 
                         ) ;
                     
              | 466,233 => (* P186 StmtPlus (221): Stmt .*)
                DEC (yyStackPtr, 1); yyNonterminal := 221;
                (* line 1722 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt (* Stmt count. *) ; 
              | 467,230 => (* P187 StmtPlus (221): StmtPlus StkSemicolon Stmt .*)
                DEC (yyStackPtr, 3); yyNonterminal := 221;
                (* line 1725 of "FM3Parser.lalr" *)
                 yySynAttribute . PaInt := yyAttributeStack^[yyStackPtr+1] . PaInt + 1 (* Stmt count. *) ;
                       FM3ParsePass . Push_ECIP (* Internal separator. *)
                         ( Itk . ItkStmtListLt
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+1] . PaInt
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         ) ; 
                     
              | 468,231 => (* P188 Stmt (222): AssignStmt .*)
                DEC (yyStackPtr, 1); yyNonterminal := 222;

              | 469 => (* P189 AssignStmt (223): Expr StkBecomes Expr .*)
                DEC (yyStackPtr, 3); yyNonterminal := 223;
                (* line 1739 of "FM3Parser.lalr" *)
                 FM3ParsePass . Push_LCPeCprp
                         ( Itk . ItkBecomesLt
                         , yyAttributeStack^[yyStackPtr+1] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+2] . PaUnnestCoord
                         , yyAttributeStack^[yyStackPtr+2] . Scan . Position
                         ) ;
                     
              END (*CASE*);

          (* End of inserted semantic action code from the .lalr file: *)
(* -------------------------------------------------------------------------- *)

               (* Here, a reduction has been partially done.  yyStackPtr has
                  been decremented by the RHS length, yyNonterminal has been set
                  to the LHS NT of the reduced-by production (but has not been
                  pushed), and any Semantic actions have been performed,
                  which may have made assignments to yySynAttribute.  Now
                  do a nonterminal read transition on
                  yyStateStack^ [yyStackPtr] (* A state*) and yyNonterminal.
               *) 

               (* SPEC yyState 
                    := Next (Top (), yyNonterminal); nonterminal transition *)
               yyNCombPtr 
                 := LOOPHOLE 
                      ( LOOPHOLE
                          ( yyNBasePtr [yyStateStack^ [yyStackPtr]], INTEGER )
                          + (yyNonterminal-(yyLastTerminal+1))
                            * BYTESIZE (yyNCombType) 
                      , yyNCombTypePtr
                      );
               (*Any action*)yyState := yyNCombPtr^;
               
               INC (yyStackPtr) (* To push new LHS. *);
               WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
                    (* Tho' already popped by lalr-generated reduce action, this
                       is still present and may have a meaningful Position. *)
               DO
                 yyNTPos := WParsAttr . Scan . Position (* Parser debug.*) ;
                 (* ^Either from LM symbol of RHS, or, if empty RHS, was set to
                    the scanner's position by lalr-generated code. *) 
                 yyRHSUnnestCoord := WParsAttr . PaUnnestCoord; 
                 WParsAttr := yySynAttribute;
                 IF yySynAttribute . PaUnnestCoord = ParsAttrNull . PaUnnestCoord 
                 THEN (* Semantic actions didn't set it. *) 
                   IF yyStackPtr = yyPrereduceStackPtr + 1 (* Empty reduction *)
                   THEN WParsAttr . PaUnnestCoord := yyPrereduceUnnestCoord; 
                   ELSE WParsAttr . PaUnnestCoord := yyRHSUnnestCoord;
                   END (*IF*);
                 END (*IF*);
                 WParsAttr.Scan.SaTok := yyNonterminal;
              (* ^This requires that tScanAttribute have field 'SaTok'. *)
                 WParsAttr . Scan . Position := yyNTPos (* Parser debug.*) ; 
               END (*WITH*);
               yyStateStack^ [yyStackPtr]
                 := yyState (* Not necessarily a state*) (*ParserDebug*);
               IF yyState < yyFirstFinalState (* read nonterminal? *) 
               THEN (* A true state. *)
                 EXIT 
               END (* IF *) ; 
            END (* LOOP *) ;

         ELSE (* Read Terminal. *)
            INC (yyStackPtr);
            yyStateStack^ [yyStackPtr] := yyState (*A state*) (*ParserDebug*);
            WITH WParsAttr = yyAttributeStack^ [yyStackPtr]
            DO
              WParsAttr.Scan := FM3Scanner.Attribute;
              WParsAttr.PaUnnestCoord := UnnestCoord ( );
(*            PushUnnestStk (WParsAttr); *)
            END (*WITH*);
            yyTerminal := FM3Scanner.GetToken ();
             IF yyRepairsInserted >= 0
                (* ^0 => repair's been happening, tho' with no insertions. *)
             THEN (* Finished with a repair. *)
               EmitSyntErrMsg ( );
               yyRepairsInserted := - 1;
             END (*IF*);
         END (* IF *);
      END (* LOOP *) ;
   END FM3Parser;

PROCEDURE AppendToLine ( FragText : TEXT ) =
   BEGIN
      Wr.PutText (yyErrMsgWrT , FragText);
      INC (yyMsgLineLen, Text.Length (FragText))
   END AppendToLine;

PROCEDURE QuoteAndFillOnLine ( FragText : TEXT ) =
   VAR FragLen : INTEGER;
   BEGIN
      FragLen := Text.Length (FragText);
      IF yyMsgLineLen > FM3Messages.IndentLen
         (* There's already a fragment on this line. *) 
         AND yyMsgLineLen + FragLen + 2 (*For quotes.*)
             > FM3Messages.MsgLineLen (* Frag won't fit. *) 
      THEN
        Wr.PutText ( yyErrMsgWrT, FM3Messages.NLIndent);
        yyMsgLineLen := FM3Messages.IndentLen;
      ELSIF yyMsgLineLen > FM3Messages.IndentLen
      THEN 
        Wr.PutChar (yyErrMsgWrT , ' ');
        INC ( yyMsgLineLen );
      END (*IF*);
      Wr.PutChar (yyErrMsgWrT , '\"');
      Wr.PutText (yyErrMsgWrT , FragText);
      Wr.PutText (yyErrMsgWrT , "\" ");
      INC (yyMsgLineLen, FragLen + 2);
   END QuoteAndFillOnLine; 

PROCEDURE ErrorRecovery (
      VAR Terminal      : yySymbolRange ;
          StateStack    : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType
    ) =
   VAR
      ContinueSet       : IntSets . T;
      RestartSet        : IntSets . T;
      Token             : yySymbolRange;
      TokenText         : TEXT;
      TokenArray        : ARRAY [0..127] OF CHAR;
      InfoText          : TEXT;
      TokensSkipped     : BOOLEAN;

      PROCEDURE VisitTok (Elem: IntSets.ElemT) = 
      VAR TokenText : TEXT;
      BEGIN (*VisitTok*)
         TokenName (Elem, (*OUT*) TokenText);
         QuoteAndFillOnLine (TokenText);
      END VisitTok;

   BEGIN (* ErrorRecovery *)
   (* Start the error message. *) 
     yyErrorPos := FM3Scanner.Attribute.Position;
      yyErrMsgWrT := TextWr . New ( );
      TokenName ( Terminal , (*OUT*) TokenText );
      Wr.PutText (yyErrMsgWrT , "Illegal token: \"");
      Wr.PutText (yyErrMsgWrT , TokenText );
      Wr.PutText (yyErrMsgWrT , "\"" );

   (* Append list of the set of expected terminal symbols. *)
      ComputeContinuation
        (StateStack, StackSize, StackPtr, (*OUT*) ContinueSet);
      IF IntSets.Card(ContinueSet) = 0
      THEN (* Shouldn't happen. *) 
      ELSIF IntSets.Card(ContinueSet) = 1
      THEN
         Wr.PutText ( yyErrMsgWrT, ", expecting \"");
         Token := IntSets . ArbitraryMember (ContinueSet);
         TokenName (Token, (*OUT*) TokenText);
         Wr.PutText ( yyErrMsgWrT, TokenText);  
         Wr.PutText ( yyErrMsgWrT, "\"");  
      ELSE (* Expected set is plural. *)   
         Wr.PutText ( yyErrMsgWrT, ", expecting one of:");
         Wr.PutText ( yyErrMsgWrT, FM3Messages.NLIndent );
         yyMsgLineLen := FM3Messages.IndentLen;
         IntSets . ForAllDo (ContinueSet, VisitTok);
      END (*IF*);

      (* Skip terminal symbols until a restart point is reached *)
      ComputeRestartPoints
        (StateStack, StackSize, StackPtr, (*OUT*) RestartSet);
      TokensSkipped := FALSE;
      WHILE NOT IntSets.IsElement (Terminal, RestartSet) DO
       Terminal := FM3Scanner.GetToken ();
        TokensSkipped := TRUE;
      END (*WHILE*);
      (* Append restart point, if any tokens were skipped. *) 
      IF TokensSkipped
      THEN
         Wr.PutText (yyErrMsgWrT, FM3Messages.NLIndent);
         Wr.PutText (yyErrMsgWrT , "Restarting parse at ");
        FM3SharedUtils.PutPosImage ( yyErrMsgWrT , FM3Scanner.Attribute.Position );
      END (*IF*);

      ContinueSet := NIL;
      RestartSet := NIL;
   END ErrorRecovery;

PROCEDURE EmitSyntErrMsg ( ) =
   VAR ErrorMsgText : TEXT;
   BEGIN 
      ErrorMsgText := TextWr.ToText (yyErrMsgWrT);
      FM3Messages.ErrorArr
        ( ARRAY OF REFANY { ErrorMsgText } , yyErrorPos );
      yyErrMsgWrT := NIL; 
   END EmitSyntErrMsg;

(*
   compute the set of terminal symbols that can be accepted (read)
   in a given stack configuration (eventually after reduce actions)
*)

PROCEDURE ComputeContinuation (
          Stack         : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType;
      VAR ContinueSet   : IntSets . T     ) =
   VAR Terminal         : yySymbolRange;
   BEGIN
      ContinueSet:= IntSets . Empty ( );
      FOR Terminal := yyFirstTerminal TO yyLastTerminal DO
         IF IsContinuation (Terminal, Stack, StackSize, StackPtr) THEN
            ContinueSet := IntSets . Include ( ContinueSet , Terminal )
         END;
      END;
   END ComputeContinuation;

(*
   check whether a given terminal symbol can be accepted (read)
   in a certain stack configuration (eventually after reduce actions)
*)

PROCEDURE IsContinuation (
      Terminal          : yySymbolRange ;
      ParseStack        : yyStackType   ;
      StackSize         : INTEGER       ;
      StackPtr          : yyStackPtrType): BOOLEAN =
   VAR
      State             : yyStateRange;
      Nonterminal       : yySymbolRange;
      Stack             : yyStackType;
   BEGIN
      Stack := NEW (yyStackType, StackSize);
      SUBARRAY (Stack^, 0, StackPtr+1 )
        := SUBARRAY (ParseStack^, 0, StackPtr+1 );
      State := Stack^ [StackPtr];
      LOOP
         Stack^ [StackPtr] := State;
         State := Next (State, Terminal);
         IF State = yyNoState THEN
            Stack := NIL;
            RETURN FALSE;
         END;
         IF State <= yyLastReadTermState (* read or read terminal reduce ? *)
         THEN
            Stack := NIL;
            RETURN TRUE;
         END;
         
         LOOP (* reduce *)
            IF State =  yyStopState THEN
               Stack := NIL; 
               RETURN TRUE;
            ELSE 
               DEC (StackPtr, yyLength [State]);
               Nonterminal := yyLeftHandSide [State];
            END;

            State := Next (Stack^ [StackPtr], Nonterminal);
            (* Ensure Stack has room for at least 2 elements. *)
            IF StackPtr >= StackSize THEN
              ExpandStateStack
                (Stack, MAX (NUMBER ( Stack ^ ) * 2 , StackPtr + 2 ) );
              StackSize := NUMBER (Stack^); 
            END;
            INC (StackPtr);
            Stack^ [StackPtr] := State (*ParserDebug*);
            IF State < yyFirstFinalState
            THEN EXIT;
            END; (* read nonterminal ? *)
            State := yyFinalToProd [State]; (* read nonterminal reduce *)
            Stack^ [StackPtr] := State (*ParserDebug*);
         END;
      END;
    END IsContinuation;
(*
   compute a set of terminal symbols that can be used to restart
   parsing in a given stack configuration. we simulate parsing until
   end of file using a suffix program synthesized by the function
   Continuation. All symbols acceptable in the states reached during
   the simulation can be used to restart parsing.
*)

PROCEDURE ComputeRestartPoints (
          ParseStack    : yyStackType   ;
          StackSize     : INTEGER       ;
          StackPtr      : yyStackPtrType;
      VAR RestartSet    : IntSets.T     ) =
   VAR
      Stack             : yyStackType;
      State             : yyStateRange;
      Nonterminal       : yySymbolRange;
      ContinueSet       : IntSets.T;
   BEGIN
      RestartSet := IntSets . Empty ( );
      Stack := NEW (yyStackType, StackSize);
      SUBARRAY (Stack^, 0, StackPtr+1 )
        := SUBARRAY (ParseStack^, 0, StackPtr+1 );
      ContinueSet := IntSets . Empty ( );
      State := Stack^ [StackPtr];

      LOOP
         (* Ensure Stack has room for at least 2 elements. *)
         IF StackPtr >= StackSize THEN
            ExpandStateStack
              (Stack, MAX (NUMBER (Stack ^) * 2 , StackPtr + 2 ) );
            StackSize := NUMBER (Stack^); 
         END;
         Stack^ [StackPtr] := State;
         ComputeContinuation (Stack, StackSize, StackPtr, (*OUT*) ContinueSet);
         RestartSet := IntSets.Union (RestartSet, ContinueSet);
         State := Next (State, yyContinuation [State]);

          IF State >= yyFirstFinalState THEN (* final state ? *)
            IF State <= yyLastReadTermState THEN (* read terminal reduce ? *)
               INC (StackPtr);
               State := yyFinalToProd [State];
               Stack^ [StackPtr] := State (*ParserDebug*);
            END;

            LOOP (* reduce *)
               IF State = yyStopState THEN
                  Stack := NIL;
                  ContinueSet := NIL;
                  RETURN;
               ELSE 
                  DEC (StackPtr, yyLength [State]);
                  Nonterminal := yyLeftHandSide [State];
               END;

               State := Next (Stack^ [StackPtr], Nonterminal);
               INC (StackPtr);
               IF State < yyFirstFinalState
               THEN EXIT;
               END; (* read nonterminal ? *)
               State := yyFinalToProd [State]; (* read nonterminal reduce *)
            END (*LOOP*);
         ELSE (* read *)
            INC (StackPtr);
         END;
      END;
   END ComputeRestartPoints;

(* access the parse table:   Next : State x Symbol -> State *)

PROCEDURE Next
   (State: yyStateRange; Symbol: yySymbolRange)
   : yyStateRange =
   VAR
      TCombPtr          : yyTCombTypePtr;
      NCombPtr          : yyNCombTypePtr;
   BEGIN
      IF Symbol <= yyLastTerminal THEN
         LOOP
            TCombPtr 
              := LOOPHOLE 
                   ( LOOPHOLE (yyTBasePtr [State],INTEGER) 
                     + Symbol * BYTESIZE (yyTCombType)
                   ,yyTCombTypePtr);
            IF TCombPtr^.Check # State THEN
               State := yyDefault [State];
               IF State = yyNoState THEN RETURN yyNoState; END;
            ELSE
               RETURN TCombPtr^.Next;
            END;
         END;
      ELSE
        NCombPtr 
          := LOOPHOLE 
               ( LOOPHOLE (yyNBasePtr [State],INTEGER) 
                 + (Symbol-(yyLastTerminal+1))
                   * BYTESIZE (yyNCombType)
               ,yyNCombTypePtr);
        RETURN NCombPtr^;
      END;
   END Next;
   
  PROCEDURE BeginFM3Parser ()=
   BEGIN
(* line 89 "FM3Parser.lalr" *)
 
      IF NOT yyIsInitialized THEN
         yyIsInitialized := TRUE;
      END;
   END BeginFM3Parser;

(*EXPORTED*)
  PROCEDURE CloseFM3Parser ()=
   BEGIN
(* line 92 "FM3Parser.lalr" *)
 
   END CloseFM3Parser;

BEGIN
    <*ASSERT BYTESIZE (yyTableElmt) = 2 *>
    yyIsInitialized := FALSE;
     ParsTabName := "FM3Parser.Tab";
  END FM3Parser.

