 
(* -----------------------------------------------------------------------1- *)
(* This file is part of the FM3 Modula-3 compiler.                           *)
(* Copyright 2023,       Rodney M. Bates.                                    *)
(* rodney.m.bates@acm.org                                                    *)
(* Licensed under the MIT License.                                           *)
(* -----------------------------------------------------------------------2- *)

(* File FM3Parser.lalr.  lalr specification for FM3Parser. *)

SCANNER FM3Scanner

PARSER FM3Parser

/* Stuff to go into the parser interface. */ 
EXPORT
  { IMPORT FM3IntToks;
    IMPORT FM3ParsePass;
  }

/* Stuff to go at front of the parser module, at global scope. */
GLOBAL

  { IMPORT FM3Base;
    IMPORT FM3Messages;
    IMPORT FM3Globals;
    IMPORT FM3IntToks AS Itk;
    IMPORT FM3ParsePass;
    FROM FM3ParsePass IMPORT UnnestCoord;
    FROM FM3ParsePass IMPORT tParsAttribute;
    FROM FM3ParsePass IMPORT ParsAttrNull;
    FROM FM3ParsePass IMPORT FormalModeTyp;
(*TODO: ^Where does this belong? *) 
    FROM FM3ParsePass IMPORT PushUnnestStk , PushUnnest, PushUnnestLong;
    FROM FM3ParsePass IMPORT
      Push_T , Push_TP , Push_TCr , Push_TCPrp , Push_TCBr , Push_TCIri , 
      Push_TI3 , Push_TI6 , Push_TCoCr , Push_TCIoCri , Pop4 , Pop8 ;
    FROM FM3ParsePass IMPORT MakeList , MakeListPos;
    IMPORT FM3Scopes;
    IMPORT FM3Units;
    FROM FM3Utils IMPORT PositionImage;
  }

/* Global declarations of the Parser procedure. */ 
LOCAL
  { TYPE Sk = FM3Scopes . ScopeKindTyp ; 
  }

/* Parser module initialization. */ 
BEGIN
  { FrontErrors . SetReportMode ( FrontErrors . tReportMode . eImmediate ); 
  }

/* Parser module final cleanup. */ 
CLOSE { }

(* Source code terminal tokens. *)
(* Copied in from GenTok output and edited. *) 
TOKEN

/* ----------------------- Source code tokens: --------------------------- */ 

(* I tried hard to get this token naming & numbering in just
   one place, but it is just too much tangential work for the
   benefit.  These are manually copied and edited from generated
   FM3SrcToks.i3, which they must be kept in sync with.  Other
   Modula-3 code will use the declarations from FM3SrcToks.i3.
   FM3SrcToks.i3 is generated by metaprogram GenTok, from input
   file FM3SrcToks.gentok.
*)

(* These are probably not used by lalr: 
    TkMinTok                                     =     1

    StkUnknown                                   =     1 (*16_01 *)
    StkBOF                                       =     2 (*16_02 *)
    StkEOF                                       =     3 (*16_03 *)
*)

    (* Reserved words: *) 
    StkRwAND                                     =     5 (*16_05 *)
    StkRwANY                                     =     6 (*16_06 *)
    StkRwARRAY                                   =     7 (*16_07 *)
    StkRwAS                                      =     8 (*16_08 *)
    StkRwBEGIN                                   =     9 (*16_09 *)
    StkRwBITS                                    =    10 (*16_0a *)
    StkRwBRANDED                                 =    11 (*16_0b *)
    StkRwBY                                      =    12 (*16_0c *)
    StkRwCASE                                    =    13 (*16_0d *)
    StkRwCONST                                   =    14 (*16_0e *)
    StkRwDIV                                     =    15 (*16_0f *)
    StkRwDO                                      =    16 (*16_10 *)
    StkRwELSE                                    =    17 (*16_11 *)
    StkRwELSIF                                   =    18 (*16_12 *)
    StkRwEND                                     =    19 (*16_13 *)
    StkRwEVAL                                    =    20 (*16_14 *)
    StkRwEXCEPT                                  =    21 (*16_15 *)
    StkRwEXCEPTION                               =    22 (*16_16 *)
    StkRwEXIT                                    =    23 (*16_17 *)
    StkRwEXPORTS                                 =    24 (*16_18 *)
    StkRwFINALLY                                 =    25 (*16_19 *)
    StkRwFOR                                     =    26 (*16_1a *)
    StkRwFROM                                    =    27 (*16_1b *)
    StkRwGENERIC                                 =    28 (*16_1c *)
    StkRwIF                                      =    29 (*16_1d *)
    StkRwIMPORT                                  =    30 (*16_1e *)
    StkRwIN                                      =    31 (*16_1f *)
    StkRwINTERFACE                               =    32 (*16_20 *)
    StkRwLOCK                                    =    33 (*16_21 *)
    StkRwLOOP                                    =    34 (*16_22 *)
    StkRwMETHODS                                 =    35 (*16_23 *)
    StkRwMOD                                     =    36 (*16_24 *)
    StkRwMODULE                                  =    37 (*16_25 *)
    StkRwNOT                                     =    38 (*16_26 *)
    StkRwOBJECT                                  =    39 (*16_27 *)
    StkRwOF                                      =    40 (*16_28 *)
    StkRwOR                                      =    41 (*16_29 *)
    StkRwOVERRIDES                               =    42 (*16_2a *)
    StkRwPROCEDURE                               =    43 (*16_2b *)
    StkRwRAISE                                   =    44 (*16_2c *)
    StkRwRAISES                                  =    45 (*16_2d *)
    StkRwREADONLY                                =    46 (*16_2e *)
    StkRwRECORD                                  =    47 (*16_2f *)
    StkRwREF                                     =    48 (*16_30 *)
    StkRwREPEAT                                  =    49 (*16_31 *)
    StkRwRETURN                                  =    50 (*16_32 *)
    StkRwREVEAL                                  =    51 (*16_33 *)
    StkRwROOT                                    =    52 (*16_34 *)
    StkRwSET                                     =    53 (*16_35 *)
    StkRwTHEN                                    =    54 (*16_36 *)
    StkRwTO                                      =    55 (*16_37 *)
    StkRwTRY                                     =    56 (*16_38 *)
    StkRwTYPE                                    =    57 (*16_39 *)
    StkRwTYPECASE                                =    58 (*16_3a *)
    StkRwUNSAFE                                  =    59 (*16_3b *)
    StkRwUNTIL                                   =    60 (*16_3c *)
    StkRwUNTRACED                                =    61 (*16_3d *)
    StkRwVALUE                                   =    62 (*16_3e *)
    StkRwVAR                                     =    63 (*16_3f *)
    StkRwWHILE                                   =    64 (*16_c0 00 *)
    StkRwWITH                                    =    65 (*16_c1 00 *)
    
    (* Special character tokens: *)
    StkSemicolon                                 =    66 (*16_c2 00 *)
    StkDot                                       =    67 (*16_c3 00 *)
    StkEqual                                     =    68 (*16_c4 00 *)
    StkOpenParen                                 =    69 (*16_c5 00 *)
    StkCloseParen                                =    70 (*16_c6 00 *)
    StkComma                                     =    71 (*16_c7 00 *)
    StkColon                                     =    72 (*16_c8 00 *)
    StkSubtype                                   =    73 (*16_c9 00 *)
    StkBecomes                                   =    74 (*16_ca 00 *)
    StkOpenBrace                                 =    75 (*16_cb 00 *)
    StkCloseBrace                                =    76 (*16_cc 00 *)
    StkStroke                                    =    77 (*16_cd 00 *)
    StkArrow                                     =    78 (*16_ce 00 *)
    StkEllipsis                                  =    79 (*16_cf 00 *)
    StkOpenBracket                               =    80 (*16_d0 00 *)
    StkCloseBracket                              =    81 (*16_d1 00 *)
    StkUnequal                                   =    82 (*16_d2 00 *)
    StkLess                                      =    83 (*16_d3 00 *)
    StkGreater                                   =    84 (*16_d4 00 *)
    StkLessEqual                                 =    85 (*16_d5 00 *)
    StkGreaterEqual                              =    86 (*16_d6 00 *)
    StkPlus                                      =    87 (*16_d7 00 *)
    StkMinus                                     =    88 (*16_d8 00 *)
    StkAmpersand                                 =    89 (*16_d9 00 *)
    StkStar                                      =    90 (*16_da 00 *)
    StkSlash                                     =    91 (*16_db 00 *)
    StkDeref                                     =    92 (*16_dc 00 *)
    StkOpenPragma                                =    93 (*16_dd 00 *)
    StkClosePragma                               =    94 (*16_de 00 *)
    
    (* Variable tokens: *)
    StkIdent                                     =    95 (*16_df 00 *)
    StkIntLit                                    =    96 (*16_e0 00 *)
    StkLongIntLit                                =    97 (*16_e1 00 *)
    StkBasedLit                                  =    98 (*16_e2 00 *)
    StkLongBasedLit                              =    99 (*16_e3 00 *)
    StkRealLit                                   =   100 (*16_e4 00 *)
    StkLongRealLit                               =   101 (*16_e5 00 *)
    StkExtendedLit                               =   102 (*16_e6 00 *)
    StkTextLit                                   =   103 (*16_e7 00 *)
    StkWideTextLit                               =   104 (*16_e8 00 *)
    StkCharLit                                   =   105 (*16_e9 00 *)
    StkWideCharLit                               =   106 (*16_ea 00 *)
    StkLexErrChars                               =   107 (*16_eb 00 *)

(* END of copied-in token decls from FM3SrcToks.i3. *) 





 
(* ------------------------------- Productions. ---------------------------- *)

(* NOTE regarding the parser's default setting of the PaUnnestCoord field:
   A shift, including an error repair insertion, copies the current unnest
   stack pointer into .PaUnnestCoord.  For a reduce, and if the semantic
   action doesn't set PaUnnestCoord, then the parser sets it to a default.
   If the RHS is empty, this is the current unnest stack pointer.  If the
   reduce is nonempty, this is a copy from the leftmost RHS's attribute.
*) 


RULE

(* Compilation units: *) 
   Compilation : Interface . 
   Compilation : Module .
   Compilation : GenInterface . 
   Compilation : GenModule . 
   Compilation : InstInterface . 
   Compilation : InstModule .

   Interface :
       OptUnsafe StkRwINTERFACE StkIdent StkSemicolon
       Imports DeclList StkRwEND StkIdent StkDot .

   Module :
       OptUnsafe StkRwMODULE StkIdent Exports StkSemicolon
       Imports Block StkIdent StkDot .

   GenInterface :
       StkRwGENERIC StkRwINTERFACE StkIdent GenFormalList StkSemicolon
       Imports DeclList StkRwEND StkIdent StkDot . 

   GenModule :
       StkRwGENERIC StkRwMODULE StkIdent GenFormalList StkSemicolon
       Imports Block StkIdent StkDot . 

   InstInterface :
       OptUnsafe StkRwINTERFACE StkIdent StkEqual
       StkIdent GenActualList
       StkRwEND StkIdent StkDot . 

   InstModule :
       OptUnsafe StkRwMODULE StkIdent Exports StkEqual
       StkIdent GenActualList
       StkRwEND StkIdent StkDot . 

(* WARNING: Do not put a lone single quote in a semantic action, e.g.:
            (* Don't do this. *).  Probably applies to double quote too.
            lalr will run to the end of its internal buffer looking
            for its mate and give an unclosed string error. *)
            
   OptUnsafe : StkRwUNSAFE { $$ . PaBool (* Unsafe.*) := TRUE ; } .
   OptUnsafe : { $$ . PaBool (* Unsafe.*) := FALSE (* Safe. *) ; }.

   CaptureCoord : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
     
   OptSemicolon : StkSemicolon .
   OptSemicolon : /*Empty*/ . 

 
(* ----------------------------- Identifier lists ---------------------- *)

(* List of one or more comma-separated Idents.*)
   IdPlusList : StkIdent 
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
     } . 
   IdPlusList : IdPlusList StkComma StkIdent
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := $1 . PaInt + 1 ;
     } . 

(* List of one or more comma-separated declaring occurrences of Idents.*)
   DeclIdPlusList : StkIdent 
     { (* PaUnnestCoord copied from $1 by parser. *) 
       $$ . PaInt := 1 ;
       FM3Scopes . DeclId ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
     } . 
   DeclIdPlusList : DeclIdPlusList StkComma StkIdent
     { (* PaUnnestCoord copied from $1 by parser . *) 
       $$ . PaInt := $1 . PaInt + 1 ;
       FM3Scopes . DeclId ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
     } . 

(* List of zero or more comma-separated Idents. *)
   IdStarList : IdStarList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ; } . 
   IdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 

(* List of zero or more comma-separated qualified Idents. *)
   QualIdStarList : QualIdStarList StkComma QualId
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   QualIdStarList : /*Empty*/
     { $$ . PaInt := 0 ; } . 
     
(* Qualified ident. *)   
   QualId : StkIdent .
   QualId : StkIdent StkDot StkIdent
     { Push_TCoCr
         ( Itk . ItkQualIdLt ,  $1 . PaUnnestCoord , $3 . PaUnnestCoord );
     } .

(*  ----------------------------- Imports -----------------------. *) 

   Imports : ImportsLt ImportsRecurse ImportsRt 
     { $$ . PaInt := $2 . PaInt (* Imported interface Count. *) ;
       $$ . PaLong := $2 . PaLong (* Imported unqualified Ident Count. *) ;
     } .
   ImportsLt : /*Empty*/ { FM3ParsePass . ImportsLt ( ) ; } . 
   ImportsRt : /*Empty*/ { FM3ParsePass . ImportsRt ( ) ; } . 
   ImportsRecurse : ImportsRecurse ImportItem  
     { $$ . PaInt := $1 . PaInt + $2 . PaInt ;
       $$ . PaLong := $1 . PaLong + $2 . PaLong ;
     } .
   ImportsRecurse : /*Empty*/
     { $$ . PaInt := 0; 
       $$ . PaLong := 0L; 
     } . 

   (* IMPORT .. *) 
   ImportItem : StkRwIMPORT ImportIntfPlusList StkSemicolon  
     { $$ . PaInt := $2 . PaInt ;
       $$ . PaLong := 0L ; 
     } .
   ImportIntfPlusList : StkIdent 
     { $$ . PaInt := 1 ;
       FM3ParsePass . Import
         ( $1 . Scan . SaAtom , $1 . Scan . Position ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       Push_TI3
         ( Itk . ItkImport
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         ) ;
     } . 
   ImportIntfPlusList : ImportIntfPlusList StkComma StkIdent
     { $$ . PaInt := $1 . PaInt + 1 ;
       Pop4 ( ) (* Replace the Ident with an ItkImport. *) ; 
       FM3ParsePass . Import
         ( $3 . Scan . SaAtom , $3 . Scan . Position ) ; 
       Push_TI3
         ( Itk . ItkImport
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

   (* FROM Id IMPORT ... *) 
   ImportItem : FromImportPlusList StkSemicolon 
     { $$ . PaInt := $1 . PaInt ;
       $$ . PaLong := $1 . PaLong ; 
     } .
   FromImportPlusList : StkRwFROM StkIdent StkRwIMPORT StkIdent
     { $$ . PaInt := 1 (* InterfaceCt. *) ;
       $$ . PaLong := 1L ;
       $$ . Scan . SaAtom := $2 . Scan . SaAtom ; 
       $$ . Scan . Position := $2 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $2 . Scan . SaAtom
         , $2 . Scan . Position 
         , $4 . Scan . SaAtom
         , $4 . Scan . Position 
         ) ; 
       Pop8 ( ) (* Replace the 2 Idents with an ItkFromImport. *) ; 
       Push_TI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $2 . Scan . SaAtom
         , $2 . Scan . Position . Line
         , $2 . Scan . Position . Column
         , $4 . Scan . SaAtom
         , $4 . Scan . Position . Line
         , $4 . Scan . Position . Column
         ) ;
     } . 
   FromImportPlusList : FromImportPlusList StkComma StkIdent
     { $$ . PaInt := 1 ;
       $$ . PaLong := $1 . PaLong + 1L ;
       $$ . Scan . SaAtom := $1 . Scan . SaAtom ; 
       $$ . Scan . Position := $1 . Scan . Position ; 
       FM3ParsePass . FromImport
         ( $1 . Scan . SaAtom
         , $1 . Scan . Position 
         , $3 . Scan . SaAtom
         , $3 . Scan . Position 
         ) ; 
       Pop4 ( ) (* Replace the Ident with an ItkFromImport. *) ;
       Push_TI6
         ( Itk . ItkFromImport
           (* Interface operands on left, then Decl ID items on Right. *) 
         , $1 . Scan . SaAtom
         , $1 . Scan . Position . Line
         , $1 . Scan . Position . Column
         , $3 . Scan . SaAtom
         , $3 . Scan . Position . Line
         , $3 . Scan . Position . Column
         ) ;
     } . 

(* IMPORT Id AS Id; *)
(*
   ImportItem : StkRwFROM StkIdent StkRwIMPORT IdPlusList StkSemicolon 
     { $$ . PaInt := 1 ;
       $$ . PaLong := VAL ( $4 . PaInt (* IdPlusList Ct. *) , LONGINT ) ;
       Push_TCIoCri
         ( Itk . ItkImportAsLt, $1 . PaUnnestCoord, $4 . PaInt , $3 . PaUnnestCoord );
     } .
*)
(* ------------------------------- Exports ------------------------- . *)
(* Exports.  Possibly absent, in which case construct "EXPORTS Main".
   Otherwise contains at least one ident. Bracket with ItkExportList*.
*) 

   Exports : StkRwEXPORTS IdPlusList 
     { MakeListPos
         ( $$ , Itk . ItkExportIdListLt , $1 . Scan . Position , $2 ) ;
     } .
   Exports : /*Empty*/
     { FM3ParsePass . PushEXPORTSMain ( $0 . Scan . Position ) ; } .

(* ------------------------ Generic parameters ---------------------- . *)
(* GenFormalList.  Zero or more idents. Bracket list with ItkGenFormalList*. *) 
   GenFormalList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos 
         ( $$ , Itk. ItkGenFormalIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* GenActualList.  Zero or more idents. Bracket list with ItkGenActualList*. *) 
   GenActualList : StkOpenParen IdStarList StkCloseParen 
     { MakeListPos
         ( $$ , Itk. ItkGenActualIdListLt , $1 . Scan . Position , $2 ) ;
     } .

(* -------------------------- Type Declarations. --------------------- . *)

   TypeDeclGroup : StkRwTYPE TypeDecls .
   TypeDecls : TypeDecl . 
   TypeDecls : TypeDecls TypeDecl . 
   TypeDecl : StkIdent StkEqual Type StkSemicolon .

(* ------------------------- Constant Declarations -------------------- . *) 

   ConstDeclGroup : StkRwCONST ConstDecls .
   ConstDecls : ConstDecl . 
   ConstDecls : ConstDecls ConstDecl . 
   ConstDecl : StkIdent OptConstType StkEqual Expr .
   OptConstType : StkColon Type
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ; } . 
   OptConstType : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ;
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
     } . 

(* ------------------------- Variable Declarations -------------------- . *) 

   VarDeclGroup : StkRwVAR VarDecls .
   VarDecls : VarDecl . 
   VarDecls : VarDecls VarDecl . 
   VarDecl : StkIdent OptVarType OptVarValue
     { IF NOT $2 . PaBool AND NOT $3 . PaBool
       THEN
         FM3Messages . Error
           ( PositionImage ( $1 . Scan . Position )
           , " VAR decl must have a type and/or an initial value. (2.4.3)."
           );
       END (*IF*) 
     } .
   OptVarType : StkColon Type 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ; } . 
   OptVarType : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ); 
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
     } . 
   OptVarValue : StkBecomes Expr 
     { $$ . PaUnnestCoord := $1 . PaUnnestCoord ;
       $$ . PaBool (* Present. *) := TRUE ; } . 
   OptVarValue : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ); 
       $$ . PaBool (* Present. *) := FALSE (* Absent. *) ;
     } . 

(* --------------------------------- Types ----------------------------- *)

   Type : StkIdent . 
   Type : RecordType .

   RecordType : StkRwRECORD VarDecl StkRwEND . 

(* -------------------------------- Procedures ------------------------- *)

(* Procedure signature (without PROCEDURE or Ident). *) 
   Signature : Formals ResultType Raises
     { VAR LTok : Itk . TokTyp;
       BEGIN
         IF $2 . PaBool
         THEN LTok := Itk . ItkFuncSignatureLt ;
         ELSE LTok := Itk . ItkProcSignatureLt ;
         END (*IF*);
         Push_TCPrp ( LTok,  $1 . PaUnnestCoord , $1 . Scan . Position );
       END (*Block*) 
     }.

(* List of formal decls. *) 
   Formals : StkOpenParen StkCloseParen /* Empty formals list. */
     { $$ . Scan . Position := $1 . Scan . Position ;
       FM3Scopes . ScopeEmpty ( Sk . SkFormals ) ; 
       PushUnnest ( Itk . ItkFormalsListEmpty )
     } .
   Formals : StkOpenParen FormalsLt FormalsPlusList OptSemicolon StkCloseParen
     { $$ . Scan . Position := $1 . Scan . Position ;
       FM3Scopes . ScopeRt ( Sk . SkFormals ) ;
       MakeListPos
         ( $$ , Itk . ItkFormalsListLt , $1 . Scan . Position , $3 ) ;
     } .
   FormalsLt : /*Empty*/
     { FM3Scopes . ScopeLt ( Sk . SkFormals ) ; } . 
   FormalsPlusList : FormalsPlusList StkSemicolon Formal 
     { $$ . PaInt := $1 . PaInt + 1 (* Formal count. *); } .  
   FormalsPlusList : Formal 
     { $$ . PaInt := 1 (* Formal count. *) ; } .

(* Formal decl (with possibly multiple idents). *)
   Formal : FormalModeAndIds FormalType FormalExpr
     { IF $1 . PaByte = ORD ( FormalModeTyp . FmVAR )  
       THEN
         IF NOT $2 . PaBool (* Formal type is present (absent). *)
         THEN
           FM3Messages . Error
             ( PositionImage ( $2 . Scan . Position )
             , " VAR formal must have a type (2.2.8)."
             );
         END (*IF*) ; 
         IF $3 . PaBool (* Formal expression is present. *) 
         THEN
           FM3Messages . Error
             ( PositionImage ( $3 . Scan . Position )
             , " VAR formal cannot have a default expression  (2.2.8)."
             );
         END (*IF*) ; 
       ELSIF NOT ( $2 . PaBool (* Type is present (absent). *) )
             AND NOT ( $3 . PaBool
                       (* Default expression is present (absent). *) ) 
       THEN 
         FM3Messages . Error
           ( PositionImage ( $1 . Scan . Position )
           , " Formal must have a type and/or default expression (2.2.8)." );
       END (*IF*);
     } .

   FormalModeAndIds : FormalMode DeclIdPlusList
     { $$ . PaByte := $1 . PaByte (* Transmission mode. *) ;
       $$ . Scan . Position := $1 . Scan . Position ;   
       MakeListPos
         ( $$ , $1 . PaInt (* List Itk *) , $1 . Scan . Position , $2 ); 
     } . 

(* Formal parameter modes. *) 
   FormalMode : StkRwVALUE 
     { $$ . PaByte := ORD ( FormalModeTyp . FmVALUE );
       $$ . PaInt := Itk . ItkFormalVALUEIdListLt;
       $$ . Scan . Position := $1 . Scan . Position; 
     } .
   FormalMode : StkRwVAR 
     { $$ . PaByte := ORD ( FormalModeTyp . FmVAR );
       $$ . PaInt := Itk . ItkFormalVARIdListLt; 
       $$ . Scan . Position := $1 . Scan . Position; 
     } .
   FormalMode : StkRwREADONLY
     { $$ . PaByte := ORD ( FormalModeTyp . FmREADONLY );
       $$ . PaInt := Itk . ItkFormalREADONLYIdListLt; 
       $$ . Scan . Position := $1 . Scan . Position; 
     } .
   FormalMode : /*Empty*/
     { $$ . PaByte := ORD ( FormalModeTyp . FmVALUE );
       $$ . PaInt := Itk . ItkFormalVALUEIdListLt; 
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
     } .

(* Formal parameter type. *) 
   FormalType : StkColon Type
     { $$ . PaBool (* Type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TCPrp
         ( Itk . ItkFormalTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position ); 
     } .
   FormalType : /*Empty*/
     { $$ . PaBool (* Type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_TP
         ( Itk . ItkFormalTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Formal parameter default value. *) 
   FormalExpr : StkBecomes Expr 
     { $$ . PaBool (* Expr is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TCPrp
         (  Itk . ItkFormalExprLt, $1 . PaUnnestCoord , $1 . Scan . Position ); 
     } .
   FormalExpr : /*Empty*/
     { $$ . PaBool (* Expr is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_TP
         ( Itk . ItkFormalExprAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature result type. *) 
   ResultType : StkColon Type 
     { $$ . PaBool (* Result type is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TCPrp
         (Itk . ItkResultTypeLt,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } .
   ResultType : /*Empty*/
     { $$ . PaBool (* Result type is present. *) := FALSE (* Absent. *) ;
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_TP
         ( Itk . ItkResultTypeAbsent , FM3Scanner . Attribute . Position ) ;
     } .

(* Signature RAISES. *) 
   Raises : StkRwANY
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TCPrp
         ( Itk . ItkRaisesANY ,  $1 . PaUnnestCoord , $1 . Scan . Position); 
     } . 
   Raises
     : StkRwRAISES StkOpenBrace QualIdStarList StkCloseBrace 
     { $$ . PaBool (* Raises set is present. *) := TRUE;
       $$ . Scan . Position := $1 . Scan . Position; 
       MakeListPos ( $$ , Itk . ItkRaisesSetLt , $1 . Scan . Position, $3 ) ;
     } . 
   Raises : /*Empty*/
     { $$ . PaBool (* Raises set is present. *) := FALSE (* Absent. *);
       $$ . Scan . Position := FM3Scanner . Attribute . Position; 
       Push_TP
         ( Itk . ItkRaisesSetAbsent , FM3Scanner . Attribute . Position ); 
     } .

(* ------------------------------ Procedures ------------------------------ *)

   ProcDecl : StkRwPROCEDURE StkIdent Signature OptBody 
     { VAR LTokLt : Itk . TokTyp; 
       BEGIN 
         CASE FM3Globals . CurrentUnitRef ^ . UntKind OF 
         | FM3Units . UnitKindTyp . UkInterface  
         , FM3Units . UnitKindTyp . UkGenInterface  
         => IF $4 . PaBool 
            THEN
              FM3Messages . Error
                ( PositionImage ( $4 . Scan . Position )
                , " A procedure in an interface must not have a body (2.5.2)."
                ); 
            END (*IF*); 
            LTokLt := Itk . ItkProcNoBodyLt ; 
         | FM3Units . UnitKindTyp . UkModule  
         , FM3Units . UnitKindTyp . UkGenModule  
         => IF NOT $4 . PaBool 
            THEN 
              FM3Messages . Error
                ( PositionImage ( $4 . Scan . Position )
                , " A procedure in a module must have a body (2.5)."
                ); 
            END (*IF*); 
            LTokLt := Itk . ItkProcWBodyLt ; 
(* TODO: Error recovery.  Insert or remove body. *) 
         ELSE (* Can't happen. *) 
         END (*CASE*);
         Push_TCIri
           ( LTokLt,  $1 . PaUnnestCoord, $2 . Scan . SaAtom ); 
       END (*Block*) 
     } . 

(*
   OptBody : OptBodyAbsent .  
   OptBody : OptBodyPresent .
*)
   OptBody : StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := FALSE (* Absent. *) ; 
       $$ . PaConstructNo := FM3Base . AtomNull ; 
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TP ( Itk . ItkProcBodyAbsent , $1 . Scan . Position ); 
     } . 
   OptBody : StkEqual Block StkIdent StkSemicolon 
     { $$ . PaBool (* Procedure has a body. *) := TRUE ; 
       $$ . PaConstructNo := $3 . Scan . SaAtom ;
       $$ . Scan . Position := $1 . Scan . Position; 
       Push_TCPrp
         ( Itk . ItkProcBodyLt,  $1 . PaUnnestCoord , $1 . Scan . Position );
     } . 


(* ---------------------------- Expressions ---------------------------- *)

Expr: StkIdent .


(* ------------------------------ Blocks ------------------------------- *)

   Block : BlockLt DeclList StkRwBEGIN Stmts StkRwEND .
   BlockLt : /*EMPTY*/
     { FM3ParsePass . BeginBlock ( ) (* Pushes nothing. *) ; } .

   DeclList : DeclListRecurse
     { MakeList ( $$ , Itk . ItkDeclListLt , $1 ) ; } .  
   DeclListRecurse : DeclListRecurse Decl  
     { $$ . PaInt := $1 . PaInt + 1 ; } .
   DeclListRecurse : /*Empty*/
     { $$ . PaInt := 0 ; } .

   Decl : ConstDeclGroup .
   Decl : VarDeclGroup .
   Decl : TypeDeclGroup . 
   Decl : ProcDecl . 
 
(* ---------------------------- Statements ----------------------------- *)

   Stmts : StmtPlusList OptSemicolon .
   StmtPlusList : Stmt . 
   StmtPlusList : StmtPlusList StkSemicolon Stmt . 
   Stmts : /*Empty*/
     { $$ . PaUnnestCoord := UnnestCoord ( ) ; } .
   
(* ---------------------------- Assignment statements ------------------ *)

   Stmt : AssignStmt .

   AssignStmt : Expr StkBecomes Expr . 

(* END of FM3Parser.lalr. *)


